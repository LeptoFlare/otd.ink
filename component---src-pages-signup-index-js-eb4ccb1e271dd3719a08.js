(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{"5VHT":function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__("M/dN");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2xlYXZlLmpzL3JlYWN0LmpzP2FjZjUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCLG1CQUFPLENBQUMsTUFBNkIiLCJmaWxlIjoiNVZIVC5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L2NsZWF2ZS1yZWFjdC1ub2RlLmpzJyk7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5VHT\n')},"M/dN":function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {__webpack_require__(\"E9XD\");\n\n(function webpackUniversalModuleDefinition(root, factory) {\n  if (true) module.exports = factory(__webpack_require__(\"q1tI\"));else {}\n})(this, function (__WEBPACK_EXTERNAL_MODULE_1__) {\n  return (\n    /******/\n    function (modules) {\n      // webpackBootstrap\n\n      /******/\n      // The module cache\n\n      /******/\n      var installedModules = {};\n      /******/\n      // The require function\n\n      /******/\n\n      function __webpack_require__(moduleId) {\n        /******/\n        // Check if module is in cache\n\n        /******/\n        if (installedModules[moduleId])\n          /******/\n          return installedModules[moduleId].exports;\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n        var module = installedModules[moduleId] = {\n          /******/\n          exports: {},\n\n          /******/\n          id: moduleId,\n\n          /******/\n          loaded: false\n          /******/\n\n        };\n        /******/\n        // Execute the module function\n\n        /******/\n\n        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n        /******/\n        // Flag the module as loaded\n\n        /******/\n\n        module.loaded = true;\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n        return module.exports;\n        /******/\n      }\n      /******/\n      // expose the modules object (__webpack_modules__)\n\n      /******/\n\n\n      __webpack_require__.m = modules;\n      /******/\n      // expose the module cache\n\n      /******/\n\n      __webpack_require__.c = installedModules;\n      /******/\n      // __webpack_public_path__\n\n      /******/\n\n      __webpack_require__.p = \"\";\n      /******/\n      // Load entry module and return exports\n\n      /******/\n\n      return __webpack_require__(0);\n      /******/\n    }(\n    /************************************************************************/\n\n    /******/\n    [\n    /* 0 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      'use strict';\n\n      var _extends = Object.assign || function (target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i];\n\n          for (var key in source) {\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n              target[key] = source[key];\n            }\n          }\n        }\n\n        return target;\n      };\n\n      function _objectWithoutProperties(obj, keys) {\n        var target = {};\n\n        for (var i in obj) {\n          if (keys.indexOf(i) >= 0) continue;\n          if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n          target[i] = obj[i];\n        }\n\n        return target;\n      }\n\n      var React = __webpack_require__(1); // eslint-disable-line no-unused-vars\n\n\n      var CreateReactClass = __webpack_require__(2);\n\n      var NumeralFormatter = __webpack_require__(9);\n\n      var DateFormatter = __webpack_require__(10);\n\n      var TimeFormatter = __webpack_require__(11);\n\n      var PhoneFormatter = __webpack_require__(12);\n\n      var CreditCardDetector = __webpack_require__(13);\n\n      var Util = __webpack_require__(14);\n\n      var DefaultProperties = __webpack_require__(15);\n\n      var cleaveReactClass = CreateReactClass({\n        componentDidMount: function componentDidMount() {\n          this.init();\n        },\n        componentDidUpdate: function componentDidUpdate(prevProps) {\n          var owner = this,\n              phoneRegionCode = (owner.props.options || {}).phoneRegionCode,\n              newValue = owner.props.value,\n              pps = owner.properties;\n          owner.updateRegisteredEvents(owner.props);\n\n          if (prevProps.value !== newValue && newValue !== undefined && newValue !== null) {\n            newValue = newValue.toString();\n\n            if (newValue !== owner.properties.result) {\n              owner.properties.initValue = newValue;\n              owner.onInput(newValue, true);\n            }\n          } // update phone region code\n\n\n          var prevPhoneRegionCode = (prevProps.options || {}).phoneRegionCode;\n\n          if (prevPhoneRegionCode !== phoneRegionCode && phoneRegionCode && phoneRegionCode !== owner.properties.phoneRegionCode) {\n            owner.properties.phoneRegionCode = phoneRegionCode;\n            owner.initPhoneFormatter();\n            owner.onInput(owner.properties.result);\n          }\n\n          Util.setSelection(owner.element, owner.state.cursorPosition, pps.document);\n        },\n        updateRegisteredEvents: function updateRegisteredEvents(props) {\n          var owner = this,\n              _owner$registeredEven = owner.registeredEvents,\n              onKeyDown = _owner$registeredEven.onKeyDown,\n              onChange = _owner$registeredEven.onChange,\n              onFocus = _owner$registeredEven.onFocus,\n              onBlur = _owner$registeredEven.onBlur,\n              onInit = _owner$registeredEven.onInit;\n          if (props.onInit && props.onInit !== onInit) owner.registeredEvents.onInit = props.onInit;\n          if (props.onChange && props.onChange !== onChange) owner.registeredEvents.onChange = props.onChange;\n          if (props.onFocus && props.onFocus !== onFocus) owner.registeredEvents.onFocus = props.onFocus;\n          if (props.onBlur && props.onBlur !== onBlur) owner.registeredEvents.onBlur = props.onBlur;\n          if (props.onKeyDown && props.onKeyDown !== onKeyDown) owner.registeredEvents.onKeyDown = props.onKeyDown;\n        },\n        getInitialState: function getInitialState() {\n          var owner = this,\n              _owner$props = owner.props,\n              value = _owner$props.value,\n              options = _owner$props.options,\n              onKeyDown = _owner$props.onKeyDown,\n              onChange = _owner$props.onChange,\n              onFocus = _owner$props.onFocus,\n              onBlur = _owner$props.onBlur,\n              onInit = _owner$props.onInit;\n          owner.registeredEvents = {\n            onInit: onInit || Util.noop,\n            onChange: onChange || Util.noop,\n            onFocus: onFocus || Util.noop,\n            onBlur: onBlur || Util.noop,\n            onKeyDown: onKeyDown || Util.noop\n          };\n\n          if (!options) {\n            options = {};\n          }\n\n          options.initValue = value;\n          owner.properties = DefaultProperties.assign({}, options);\n          return {\n            value: owner.properties.result,\n            cursorPosition: 0\n          };\n        },\n        init: function init() {\n          var owner = this,\n              pps = owner.properties; // so no need for this lib at all\n\n          if (!pps.numeral && !pps.phone && !pps.creditCard && !pps.time && !pps.date && pps.blocksLength === 0 && !pps.prefix) {\n            owner.onInput(pps.initValue);\n            owner.registeredEvents.onInit(owner);\n            return;\n          }\n\n          pps.maxLength = Util.getMaxLength(pps.blocks);\n          owner.isAndroid = Util.isAndroid();\n          owner.initPhoneFormatter();\n          owner.initDateFormatter();\n          owner.initTimeFormatter();\n          owner.initNumeralFormatter(); // avoid touch input field if value is null\n          // otherwise Firefox will add red box-shadow for <input required />\n\n          if (pps.initValue || pps.prefix && !pps.noImmediatePrefix) {\n            owner.onInput(pps.initValue);\n          }\n\n          owner.registeredEvents.onInit(owner);\n        },\n        initNumeralFormatter: function initNumeralFormatter() {\n          var owner = this,\n              pps = owner.properties;\n\n          if (!pps.numeral) {\n            return;\n          }\n\n          pps.numeralFormatter = new NumeralFormatter(pps.numeralDecimalMark, pps.numeralIntegerScale, pps.numeralDecimalScale, pps.numeralThousandsGroupStyle, pps.numeralPositiveOnly, pps.stripLeadingZeroes, pps.prefix, pps.signBeforePrefix, pps.tailPrefix, pps.delimiter);\n        },\n        initTimeFormatter: function initTimeFormatter() {\n          var owner = this,\n              pps = owner.properties;\n\n          if (!pps.time) {\n            return;\n          }\n\n          pps.timeFormatter = new TimeFormatter(pps.timePattern, pps.timeFormat);\n          pps.blocks = pps.timeFormatter.getBlocks();\n          pps.blocksLength = pps.blocks.length;\n          pps.maxLength = Util.getMaxLength(pps.blocks);\n        },\n        initDateFormatter: function initDateFormatter() {\n          var owner = this,\n              pps = owner.properties;\n\n          if (!pps.date) {\n            return;\n          }\n\n          pps.dateFormatter = new DateFormatter(pps.datePattern, pps.dateMin, pps.dateMax);\n          pps.blocks = pps.dateFormatter.getBlocks();\n          pps.blocksLength = pps.blocks.length;\n          pps.maxLength = Util.getMaxLength(pps.blocks);\n        },\n        initPhoneFormatter: function initPhoneFormatter() {\n          var owner = this,\n              pps = owner.properties;\n\n          if (!pps.phone) {\n            return;\n          } // Cleave.AsYouTypeFormatter should be provided by\n          // external google closure lib\n\n\n          try {\n            pps.phoneFormatter = new PhoneFormatter(new pps.root.Cleave.AsYouTypeFormatter(pps.phoneRegionCode), pps.delimiter);\n          } catch (ex) {\n            throw new Error('Please include phone-type-formatter.{country}.js lib');\n          }\n        },\n        setRawValue: function setRawValue(value) {\n          var owner = this,\n              pps = owner.properties;\n          value = value !== undefined && value !== null ? value.toString() : '';\n\n          if (pps.numeral) {\n            value = value.replace('.', pps.numeralDecimalMark);\n          }\n\n          pps.postDelimiterBackspace = false;\n          owner.onChange({\n            target: {\n              value: value\n            },\n            // Methods to better resemble a SyntheticEvent\n            stopPropagation: Util.noop,\n            preventDefault: Util.noop,\n            persist: Util.noop\n          });\n        },\n        getRawValue: function getRawValue() {\n          var owner = this,\n              pps = owner.properties,\n              rawValue = pps.result;\n\n          if (pps.rawValueTrimPrefix) {\n            rawValue = Util.getPrefixStrippedValue(rawValue, pps.prefix, pps.prefixLength, pps.result, pps.delimiter, pps.delimiters, pps.noImmediatePrefix, pps.tailPrefix, pps.signBeforePrefix);\n          }\n\n          if (pps.numeral) {\n            rawValue = pps.numeralFormatter ? pps.numeralFormatter.getRawValue(rawValue) : '';\n          } else {\n            rawValue = Util.stripDelimiters(rawValue, pps.delimiter, pps.delimiters);\n          }\n\n          return rawValue;\n        },\n        getISOFormatDate: function getISOFormatDate() {\n          var owner = this,\n              pps = owner.properties;\n          return pps.date ? pps.dateFormatter.getISOFormatDate() : '';\n        },\n        getISOFormatTime: function getISOFormatTime() {\n          var owner = this,\n              pps = owner.properties;\n          return pps.time ? pps.timeFormatter.getISOFormatTime() : '';\n        },\n        onInit: function onInit(owner) {\n          return owner;\n        },\n        onKeyDown: function onKeyDown(event) {\n          var owner = this,\n              pps = owner.properties,\n              charCode = event.which || event.keyCode;\n          owner.lastInputValue = pps.result;\n          owner.isBackward = charCode === 8;\n          owner.registeredEvents.onKeyDown(event);\n        },\n        onFocus: function onFocus(event) {\n          var owner = this,\n              pps = owner.properties;\n\n          if (pps.prefix && pps.noImmediatePrefix && !event.target.value) {\n            owner.onInput(pps.prefix);\n          }\n\n          event.target.rawValue = owner.getRawValue();\n          event.target.value = pps.result;\n          owner.registeredEvents.onFocus(event);\n          Util.fixPrefixCursor(owner.element, pps.prefix, pps.delimiter, pps.delimiters);\n        },\n        onBlur: function onBlur(event) {\n          var owner = this,\n              pps = owner.properties;\n          event.target.rawValue = owner.getRawValue();\n          event.target.value = pps.result;\n          owner.registeredEvents.onBlur(event);\n        },\n        onChange: function onChange(event) {\n          var owner = this,\n              pps = owner.properties;\n          owner.isBackward = owner.isBackward || event.inputType === 'deleteContentBackward'; // hit backspace when last character is delimiter\n\n          var postDelimiter = Util.getPostDelimiter(owner.lastInputValue, pps.delimiter, pps.delimiters);\n\n          if (owner.isBackward && postDelimiter) {\n            pps.postDelimiterBackspace = postDelimiter;\n          } else {\n            pps.postDelimiterBackspace = false;\n          }\n\n          owner.onInput(event.target.value);\n          event.target.rawValue = owner.getRawValue();\n          event.target.value = pps.result;\n          owner.registeredEvents.onChange(event);\n        },\n        onInput: function onInput(value, fromProps) {\n          var owner = this,\n              pps = owner.properties; // case 1: delete one more character \"4\"\n          // 1234*| -> hit backspace -> 123|\n          // case 2: last character is not delimiter which is:\n          // 12|34* -> hit backspace -> 1|34*\n\n          var postDelimiterAfter = Util.getPostDelimiter(value, pps.delimiter, pps.delimiters);\n\n          if (!fromProps && !pps.numeral && pps.postDelimiterBackspace && !postDelimiterAfter) {\n            value = Util.headStr(value, value.length - pps.postDelimiterBackspace.length);\n          } // phone formatter\n\n\n          if (pps.phone) {\n            if (pps.prefix && (!pps.noImmediatePrefix || value.length)) {\n              pps.result = pps.prefix + pps.phoneFormatter.format(value).slice(pps.prefix.length);\n            } else {\n              pps.result = pps.phoneFormatter.format(value);\n            }\n\n            owner.updateValueState();\n            return;\n          } // numeral formatter\n\n\n          if (pps.numeral) {\n            // Do not show prefix when noImmediatePrefix is specified\n            // This mostly because we need to show user the native input placeholder\n            if (pps.prefix && pps.noImmediatePrefix && value.length === 0) {\n              pps.result = '';\n            } else {\n              pps.result = pps.numeralFormatter.format(value);\n            }\n\n            owner.updateValueState();\n            return;\n          } // date\n\n\n          if (pps.date) {\n            value = pps.dateFormatter.getValidatedDate(value);\n          } // time\n\n\n          if (pps.time) {\n            value = pps.timeFormatter.getValidatedTime(value);\n          } // strip delimiters\n\n\n          value = Util.stripDelimiters(value, pps.delimiter, pps.delimiters); // strip prefix\n\n          value = Util.getPrefixStrippedValue(value, pps.prefix, pps.prefixLength, pps.result, pps.delimiter, pps.delimiters, pps.noImmediatePrefix, pps.tailPrefix, pps.signBeforePrefix); // strip non-numeric characters\n\n          value = pps.numericOnly ? Util.strip(value, /[^\\d]/g) : value; // convert case\n\n          value = pps.uppercase ? value.toUpperCase() : value;\n          value = pps.lowercase ? value.toLowerCase() : value; // prevent from showing prefix when no immediate option enabled with empty input value\n\n          if (pps.prefix) {\n            if (pps.tailPrefix) {\n              value = value + pps.prefix;\n            } else {\n              value = pps.prefix + value;\n            } // no blocks specified, no need to do formatting\n\n\n            if (pps.blocksLength === 0) {\n              pps.result = value;\n              owner.updateValueState();\n              return;\n            }\n          } // update credit card props\n\n\n          if (pps.creditCard) {\n            owner.updateCreditCardPropsByValue(value);\n          } // strip over length characters\n\n\n          value = pps.maxLength > 0 ? Util.headStr(value, pps.maxLength) : value; // apply blocks\n\n          pps.result = Util.getFormattedValue(value, pps.blocks, pps.blocksLength, pps.delimiter, pps.delimiters, pps.delimiterLazyShow);\n          owner.updateValueState();\n        },\n        updateCreditCardPropsByValue: function updateCreditCardPropsByValue(value) {\n          var owner = this,\n              pps = owner.properties,\n              creditCardInfo; // At least one of the first 4 characters has changed\n\n          if (Util.headStr(pps.result, 4) === Util.headStr(value, 4)) {\n            return;\n          }\n\n          creditCardInfo = CreditCardDetector.getInfo(value, pps.creditCardStrictMode);\n          pps.blocks = creditCardInfo.blocks;\n          pps.blocksLength = pps.blocks.length;\n          pps.maxLength = Util.getMaxLength(pps.blocks); // credit card type changed\n\n          if (pps.creditCardType !== creditCardInfo.type) {\n            pps.creditCardType = creditCardInfo.type;\n            pps.onCreditCardTypeChanged.call(owner, pps.creditCardType);\n          }\n        },\n        updateValueState: function updateValueState() {\n          var owner = this,\n              pps = owner.properties;\n\n          if (!owner.element) {\n            owner.setState({\n              value: pps.result\n            });\n            return;\n          }\n\n          var endPos = owner.element.selectionEnd;\n          var oldValue = owner.element.value;\n          var newValue = pps.result;\n          owner.lastInputValue = newValue;\n          endPos = Util.getNextCursorPosition(endPos, oldValue, newValue, pps.delimiter, pps.delimiters);\n\n          if (owner.isAndroid) {\n            window.setTimeout(function () {\n              owner.setState({\n                value: newValue,\n                cursorPosition: endPos\n              });\n            }, 1);\n            return;\n          }\n\n          owner.setState({\n            value: newValue,\n            cursorPosition: endPos\n          });\n        },\n        render: function render() {\n          var owner = this; // eslint-disable-next-line\n\n          var _owner$props2 = owner.props,\n              value = _owner$props2.value,\n              options = _owner$props2.options,\n              onKeyDown = _owner$props2.onKeyDown,\n              onFocus = _owner$props2.onFocus,\n              onBlur = _owner$props2.onBlur,\n              onChange = _owner$props2.onChange,\n              onInit = _owner$props2.onInit,\n              htmlRef = _owner$props2.htmlRef,\n              propsToTransfer = _objectWithoutProperties(_owner$props2, ['value', 'options', 'onKeyDown', 'onFocus', 'onBlur', 'onChange', 'onInit', 'htmlRef']);\n\n          return React.createElement('input', _extends({\n            type: 'text',\n            ref: function ref(_ref) {\n              owner.element = _ref;\n\n              if (!htmlRef) {\n                return;\n              }\n\n              htmlRef.apply(this, arguments);\n            },\n            value: owner.state.value,\n            onKeyDown: owner.onKeyDown,\n            onChange: owner.onChange,\n            onFocus: owner.onFocus,\n            onBlur: owner.onBlur\n          }, propsToTransfer));\n        }\n      });\n      module.exports = cleaveReactClass;\n      /***/\n    },\n    /* 1 */\n\n    /***/\n    function (module, exports) {\n      module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n      /***/\n    },\n    /* 2 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * Copyright (c) 2013-present, Facebook, Inc.\n       *\n       * This source code is licensed under the MIT license found in the\n       * LICENSE file in the root directory of this source tree.\n       *\n       */\n      'use strict';\n\n      var React = __webpack_require__(1);\n\n      var factory = __webpack_require__(3);\n\n      if (typeof React === 'undefined') {\n        throw Error('create-react-class could not find the React object. If you are using script tags, ' + 'make sure that React is being loaded before create-react-class.');\n      } // Hack to grab NoopUpdateQueue from isomorphic React\n\n\n      var ReactNoopUpdateQueue = new React.Component().updater;\n      module.exports = factory(React.Component, React.isValidElement, ReactNoopUpdateQueue);\n      /***/\n    },\n    /* 3 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * Copyright (c) 2013-present, Facebook, Inc.\n       *\n       * This source code is licensed under the MIT license found in the\n       * LICENSE file in the root directory of this source tree.\n       *\n       */\n      'use strict';\n\n      var _assign = __webpack_require__(4);\n\n      var emptyObject = __webpack_require__(5);\n\n      var _invariant = __webpack_require__(6);\n\n      if (false) { var warning; }\n\n      var MIXINS_KEY = 'mixins'; // Helper function to allow the creation of anonymous functions which do not\n      // have .name set to the name of the variable being assigned to.\n\n      function identity(fn) {\n        return fn;\n      }\n\n      var ReactPropTypeLocationNames;\n\n      if (false) {} else {\n        ReactPropTypeLocationNames = {};\n      }\n\n      function factory(ReactComponent, isValidElement, ReactNoopUpdateQueue) {\n        /**\n         * Policies that describe methods in `ReactClassInterface`.\n         */\n        var injectedMixins = [];\n        /**\n         * Composite components are higher-level components that compose other composite\n         * or host components.\n         *\n         * To create a new type of `ReactClass`, pass a specification of\n         * your new class to `React.createClass`. The only requirement of your class\n         * specification is that you implement a `render` method.\n         *\n         *   var MyComponent = React.createClass({\n         *     render: function() {\n         *       return <div>Hello World</div>;\n         *     }\n         *   });\n         *\n         * The class specification supports a specific protocol of methods that have\n         * special meaning (e.g. `render`). See `ReactClassInterface` for\n         * more the comprehensive protocol. Any other properties and methods in the\n         * class specification will be available on the prototype.\n         *\n         * @interface ReactClassInterface\n         * @internal\n         */\n\n        var ReactClassInterface = {\n          /**\n           * An array of Mixin objects to include when defining your component.\n           *\n           * @type {array}\n           * @optional\n           */\n          mixins: 'DEFINE_MANY',\n\n          /**\n           * An object containing properties and methods that should be defined on\n           * the component's constructor instead of its prototype (static methods).\n           *\n           * @type {object}\n           * @optional\n           */\n          statics: 'DEFINE_MANY',\n\n          /**\n           * Definition of prop types for this component.\n           *\n           * @type {object}\n           * @optional\n           */\n          propTypes: 'DEFINE_MANY',\n\n          /**\n           * Definition of context types for this component.\n           *\n           * @type {object}\n           * @optional\n           */\n          contextTypes: 'DEFINE_MANY',\n\n          /**\n           * Definition of context types this component sets for its children.\n           *\n           * @type {object}\n           * @optional\n           */\n          childContextTypes: 'DEFINE_MANY',\n          // ==== Definition methods ====\n\n          /**\n           * Invoked when the component is mounted. Values in the mapping will be set on\n           * `this.props` if that prop is not specified (i.e. using an `in` check).\n           *\n           * This method is invoked before `getInitialState` and therefore cannot rely\n           * on `this.state` or use `this.setState`.\n           *\n           * @return {object}\n           * @optional\n           */\n          getDefaultProps: 'DEFINE_MANY_MERGED',\n\n          /**\n           * Invoked once before the component is mounted. The return value will be used\n           * as the initial value of `this.state`.\n           *\n           *   getInitialState: function() {\n           *     return {\n           *       isOn: false,\n           *       fooBaz: new BazFoo()\n           *     }\n           *   }\n           *\n           * @return {object}\n           * @optional\n           */\n          getInitialState: 'DEFINE_MANY_MERGED',\n\n          /**\n           * @return {object}\n           * @optional\n           */\n          getChildContext: 'DEFINE_MANY_MERGED',\n\n          /**\n           * Uses props from `this.props` and state from `this.state` to render the\n           * structure of the component.\n           *\n           * No guarantees are made about when or how often this method is invoked, so\n           * it must not have side effects.\n           *\n           *   render: function() {\n           *     var name = this.props.name;\n           *     return <div>Hello, {name}!</div>;\n           *   }\n           *\n           * @return {ReactComponent}\n           * @required\n           */\n          render: 'DEFINE_ONCE',\n          // ==== Delegate methods ====\n\n          /**\n           * Invoked when the component is initially created and about to be mounted.\n           * This may have side effects, but any external subscriptions or data created\n           * by this method must be cleaned up in `componentWillUnmount`.\n           *\n           * @optional\n           */\n          componentWillMount: 'DEFINE_MANY',\n\n          /**\n           * Invoked when the component has been mounted and has a DOM representation.\n           * However, there is no guarantee that the DOM node is in the document.\n           *\n           * Use this as an opportunity to operate on the DOM when the component has\n           * been mounted (initialized and rendered) for the first time.\n           *\n           * @param {DOMElement} rootNode DOM element representing the component.\n           * @optional\n           */\n          componentDidMount: 'DEFINE_MANY',\n\n          /**\n           * Invoked before the component receives new props.\n           *\n           * Use this as an opportunity to react to a prop transition by updating the\n           * state using `this.setState`. Current props are accessed via `this.props`.\n           *\n           *   componentWillReceiveProps: function(nextProps, nextContext) {\n           *     this.setState({\n           *       likesIncreasing: nextProps.likeCount > this.props.likeCount\n           *     });\n           *   }\n           *\n           * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop\n           * transition may cause a state change, but the opposite is not true. If you\n           * need it, you are probably looking for `componentWillUpdate`.\n           *\n           * @param {object} nextProps\n           * @optional\n           */\n          componentWillReceiveProps: 'DEFINE_MANY',\n\n          /**\n           * Invoked while deciding if the component should be updated as a result of\n           * receiving new props, state and/or context.\n           *\n           * Use this as an opportunity to `return false` when you're certain that the\n           * transition to the new props/state/context will not require a component\n           * update.\n           *\n           *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {\n           *     return !equal(nextProps, this.props) ||\n           *       !equal(nextState, this.state) ||\n           *       !equal(nextContext, this.context);\n           *   }\n           *\n           * @param {object} nextProps\n           * @param {?object} nextState\n           * @param {?object} nextContext\n           * @return {boolean} True if the component should update.\n           * @optional\n           */\n          shouldComponentUpdate: 'DEFINE_ONCE',\n\n          /**\n           * Invoked when the component is about to update due to a transition from\n           * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`\n           * and `nextContext`.\n           *\n           * Use this as an opportunity to perform preparation before an update occurs.\n           *\n           * NOTE: You **cannot** use `this.setState()` in this method.\n           *\n           * @param {object} nextProps\n           * @param {?object} nextState\n           * @param {?object} nextContext\n           * @param {ReactReconcileTransaction} transaction\n           * @optional\n           */\n          componentWillUpdate: 'DEFINE_MANY',\n\n          /**\n           * Invoked when the component's DOM representation has been updated.\n           *\n           * Use this as an opportunity to operate on the DOM when the component has\n           * been updated.\n           *\n           * @param {object} prevProps\n           * @param {?object} prevState\n           * @param {?object} prevContext\n           * @param {DOMElement} rootNode DOM element representing the component.\n           * @optional\n           */\n          componentDidUpdate: 'DEFINE_MANY',\n\n          /**\n           * Invoked when the component is about to be removed from its parent and have\n           * its DOM representation destroyed.\n           *\n           * Use this as an opportunity to deallocate any external resources.\n           *\n           * NOTE: There is no `componentDidUnmount` since your component will have been\n           * destroyed by that point.\n           *\n           * @optional\n           */\n          componentWillUnmount: 'DEFINE_MANY',\n\n          /**\n           * Replacement for (deprecated) `componentWillMount`.\n           *\n           * @optional\n           */\n          UNSAFE_componentWillMount: 'DEFINE_MANY',\n\n          /**\n           * Replacement for (deprecated) `componentWillReceiveProps`.\n           *\n           * @optional\n           */\n          UNSAFE_componentWillReceiveProps: 'DEFINE_MANY',\n\n          /**\n           * Replacement for (deprecated) `componentWillUpdate`.\n           *\n           * @optional\n           */\n          UNSAFE_componentWillUpdate: 'DEFINE_MANY',\n          // ==== Advanced methods ====\n\n          /**\n           * Updates the component's currently mounted DOM representation.\n           *\n           * By default, this implements React's rendering and reconciliation algorithm.\n           * Sophisticated clients may wish to override this.\n           *\n           * @param {ReactReconcileTransaction} transaction\n           * @internal\n           * @overridable\n           */\n          updateComponent: 'OVERRIDE_BASE'\n        };\n        /**\n         * Similar to ReactClassInterface but for static methods.\n         */\n\n        var ReactClassStaticInterface = {\n          /**\n           * This method is invoked after a component is instantiated and when it\n           * receives new props. Return an object to update state in response to\n           * prop changes. Return null to indicate no change to state.\n           *\n           * If an object is returned, its keys will be merged into the existing state.\n           *\n           * @return {object || null}\n           * @optional\n           */\n          getDerivedStateFromProps: 'DEFINE_MANY_MERGED'\n        };\n        /**\n         * Mapping from class specification keys to special processing functions.\n         *\n         * Although these are declared like instance properties in the specification\n         * when defining classes using `React.createClass`, they are actually static\n         * and are accessible on the constructor instead of the prototype. Despite\n         * being static, they must be defined outside of the \"statics\" key under\n         * which all other static methods are defined.\n         */\n\n        var RESERVED_SPEC_KEYS = {\n          displayName: function displayName(Constructor, _displayName) {\n            Constructor.displayName = _displayName;\n          },\n          mixins: function mixins(Constructor, _mixins) {\n            if (_mixins) {\n              for (var i = 0; i < _mixins.length; i++) {\n                mixSpecIntoComponent(Constructor, _mixins[i]);\n              }\n            }\n          },\n          childContextTypes: function childContextTypes(Constructor, _childContextTypes) {\n            if (false) {}\n\n            Constructor.childContextTypes = _assign({}, Constructor.childContextTypes, _childContextTypes);\n          },\n          contextTypes: function contextTypes(Constructor, _contextTypes) {\n            if (false) {}\n\n            Constructor.contextTypes = _assign({}, Constructor.contextTypes, _contextTypes);\n          },\n\n          /**\n           * Special case getDefaultProps which should move into statics but requires\n           * automatic merging.\n           */\n          getDefaultProps: function getDefaultProps(Constructor, _getDefaultProps) {\n            if (Constructor.getDefaultProps) {\n              Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, _getDefaultProps);\n            } else {\n              Constructor.getDefaultProps = _getDefaultProps;\n            }\n          },\n          propTypes: function propTypes(Constructor, _propTypes) {\n            if (false) {}\n\n            Constructor.propTypes = _assign({}, Constructor.propTypes, _propTypes);\n          },\n          statics: function statics(Constructor, _statics) {\n            mixStaticSpecIntoComponent(Constructor, _statics);\n          },\n          autobind: function autobind() {}\n        };\n\n        function validateTypeDef(Constructor, typeDef, location) {\n          for (var propName in typeDef) {\n            if (typeDef.hasOwnProperty(propName)) {\n              // use a warning instead of an _invariant so components\n              // don't show up in prod but only in __DEV__\n              if (false) {}\n            }\n          }\n        }\n\n        function validateMethodOverride(isAlreadyDefined, name) {\n          var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null; // Disallow overriding of base class methods unless explicitly allowed.\n\n          if (ReactClassMixin.hasOwnProperty(name)) {\n            _invariant(specPolicy === 'OVERRIDE_BASE', 'ReactClassInterface: You are attempting to override ' + '`%s` from your class specification. Ensure that your method names ' + 'do not overlap with React methods.', name);\n          } // Disallow defining methods more than once unless explicitly allowed.\n\n\n          if (isAlreadyDefined) {\n            _invariant(specPolicy === 'DEFINE_MANY' || specPolicy === 'DEFINE_MANY_MERGED', 'ReactClassInterface: You are attempting to define ' + '`%s` on your component more than once. This conflict may be due ' + 'to a mixin.', name);\n          }\n        }\n        /**\n         * Mixin helper which handles policy validation and reserved\n         * specification keys when building React classes.\n         */\n\n\n        function mixSpecIntoComponent(Constructor, spec) {\n          if (!spec) {\n            if (false) { var isMixinValid, typeofSpec; }\n\n            return;\n          }\n\n          _invariant(typeof spec !== 'function', \"ReactClass: You're attempting to \" + 'use a component class or function as a mixin. Instead, just use a ' + 'regular object.');\n\n          _invariant(!isValidElement(spec), \"ReactClass: You're attempting to \" + 'use a component as a mixin. Instead, just use a regular object.');\n\n          var proto = Constructor.prototype;\n          var autoBindPairs = proto.__reactAutoBindPairs; // By handling mixins before any other properties, we ensure the same\n          // chaining order is applied to methods with DEFINE_MANY policy, whether\n          // mixins are listed before or after these methods in the spec.\n\n          if (spec.hasOwnProperty(MIXINS_KEY)) {\n            RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);\n          }\n\n          for (var name in spec) {\n            if (!spec.hasOwnProperty(name)) {\n              continue;\n            }\n\n            if (name === MIXINS_KEY) {\n              // We have already handled mixins in a special case above.\n              continue;\n            }\n\n            var property = spec[name];\n            var isAlreadyDefined = proto.hasOwnProperty(name);\n            validateMethodOverride(isAlreadyDefined, name);\n\n            if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {\n              RESERVED_SPEC_KEYS[name](Constructor, property);\n            } else {\n              // Setup methods on prototype:\n              // The following member methods should not be automatically bound:\n              // 1. Expected ReactClass methods (in the \"interface\").\n              // 2. Overridden methods (that were mixed in).\n              var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);\n              var isFunction = typeof property === 'function';\n              var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;\n\n              if (shouldAutoBind) {\n                autoBindPairs.push(name, property);\n                proto[name] = property;\n              } else {\n                if (isAlreadyDefined) {\n                  var specPolicy = ReactClassInterface[name]; // These cases should already be caught by validateMethodOverride.\n\n                  _invariant(isReactClassMethod && (specPolicy === 'DEFINE_MANY_MERGED' || specPolicy === 'DEFINE_MANY'), 'ReactClass: Unexpected spec policy %s for key %s ' + 'when mixing in component specs.', specPolicy, name); // For methods which are defined more than once, call the existing\n                  // methods before calling the new property, merging if appropriate.\n\n\n                  if (specPolicy === 'DEFINE_MANY_MERGED') {\n                    proto[name] = createMergedResultFunction(proto[name], property);\n                  } else if (specPolicy === 'DEFINE_MANY') {\n                    proto[name] = createChainedFunction(proto[name], property);\n                  }\n                } else {\n                  proto[name] = property;\n\n                  if (false) {}\n                }\n              }\n            }\n          }\n        }\n\n        function mixStaticSpecIntoComponent(Constructor, statics) {\n          if (!statics) {\n            return;\n          }\n\n          for (var name in statics) {\n            var property = statics[name];\n\n            if (!statics.hasOwnProperty(name)) {\n              continue;\n            }\n\n            var isReserved = (name in RESERVED_SPEC_KEYS);\n\n            _invariant(!isReserved, 'ReactClass: You are attempting to define a reserved ' + 'property, `%s`, that shouldn\\'t be on the \"statics\" key. Define it ' + 'as an instance property instead; it will still be accessible on the ' + 'constructor.', name);\n\n            var isAlreadyDefined = (name in Constructor);\n\n            if (isAlreadyDefined) {\n              var specPolicy = ReactClassStaticInterface.hasOwnProperty(name) ? ReactClassStaticInterface[name] : null;\n\n              _invariant(specPolicy === 'DEFINE_MANY_MERGED', 'ReactClass: You are attempting to define ' + '`%s` on your component more than once. This conflict may be ' + 'due to a mixin.', name);\n\n              Constructor[name] = createMergedResultFunction(Constructor[name], property);\n              return;\n            }\n\n            Constructor[name] = property;\n          }\n        }\n        /**\n         * Merge two objects, but throw if both contain the same key.\n         *\n         * @param {object} one The first object, which is mutated.\n         * @param {object} two The second object\n         * @return {object} one after it has been mutated to contain everything in two.\n         */\n\n\n        function mergeIntoWithNoDuplicateKeys(one, two) {\n          _invariant(one && two && typeof one === 'object' && typeof two === 'object', 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.');\n\n          for (var key in two) {\n            if (two.hasOwnProperty(key)) {\n              _invariant(one[key] === undefined, 'mergeIntoWithNoDuplicateKeys(): ' + 'Tried to merge two objects with the same key: `%s`. This conflict ' + 'may be due to a mixin; in particular, this may be caused by two ' + 'getInitialState() or getDefaultProps() methods returning objects ' + 'with clashing keys.', key);\n\n              one[key] = two[key];\n            }\n          }\n\n          return one;\n        }\n        /**\n         * Creates a function that invokes two functions and merges their return values.\n         *\n         * @param {function} one Function to invoke first.\n         * @param {function} two Function to invoke second.\n         * @return {function} Function that invokes the two argument functions.\n         * @private\n         */\n\n\n        function createMergedResultFunction(one, two) {\n          return function mergedResult() {\n            var a = one.apply(this, arguments);\n            var b = two.apply(this, arguments);\n\n            if (a == null) {\n              return b;\n            } else if (b == null) {\n              return a;\n            }\n\n            var c = {};\n            mergeIntoWithNoDuplicateKeys(c, a);\n            mergeIntoWithNoDuplicateKeys(c, b);\n            return c;\n          };\n        }\n        /**\n         * Creates a function that invokes two functions and ignores their return vales.\n         *\n         * @param {function} one Function to invoke first.\n         * @param {function} two Function to invoke second.\n         * @return {function} Function that invokes the two argument functions.\n         * @private\n         */\n\n\n        function createChainedFunction(one, two) {\n          return function chainedFunction() {\n            one.apply(this, arguments);\n            two.apply(this, arguments);\n          };\n        }\n        /**\n         * Binds a method to the component.\n         *\n         * @param {object} component Component whose method is going to be bound.\n         * @param {function} method Method to be bound.\n         * @return {function} The bound method.\n         */\n\n\n        function bindAutoBindMethod(component, method) {\n          var boundMethod = method.bind(component);\n\n          if (false) { var _bind, componentName; }\n\n          return boundMethod;\n        }\n        /**\n         * Binds all auto-bound methods in a component.\n         *\n         * @param {object} component Component whose method is going to be bound.\n         */\n\n\n        function bindAutoBindMethods(component) {\n          var pairs = component.__reactAutoBindPairs;\n\n          for (var i = 0; i < pairs.length; i += 2) {\n            var autoBindKey = pairs[i];\n            var method = pairs[i + 1];\n            component[autoBindKey] = bindAutoBindMethod(component, method);\n          }\n        }\n\n        var IsMountedPreMixin = {\n          componentDidMount: function componentDidMount() {\n            this.__isMounted = true;\n          }\n        };\n        var IsMountedPostMixin = {\n          componentWillUnmount: function componentWillUnmount() {\n            this.__isMounted = false;\n          }\n        };\n        /**\n         * Add more to the ReactClass base class. These are all legacy features and\n         * therefore not already part of the modern ReactComponent.\n         */\n\n        var ReactClassMixin = {\n          /**\n           * TODO: This will be deprecated because state should always keep a consistent\n           * type signature and the only use case for this, is to avoid that.\n           */\n          replaceState: function replaceState(newState, callback) {\n            this.updater.enqueueReplaceState(this, newState, callback);\n          },\n\n          /**\n           * Checks whether or not this composite component is mounted.\n           * @return {boolean} True if mounted, false otherwise.\n           * @protected\n           * @final\n           */\n          isMounted: function isMounted() {\n            if (false) {}\n\n            return !!this.__isMounted;\n          }\n        };\n\n        var ReactClassComponent = function ReactClassComponent() {};\n\n        _assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);\n        /**\n         * Creates a composite component class given a class specification.\n         * See https://facebook.github.io/react/docs/top-level-api.html#react.createclass\n         *\n         * @param {object} spec Class specification (which must define `render`).\n         * @return {function} Component constructor function.\n         * @public\n         */\n\n\n        function createClass(spec) {\n          // To keep our warnings more understandable, we'll use a little hack here to\n          // ensure that Constructor.name !== 'Constructor'. This makes sure we don't\n          // unnecessarily identify a class without displayName as 'Constructor'.\n          var Constructor = identity(function (props, context, updater) {\n            // This constructor gets overridden by mocks. The argument is used\n            // by mocks to assert on what gets mounted.\n            if (false) {} // Wire up auto-binding\n\n\n            if (this.__reactAutoBindPairs.length) {\n              bindAutoBindMethods(this);\n            }\n\n            this.props = props;\n            this.context = context;\n            this.refs = emptyObject;\n            this.updater = updater || ReactNoopUpdateQueue;\n            this.state = null; // ReactClasses doesn't have constructors. Instead, they use the\n            // getInitialState and componentWillMount methods for initialization.\n\n            var initialState = this.getInitialState ? this.getInitialState() : null;\n\n            if (false) {}\n\n            _invariant(typeof initialState === 'object' && !Array.isArray(initialState), '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent');\n\n            this.state = initialState;\n          });\n          Constructor.prototype = new ReactClassComponent();\n          Constructor.prototype.constructor = Constructor;\n          Constructor.prototype.__reactAutoBindPairs = [];\n          injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));\n          mixSpecIntoComponent(Constructor, IsMountedPreMixin);\n          mixSpecIntoComponent(Constructor, spec);\n          mixSpecIntoComponent(Constructor, IsMountedPostMixin); // Initialize the defaultProps property after all mixins have been merged.\n\n          if (Constructor.getDefaultProps) {\n            Constructor.defaultProps = Constructor.getDefaultProps();\n          }\n\n          if (false) {}\n\n          _invariant(Constructor.prototype.render, 'createClass(...): Class specification must implement a `render` method.');\n\n          if (false) {} // Reduce time spent doing lookups by setting these on the prototype.\n\n\n          for (var methodName in ReactClassInterface) {\n            if (!Constructor.prototype[methodName]) {\n              Constructor.prototype[methodName] = null;\n            }\n          }\n\n          return Constructor;\n        }\n\n        return createClass;\n      }\n\n      module.exports = factory;\n      /***/\n    },\n    /* 4 */\n\n    /***/\n    function (module, exports) {\n      /*\n      object-assign\n      (c) Sindre Sorhus\n      @license MIT\n      */\n      'use strict';\n      /* eslint-disable no-unused-vars */\n\n      var getOwnPropertySymbols = Object.getOwnPropertySymbols;\n      var hasOwnProperty = Object.prototype.hasOwnProperty;\n      var propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\n      function toObject(val) {\n        if (val === null || val === undefined) {\n          throw new TypeError('Object.assign cannot be called with null or undefined');\n        }\n\n        return Object(val);\n      }\n\n      function shouldUseNative() {\n        try {\n          if (!Object.assign) {\n            return false;\n          } // Detect buggy property enumeration order in older V8 versions.\n          // https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\n\n          var test1 = new String('abc'); // eslint-disable-line no-new-wrappers\n\n          test1[5] = 'de';\n\n          if (Object.getOwnPropertyNames(test1)[0] === '5') {\n            return false;\n          } // https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\n\n          var test2 = {};\n\n          for (var i = 0; i < 10; i++) {\n            test2['_' + String.fromCharCode(i)] = i;\n          }\n\n          var order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n            return test2[n];\n          });\n\n          if (order2.join('') !== '0123456789') {\n            return false;\n          } // https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\n\n          var test3 = {};\n          'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n            test3[letter] = letter;\n          });\n\n          if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {\n            return false;\n          }\n\n          return true;\n        } catch (err) {\n          // We don't expect any of the above to throw, but better to be safe.\n          return false;\n        }\n      }\n\n      module.exports = shouldUseNative() ? Object.assign : function (target, source) {\n        var from;\n        var to = toObject(target);\n        var symbols;\n\n        for (var s = 1; s < arguments.length; s++) {\n          from = Object(arguments[s]);\n\n          for (var key in from) {\n            if (hasOwnProperty.call(from, key)) {\n              to[key] = from[key];\n            }\n          }\n\n          if (getOwnPropertySymbols) {\n            symbols = getOwnPropertySymbols(from);\n\n            for (var i = 0; i < symbols.length; i++) {\n              if (propIsEnumerable.call(from, symbols[i])) {\n                to[symbols[i]] = from[symbols[i]];\n              }\n            }\n          }\n        }\n\n        return to;\n      };\n      /***/\n    },\n    /* 5 */\n\n    /***/\n    function (module, exports) {\n      /**\n       * Copyright (c) 2013-present, Facebook, Inc.\n       *\n       * This source code is licensed under the MIT license found in the\n       * LICENSE file in the root directory of this source tree.\n       *\n       */\n      'use strict';\n\n      var emptyObject = {};\n\n      if (false) {}\n\n      module.exports = emptyObject;\n      /***/\n    },\n    /* 6 */\n\n    /***/\n    function (module, exports) {\n      /**\n       * Copyright (c) 2013-present, Facebook, Inc.\n       *\n       * This source code is licensed under the MIT license found in the\n       * LICENSE file in the root directory of this source tree.\n       *\n       */\n      'use strict';\n      /**\n       * Use invariant() to assert state which your program assumes to be true.\n       *\n       * Provide sprintf-style format (only %s is supported) and arguments\n       * to provide information about what broke and what you were\n       * expecting.\n       *\n       * The invariant message will be stripped in production, but the invariant\n       * will remain to ensure logic does not differ in production.\n       */\n\n      var validateFormat = function validateFormat(format) {};\n\n      if (false) {}\n\n      function invariant(condition, format, a, b, c, d, e, f) {\n        validateFormat(format);\n\n        if (!condition) {\n          var error;\n\n          if (format === undefined) {\n            error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\n          } else {\n            var args = [a, b, c, d, e, f];\n            var argIndex = 0;\n            error = new Error(format.replace(/%s/g, function () {\n              return args[argIndex++];\n            }));\n            error.name = 'Invariant Violation';\n          }\n\n          error.framesToPop = 1; // we don't care about invariant's own frame\n\n          throw error;\n        }\n      }\n\n      module.exports = invariant;\n      /***/\n    },\n    /* 7 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * Copyright (c) 2014-present, Facebook, Inc.\n       *\n       * This source code is licensed under the MIT license found in the\n       * LICENSE file in the root directory of this source tree.\n       *\n       */\n      'use strict';\n\n      var emptyFunction = __webpack_require__(8);\n      /**\n       * Similar to invariant but only logs a warning if the condition is not met.\n       * This can be used to log issues in development environments in critical\n       * paths. Removing the logging code for production environments will keep the\n       * same logic and follow the same code paths.\n       */\n\n\n      var warning = emptyFunction;\n\n      if (false) { var printWarning; }\n\n      module.exports = warning;\n      /***/\n    },\n    /* 8 */\n\n    /***/\n    function (module, exports) {\n      \"use strict\";\n      /**\n       * Copyright (c) 2013-present, Facebook, Inc.\n       *\n       * This source code is licensed under the MIT license found in the\n       * LICENSE file in the root directory of this source tree.\n       *\n       * \n       */\n\n      function makeEmptyFunction(arg) {\n        return function () {\n          return arg;\n        };\n      }\n      /**\n       * This function accepts and discards inputs; it has no side effects. This is\n       * primarily useful idiomatically for overridable function endpoints which\n       * always need to be callable, since JS lacks a null-call idiom ala Cocoa.\n       */\n\n\n      var emptyFunction = function emptyFunction() {};\n\n      emptyFunction.thatReturns = makeEmptyFunction;\n      emptyFunction.thatReturnsFalse = makeEmptyFunction(false);\n      emptyFunction.thatReturnsTrue = makeEmptyFunction(true);\n      emptyFunction.thatReturnsNull = makeEmptyFunction(null);\n\n      emptyFunction.thatReturnsThis = function () {\n        return this;\n      };\n\n      emptyFunction.thatReturnsArgument = function (arg) {\n        return arg;\n      };\n\n      module.exports = emptyFunction;\n      /***/\n    },\n    /* 9 */\n\n    /***/\n    function (module, exports) {\n      'use strict';\n\n      var NumeralFormatter = function NumeralFormatter(numeralDecimalMark, numeralIntegerScale, numeralDecimalScale, numeralThousandsGroupStyle, numeralPositiveOnly, stripLeadingZeroes, prefix, signBeforePrefix, tailPrefix, delimiter) {\n        var owner = this;\n        owner.numeralDecimalMark = numeralDecimalMark || '.';\n        owner.numeralIntegerScale = numeralIntegerScale > 0 ? numeralIntegerScale : 0;\n        owner.numeralDecimalScale = numeralDecimalScale >= 0 ? numeralDecimalScale : 2;\n        owner.numeralThousandsGroupStyle = numeralThousandsGroupStyle || NumeralFormatter.groupStyle.thousand;\n        owner.numeralPositiveOnly = !!numeralPositiveOnly;\n        owner.stripLeadingZeroes = stripLeadingZeroes !== false;\n        owner.prefix = prefix || prefix === '' ? prefix : '';\n        owner.signBeforePrefix = !!signBeforePrefix;\n        owner.tailPrefix = !!tailPrefix;\n        owner.delimiter = delimiter || delimiter === '' ? delimiter : ',';\n        owner.delimiterRE = delimiter ? new RegExp('\\\\' + delimiter, 'g') : '';\n      };\n\n      NumeralFormatter.groupStyle = {\n        thousand: 'thousand',\n        lakh: 'lakh',\n        wan: 'wan',\n        none: 'none'\n      };\n      NumeralFormatter.prototype = {\n        getRawValue: function getRawValue(value) {\n          return value.replace(this.delimiterRE, '').replace(this.numeralDecimalMark, '.');\n        },\n        format: function format(value) {\n          var owner = this,\n              parts,\n              partSign,\n              partSignAndPrefix,\n              partInteger,\n              partDecimal = ''; // strip alphabet letters\n\n          value = value.replace(/[A-Za-z]/g, '') // replace the first decimal mark with reserved placeholder\n          .replace(owner.numeralDecimalMark, 'M') // strip non numeric letters except minus and \"M\"\n          // this is to ensure prefix has been stripped\n          .replace(/[^\\dM-]/g, '') // replace the leading minus with reserved placeholder\n          .replace(/^\\-/, 'N') // strip the other minus sign (if present)\n          .replace(/\\-/g, '') // replace the minus sign (if present)\n          .replace('N', owner.numeralPositiveOnly ? '' : '-') // replace decimal mark\n          .replace('M', owner.numeralDecimalMark); // strip any leading zeros\n\n          if (owner.stripLeadingZeroes) {\n            value = value.replace(/^(-)?0+(?=\\d)/, '$1');\n          }\n\n          partSign = value.slice(0, 1) === '-' ? '-' : '';\n\n          if (typeof owner.prefix != 'undefined') {\n            if (owner.signBeforePrefix) {\n              partSignAndPrefix = partSign + owner.prefix;\n            } else {\n              partSignAndPrefix = owner.prefix + partSign;\n            }\n          } else {\n            partSignAndPrefix = partSign;\n          }\n\n          partInteger = value;\n\n          if (value.indexOf(owner.numeralDecimalMark) >= 0) {\n            parts = value.split(owner.numeralDecimalMark);\n            partInteger = parts[0];\n            partDecimal = owner.numeralDecimalMark + parts[1].slice(0, owner.numeralDecimalScale);\n          }\n\n          if (partSign === '-') {\n            partInteger = partInteger.slice(1);\n          }\n\n          if (owner.numeralIntegerScale > 0) {\n            partInteger = partInteger.slice(0, owner.numeralIntegerScale);\n          }\n\n          switch (owner.numeralThousandsGroupStyle) {\n            case NumeralFormatter.groupStyle.lakh:\n              partInteger = partInteger.replace(/(\\d)(?=(\\d\\d)+\\d$)/g, '$1' + owner.delimiter);\n              break;\n\n            case NumeralFormatter.groupStyle.wan:\n              partInteger = partInteger.replace(/(\\d)(?=(\\d{4})+$)/g, '$1' + owner.delimiter);\n              break;\n\n            case NumeralFormatter.groupStyle.thousand:\n              partInteger = partInteger.replace(/(\\d)(?=(\\d{3})+$)/g, '$1' + owner.delimiter);\n              break;\n          }\n\n          if (owner.tailPrefix) {\n            return partSign + partInteger.toString() + (owner.numeralDecimalScale > 0 ? partDecimal.toString() : '') + owner.prefix;\n          }\n\n          return partSignAndPrefix + partInteger.toString() + (owner.numeralDecimalScale > 0 ? partDecimal.toString() : '');\n        }\n      };\n      module.exports = NumeralFormatter;\n      /***/\n    },\n    /* 10 */\n\n    /***/\n    function (module, exports) {\n      'use strict';\n\n      var DateFormatter = function DateFormatter(datePattern, dateMin, dateMax) {\n        var owner = this;\n        owner.date = [];\n        owner.blocks = [];\n        owner.datePattern = datePattern;\n        owner.dateMin = dateMin.split('-').reverse().map(function (x) {\n          return parseInt(x, 10);\n        });\n        if (owner.dateMin.length === 2) owner.dateMin.unshift(0);\n        owner.dateMax = dateMax.split('-').reverse().map(function (x) {\n          return parseInt(x, 10);\n        });\n        if (owner.dateMax.length === 2) owner.dateMax.unshift(0);\n        owner.initBlocks();\n      };\n\n      DateFormatter.prototype = {\n        initBlocks: function initBlocks() {\n          var owner = this;\n          owner.datePattern.forEach(function (value) {\n            if (value === 'Y') {\n              owner.blocks.push(4);\n            } else {\n              owner.blocks.push(2);\n            }\n          });\n        },\n        getISOFormatDate: function getISOFormatDate() {\n          var owner = this,\n              date = owner.date;\n          return date[2] ? date[2] + '-' + owner.addLeadingZero(date[1]) + '-' + owner.addLeadingZero(date[0]) : '';\n        },\n        getBlocks: function getBlocks() {\n          return this.blocks;\n        },\n        getValidatedDate: function getValidatedDate(value) {\n          var owner = this,\n              result = '';\n          value = value.replace(/[^\\d]/g, '');\n          owner.blocks.forEach(function (length, index) {\n            if (value.length > 0) {\n              var sub = value.slice(0, length),\n                  sub0 = sub.slice(0, 1),\n                  rest = value.slice(length);\n\n              switch (owner.datePattern[index]) {\n                case 'd':\n                  if (sub === '00') {\n                    sub = '01';\n                  } else if (parseInt(sub0, 10) > 3) {\n                    sub = '0' + sub0;\n                  } else if (parseInt(sub, 10) > 31) {\n                    sub = '31';\n                  }\n\n                  break;\n\n                case 'm':\n                  if (sub === '00') {\n                    sub = '01';\n                  } else if (parseInt(sub0, 10) > 1) {\n                    sub = '0' + sub0;\n                  } else if (parseInt(sub, 10) > 12) {\n                    sub = '12';\n                  }\n\n                  break;\n              }\n\n              result += sub; // update remaining string\n\n              value = rest;\n            }\n          });\n          return this.getFixedDateString(result);\n        },\n        getFixedDateString: function getFixedDateString(value) {\n          var owner = this,\n              datePattern = owner.datePattern,\n              date = [],\n              dayIndex = 0,\n              monthIndex = 0,\n              yearIndex = 0,\n              dayStartIndex = 0,\n              monthStartIndex = 0,\n              yearStartIndex = 0,\n              day,\n              month,\n              year,\n              fullYearDone = false; // mm-dd || dd-mm\n\n          if (value.length === 4 && datePattern[0].toLowerCase() !== 'y' && datePattern[1].toLowerCase() !== 'y') {\n            dayStartIndex = datePattern[0] === 'd' ? 0 : 2;\n            monthStartIndex = 2 - dayStartIndex;\n            day = parseInt(value.slice(dayStartIndex, dayStartIndex + 2), 10);\n            month = parseInt(value.slice(monthStartIndex, monthStartIndex + 2), 10);\n            date = this.getFixedDate(day, month, 0);\n          } // yyyy-mm-dd || yyyy-dd-mm || mm-dd-yyyy || dd-mm-yyyy || dd-yyyy-mm || mm-yyyy-dd\n\n\n          if (value.length === 8) {\n            datePattern.forEach(function (type, index) {\n              switch (type) {\n                case 'd':\n                  dayIndex = index;\n                  break;\n\n                case 'm':\n                  monthIndex = index;\n                  break;\n\n                default:\n                  yearIndex = index;\n                  break;\n              }\n            });\n            yearStartIndex = yearIndex * 2;\n            dayStartIndex = dayIndex <= yearIndex ? dayIndex * 2 : dayIndex * 2 + 2;\n            monthStartIndex = monthIndex <= yearIndex ? monthIndex * 2 : monthIndex * 2 + 2;\n            day = parseInt(value.slice(dayStartIndex, dayStartIndex + 2), 10);\n            month = parseInt(value.slice(monthStartIndex, monthStartIndex + 2), 10);\n            year = parseInt(value.slice(yearStartIndex, yearStartIndex + 4), 10);\n            fullYearDone = value.slice(yearStartIndex, yearStartIndex + 4).length === 4;\n            date = this.getFixedDate(day, month, year);\n          } // mm-yy || yy-mm\n\n\n          if (value.length === 4 && (datePattern[0] === 'y' || datePattern[1] === 'y')) {\n            monthStartIndex = datePattern[0] === 'm' ? 0 : 2;\n            yearStartIndex = 2 - monthStartIndex;\n            month = parseInt(value.slice(monthStartIndex, monthStartIndex + 2), 10);\n            year = parseInt(value.slice(yearStartIndex, yearStartIndex + 2), 10);\n            fullYearDone = value.slice(yearStartIndex, yearStartIndex + 2).length === 2;\n            date = [0, month, year];\n          } // mm-yyyy || yyyy-mm\n\n\n          if (value.length === 6 && (datePattern[0] === 'Y' || datePattern[1] === 'Y')) {\n            monthStartIndex = datePattern[0] === 'm' ? 0 : 4;\n            yearStartIndex = 2 - 0.5 * monthStartIndex;\n            month = parseInt(value.slice(monthStartIndex, monthStartIndex + 2), 10);\n            year = parseInt(value.slice(yearStartIndex, yearStartIndex + 4), 10);\n            fullYearDone = value.slice(yearStartIndex, yearStartIndex + 4).length === 4;\n            date = [0, month, year];\n          }\n\n          date = owner.getRangeFixedDate(date);\n          owner.date = date;\n          var result = date.length === 0 ? value : datePattern.reduce(function (previous, current) {\n            switch (current) {\n              case 'd':\n                return previous + (date[0] === 0 ? '' : owner.addLeadingZero(date[0]));\n\n              case 'm':\n                return previous + (date[1] === 0 ? '' : owner.addLeadingZero(date[1]));\n\n              case 'y':\n                return previous + (fullYearDone ? owner.addLeadingZeroForYear(date[2], false) : '');\n\n              case 'Y':\n                return previous + (fullYearDone ? owner.addLeadingZeroForYear(date[2], true) : '');\n            }\n          }, '');\n          return result;\n        },\n        getRangeFixedDate: function getRangeFixedDate(date) {\n          var owner = this,\n              datePattern = owner.datePattern,\n              dateMin = owner.dateMin || [],\n              dateMax = owner.dateMax || [];\n          if (!date.length || dateMin.length < 3 && dateMax.length < 3) return date;\n          if (datePattern.find(function (x) {\n            return x.toLowerCase() === 'y';\n          }) && date[2] === 0) return date;\n          if (dateMax.length && (dateMax[2] < date[2] || dateMax[2] === date[2] && (dateMax[1] < date[1] || dateMax[1] === date[1] && dateMax[0] < date[0]))) return dateMax;\n          if (dateMin.length && (dateMin[2] > date[2] || dateMin[2] === date[2] && (dateMin[1] > date[1] || dateMin[1] === date[1] && dateMin[0] > date[0]))) return dateMin;\n          return date;\n        },\n        getFixedDate: function getFixedDate(day, month, year) {\n          day = Math.min(day, 31);\n          month = Math.min(month, 12);\n          year = parseInt(year || 0, 10);\n\n          if (month < 7 && month % 2 === 0 || month > 8 && month % 2 === 1) {\n            day = Math.min(day, month === 2 ? this.isLeapYear(year) ? 29 : 28 : 30);\n          }\n\n          return [day, month, year];\n        },\n        isLeapYear: function isLeapYear(year) {\n          return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;\n        },\n        addLeadingZero: function addLeadingZero(number) {\n          return (number < 10 ? '0' : '') + number;\n        },\n        addLeadingZeroForYear: function addLeadingZeroForYear(number, fullYearMode) {\n          if (fullYearMode) {\n            return (number < 10 ? '000' : number < 100 ? '00' : number < 1000 ? '0' : '') + number;\n          }\n\n          return (number < 10 ? '0' : '') + number;\n        }\n      };\n      module.exports = DateFormatter;\n      /***/\n    },\n    /* 11 */\n\n    /***/\n    function (module, exports) {\n      'use strict';\n\n      var TimeFormatter = function TimeFormatter(timePattern, timeFormat) {\n        var owner = this;\n        owner.time = [];\n        owner.blocks = [];\n        owner.timePattern = timePattern;\n        owner.timeFormat = timeFormat;\n        owner.initBlocks();\n      };\n\n      TimeFormatter.prototype = {\n        initBlocks: function initBlocks() {\n          var owner = this;\n          owner.timePattern.forEach(function () {\n            owner.blocks.push(2);\n          });\n        },\n        getISOFormatTime: function getISOFormatTime() {\n          var owner = this,\n              time = owner.time;\n          return time[2] ? owner.addLeadingZero(time[0]) + ':' + owner.addLeadingZero(time[1]) + ':' + owner.addLeadingZero(time[2]) : '';\n        },\n        getBlocks: function getBlocks() {\n          return this.blocks;\n        },\n        getTimeFormatOptions: function getTimeFormatOptions() {\n          var owner = this;\n\n          if (String(owner.timeFormat) === '12') {\n            return {\n              maxHourFirstDigit: 1,\n              maxHours: 12,\n              maxMinutesFirstDigit: 5,\n              maxMinutes: 60\n            };\n          }\n\n          return {\n            maxHourFirstDigit: 2,\n            maxHours: 23,\n            maxMinutesFirstDigit: 5,\n            maxMinutes: 60\n          };\n        },\n        getValidatedTime: function getValidatedTime(value) {\n          var owner = this,\n              result = '';\n          value = value.replace(/[^\\d]/g, '');\n          var timeFormatOptions = owner.getTimeFormatOptions();\n          owner.blocks.forEach(function (length, index) {\n            if (value.length > 0) {\n              var sub = value.slice(0, length),\n                  sub0 = sub.slice(0, 1),\n                  rest = value.slice(length);\n\n              switch (owner.timePattern[index]) {\n                case 'h':\n                  if (parseInt(sub0, 10) > timeFormatOptions.maxHourFirstDigit) {\n                    sub = '0' + sub0;\n                  } else if (parseInt(sub, 10) > timeFormatOptions.maxHours) {\n                    sub = timeFormatOptions.maxHours + '';\n                  }\n\n                  break;\n\n                case 'm':\n                case 's':\n                  if (parseInt(sub0, 10) > timeFormatOptions.maxMinutesFirstDigit) {\n                    sub = '0' + sub0;\n                  } else if (parseInt(sub, 10) > timeFormatOptions.maxMinutes) {\n                    sub = timeFormatOptions.maxMinutes + '';\n                  }\n\n                  break;\n              }\n\n              result += sub; // update remaining string\n\n              value = rest;\n            }\n          });\n          return this.getFixedTimeString(result);\n        },\n        getFixedTimeString: function getFixedTimeString(value) {\n          var owner = this,\n              timePattern = owner.timePattern,\n              time = [],\n              secondIndex = 0,\n              minuteIndex = 0,\n              hourIndex = 0,\n              secondStartIndex = 0,\n              minuteStartIndex = 0,\n              hourStartIndex = 0,\n              second,\n              minute,\n              hour;\n\n          if (value.length === 6) {\n            timePattern.forEach(function (type, index) {\n              switch (type) {\n                case 's':\n                  secondIndex = index * 2;\n                  break;\n\n                case 'm':\n                  minuteIndex = index * 2;\n                  break;\n\n                case 'h':\n                  hourIndex = index * 2;\n                  break;\n              }\n            });\n            hourStartIndex = hourIndex;\n            minuteStartIndex = minuteIndex;\n            secondStartIndex = secondIndex;\n            second = parseInt(value.slice(secondStartIndex, secondStartIndex + 2), 10);\n            minute = parseInt(value.slice(minuteStartIndex, minuteStartIndex + 2), 10);\n            hour = parseInt(value.slice(hourStartIndex, hourStartIndex + 2), 10);\n            time = this.getFixedTime(hour, minute, second);\n          }\n\n          if (value.length === 4 && owner.timePattern.indexOf('s') < 0) {\n            timePattern.forEach(function (type, index) {\n              switch (type) {\n                case 'm':\n                  minuteIndex = index * 2;\n                  break;\n\n                case 'h':\n                  hourIndex = index * 2;\n                  break;\n              }\n            });\n            hourStartIndex = hourIndex;\n            minuteStartIndex = minuteIndex;\n            second = 0;\n            minute = parseInt(value.slice(minuteStartIndex, minuteStartIndex + 2), 10);\n            hour = parseInt(value.slice(hourStartIndex, hourStartIndex + 2), 10);\n            time = this.getFixedTime(hour, minute, second);\n          }\n\n          owner.time = time;\n          return time.length === 0 ? value : timePattern.reduce(function (previous, current) {\n            switch (current) {\n              case 's':\n                return previous + owner.addLeadingZero(time[2]);\n\n              case 'm':\n                return previous + owner.addLeadingZero(time[1]);\n\n              case 'h':\n                return previous + owner.addLeadingZero(time[0]);\n            }\n          }, '');\n        },\n        getFixedTime: function getFixedTime(hour, minute, second) {\n          second = Math.min(parseInt(second || 0, 10), 60);\n          minute = Math.min(minute, 60);\n          hour = Math.min(hour, 60);\n          return [hour, minute, second];\n        },\n        addLeadingZero: function addLeadingZero(number) {\n          return (number < 10 ? '0' : '') + number;\n        }\n      };\n      module.exports = TimeFormatter;\n      /***/\n    },\n    /* 12 */\n\n    /***/\n    function (module, exports) {\n      'use strict';\n\n      var PhoneFormatter = function PhoneFormatter(formatter, delimiter) {\n        var owner = this;\n        owner.delimiter = delimiter || delimiter === '' ? delimiter : ' ';\n        owner.delimiterRE = delimiter ? new RegExp('\\\\' + delimiter, 'g') : '';\n        owner.formatter = formatter;\n      };\n\n      PhoneFormatter.prototype = {\n        setFormatter: function setFormatter(formatter) {\n          this.formatter = formatter;\n        },\n        format: function format(phoneNumber) {\n          var owner = this;\n          owner.formatter.clear(); // only keep number and +\n\n          phoneNumber = phoneNumber.replace(/[^\\d+]/g, ''); // strip non-leading +\n\n          phoneNumber = phoneNumber.replace(/^\\+/, 'B').replace(/\\+/g, '').replace('B', '+'); // strip delimiter\n\n          phoneNumber = phoneNumber.replace(owner.delimiterRE, '');\n          var result = '',\n              current,\n              validated = false;\n\n          for (var i = 0, iMax = phoneNumber.length; i < iMax; i++) {\n            current = owner.formatter.inputDigit(phoneNumber.charAt(i)); // has ()- or space inside\n\n            if (/[\\s()-]/g.test(current)) {\n              result = current;\n              validated = true;\n            } else {\n              if (!validated) {\n                result = current;\n              } // else: over length input\n              // it turns to invalid number again\n\n            }\n          } // strip ()\n          // e.g. US: 7161234567 returns (716) 123-4567\n\n\n          result = result.replace(/[()]/g, ''); // replace library delimiter with user customized delimiter\n\n          result = result.replace(/[\\s-]/g, owner.delimiter);\n          return result;\n        }\n      };\n      module.exports = PhoneFormatter;\n      /***/\n    },\n    /* 13 */\n\n    /***/\n    function (module, exports) {\n      'use strict';\n\n      var CreditCardDetector = {\n        blocks: {\n          uatp: [4, 5, 6],\n          amex: [4, 6, 5],\n          diners: [4, 6, 4],\n          discover: [4, 4, 4, 4],\n          mastercard: [4, 4, 4, 4],\n          dankort: [4, 4, 4, 4],\n          instapayment: [4, 4, 4, 4],\n          jcb15: [4, 6, 5],\n          jcb: [4, 4, 4, 4],\n          maestro: [4, 4, 4, 4],\n          visa: [4, 4, 4, 4],\n          mir: [4, 4, 4, 4],\n          unionPay: [4, 4, 4, 4],\n          general: [4, 4, 4, 4]\n        },\n        re: {\n          // starts with 1; 15 digits, not starts with 1800 (jcb card)\n          uatp: /^(?!1800)1\\d{0,14}/,\n          // starts with 34/37; 15 digits\n          amex: /^3[47]\\d{0,13}/,\n          // starts with 6011/65/644-649; 16 digits\n          discover: /^(?:6011|65\\d{0,2}|64[4-9]\\d?)\\d{0,12}/,\n          // starts with 300-305/309 or 36/38/39; 14 digits\n          diners: /^3(?:0([0-5]|9)|[689]\\d?)\\d{0,11}/,\n          // starts with 51-55/22212720; 16 digits\n          mastercard: /^(5[1-5]\\d{0,2}|22[2-9]\\d{0,1}|2[3-7]\\d{0,2})\\d{0,12}/,\n          // starts with 5019/4175/4571; 16 digits\n          dankort: /^(5019|4175|4571)\\d{0,12}/,\n          // starts with 637-639; 16 digits\n          instapayment: /^63[7-9]\\d{0,13}/,\n          // starts with 2131/1800; 15 digits\n          jcb15: /^(?:2131|1800)\\d{0,11}/,\n          // starts with 2131/1800/35; 16 digits\n          jcb: /^(?:35\\d{0,2})\\d{0,12}/,\n          // starts with 50/56-58/6304/67; 16 digits\n          maestro: /^(?:5[0678]\\d{0,2}|6304|67\\d{0,2})\\d{0,12}/,\n          // starts with 22; 16 digits\n          mir: /^220[0-4]\\d{0,12}/,\n          // starts with 4; 16 digits\n          visa: /^4\\d{0,15}/,\n          // starts with 62/81; 16 digits\n          unionPay: /^(62|81)\\d{0,14}/\n        },\n        getStrictBlocks: function getStrictBlocks(block) {\n          var total = block.reduce(function (prev, current) {\n            return prev + current;\n          }, 0);\n          return block.concat(19 - total);\n        },\n        getInfo: function getInfo(value, strictMode) {\n          var blocks = CreditCardDetector.blocks,\n              re = CreditCardDetector.re; // Some credit card can have up to 19 digits number.\n          // Set strictMode to true will remove the 16 max-length restrain,\n          // however, I never found any website validate card number like\n          // this, hence probably you don't want to enable this option.\n\n          strictMode = !!strictMode;\n\n          for (var key in re) {\n            if (re[key].test(value)) {\n              var matchedBlocks = blocks[key];\n              return {\n                type: key,\n                blocks: strictMode ? this.getStrictBlocks(matchedBlocks) : matchedBlocks\n              };\n            }\n          }\n\n          return {\n            type: 'unknown',\n            blocks: strictMode ? this.getStrictBlocks(blocks.general) : blocks.general\n          };\n        }\n      };\n      module.exports = CreditCardDetector;\n      /***/\n    },\n    /* 14 */\n\n    /***/\n    function (module, exports) {\n      'use strict';\n\n      var Util = {\n        noop: function noop() {},\n        strip: function strip(value, re) {\n          return value.replace(re, '');\n        },\n        getPostDelimiter: function getPostDelimiter(value, delimiter, delimiters) {\n          // single delimiter\n          if (delimiters.length === 0) {\n            return value.slice(-delimiter.length) === delimiter ? delimiter : '';\n          } // multiple delimiters\n\n\n          var matchedDelimiter = '';\n          delimiters.forEach(function (current) {\n            if (value.slice(-current.length) === current) {\n              matchedDelimiter = current;\n            }\n          });\n          return matchedDelimiter;\n        },\n        getDelimiterREByDelimiter: function getDelimiterREByDelimiter(delimiter) {\n          return new RegExp(delimiter.replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1'), 'g');\n        },\n        getNextCursorPosition: function getNextCursorPosition(prevPos, oldValue, newValue, delimiter, delimiters) {\n          // If cursor was at the end of value, just place it back.\n          // Because new value could contain additional chars.\n          if (oldValue.length === prevPos) {\n            return newValue.length;\n          }\n\n          return prevPos + this.getPositionOffset(prevPos, oldValue, newValue, delimiter, delimiters);\n        },\n        getPositionOffset: function getPositionOffset(prevPos, oldValue, newValue, delimiter, delimiters) {\n          var oldRawValue, newRawValue, lengthOffset;\n          oldRawValue = this.stripDelimiters(oldValue.slice(0, prevPos), delimiter, delimiters);\n          newRawValue = this.stripDelimiters(newValue.slice(0, prevPos), delimiter, delimiters);\n          lengthOffset = oldRawValue.length - newRawValue.length;\n          return lengthOffset !== 0 ? lengthOffset / Math.abs(lengthOffset) : 0;\n        },\n        stripDelimiters: function stripDelimiters(value, delimiter, delimiters) {\n          var owner = this; // single delimiter\n\n          if (delimiters.length === 0) {\n            var delimiterRE = delimiter ? owner.getDelimiterREByDelimiter(delimiter) : '';\n            return value.replace(delimiterRE, '');\n          } // multiple delimiters\n\n\n          delimiters.forEach(function (current) {\n            current.split('').forEach(function (letter) {\n              value = value.replace(owner.getDelimiterREByDelimiter(letter), '');\n            });\n          });\n          return value;\n        },\n        headStr: function headStr(str, length) {\n          return str.slice(0, length);\n        },\n        getMaxLength: function getMaxLength(blocks) {\n          return blocks.reduce(function (previous, current) {\n            return previous + current;\n          }, 0);\n        },\n        // strip prefix\n        // Before type  |   After type    |     Return value\n        // PEFIX-...    |   PEFIX-...     |     ''\n        // PREFIX-123   |   PEFIX-123     |     123\n        // PREFIX-123   |   PREFIX-23     |     23\n        // PREFIX-123   |   PREFIX-1234   |     1234\n        getPrefixStrippedValue: function getPrefixStrippedValue(value, prefix, prefixLength, prevResult, delimiter, delimiters, noImmediatePrefix, tailPrefix, signBeforePrefix) {\n          // No prefix\n          if (prefixLength === 0) {\n            return value;\n          } // Value is prefix\n\n\n          if (value === prefix && value !== '') {\n            return '';\n          }\n\n          if (signBeforePrefix && value.slice(0, 1) == '-') {\n            var prev = prevResult.slice(0, 1) == '-' ? prevResult.slice(1) : prevResult;\n            return '-' + this.getPrefixStrippedValue(value.slice(1), prefix, prefixLength, prev, delimiter, delimiters, noImmediatePrefix, tailPrefix, signBeforePrefix);\n          } // Pre result prefix string does not match pre-defined prefix\n\n\n          if (prevResult.slice(0, prefixLength) !== prefix && !tailPrefix) {\n            // Check if the first time user entered something\n            if (noImmediatePrefix && !prevResult && value) return value;\n            return '';\n          } else if (prevResult.slice(-prefixLength) !== prefix && tailPrefix) {\n            // Check if the first time user entered something\n            if (noImmediatePrefix && !prevResult && value) return value;\n            return '';\n          }\n\n          var prevValue = this.stripDelimiters(prevResult, delimiter, delimiters); // New value has issue, someone typed in between prefix letters\n          // Revert to pre value\n\n          if (value.slice(0, prefixLength) !== prefix && !tailPrefix) {\n            return prevValue.slice(prefixLength);\n          } else if (value.slice(-prefixLength) !== prefix && tailPrefix) {\n            return prevValue.slice(0, -prefixLength - 1);\n          } // No issue, strip prefix for new value\n\n\n          return tailPrefix ? value.slice(0, -prefixLength) : value.slice(prefixLength);\n        },\n        getFirstDiffIndex: function getFirstDiffIndex(prev, current) {\n          var index = 0;\n\n          while (prev.charAt(index) === current.charAt(index)) {\n            if (prev.charAt(index++) === '') {\n              return -1;\n            }\n          }\n\n          return index;\n        },\n        getFormattedValue: function getFormattedValue(value, blocks, blocksLength, delimiter, delimiters, delimiterLazyShow) {\n          var result = '',\n              multipleDelimiters = delimiters.length > 0,\n              currentDelimiter = ''; // no options, normal input\n\n          if (blocksLength === 0) {\n            return value;\n          }\n\n          blocks.forEach(function (length, index) {\n            if (value.length > 0) {\n              var sub = value.slice(0, length),\n                  rest = value.slice(length);\n\n              if (multipleDelimiters) {\n                currentDelimiter = delimiters[delimiterLazyShow ? index - 1 : index] || currentDelimiter;\n              } else {\n                currentDelimiter = delimiter;\n              }\n\n              if (delimiterLazyShow) {\n                if (index > 0) {\n                  result += currentDelimiter;\n                }\n\n                result += sub;\n              } else {\n                result += sub;\n\n                if (sub.length === length && index < blocksLength - 1) {\n                  result += currentDelimiter;\n                }\n              } // update remaining string\n\n\n              value = rest;\n            }\n          });\n          return result;\n        },\n        // move cursor to the end\n        // the first time user focuses on an input with prefix\n        fixPrefixCursor: function fixPrefixCursor(el, prefix, delimiter, delimiters) {\n          if (!el) {\n            return;\n          }\n\n          var val = el.value,\n              appendix = delimiter || delimiters[0] || ' ';\n\n          if (!el.setSelectionRange || !prefix || prefix.length + appendix.length <= val.length) {\n            return;\n          }\n\n          var len = val.length * 2; // set timeout to avoid blink\n\n          setTimeout(function () {\n            el.setSelectionRange(len, len);\n          }, 1);\n        },\n        // Check if input field is fully selected\n        checkFullSelection: function checkFullSelection(value) {\n          try {\n            var selection = window.getSelection() || document.getSelection() || {};\n            return selection.toString().length === value.length;\n          } catch (ex) {// Ignore\n          }\n\n          return false;\n        },\n        setSelection: function setSelection(element, position, doc) {\n          if (element !== this.getActiveElement(doc)) {\n            return;\n          } // cursor is already in the end\n\n\n          if (element && element.value.length <= position) {\n            return;\n          }\n\n          if (element.createTextRange) {\n            var range = element.createTextRange();\n            range.move('character', position);\n            range.select();\n          } else {\n            try {\n              element.setSelectionRange(position, position);\n            } catch (e) {\n              // eslint-disable-next-line\n              console.warn('The input element type does not support selection');\n            }\n          }\n        },\n        getActiveElement: function getActiveElement(parent) {\n          var activeElement = parent.activeElement;\n\n          if (activeElement && activeElement.shadowRoot) {\n            return this.getActiveElement(activeElement.shadowRoot);\n          }\n\n          return activeElement;\n        },\n        isAndroid: function isAndroid() {\n          return navigator && /android/i.test(navigator.userAgent);\n        },\n        // On Android chrome, the keyup and keydown events\n        // always return key code 229 as a composition that\n        // buffers the users keystrokes\n        // see https://github.com/nosir/cleave.js/issues/147\n        isAndroidBackspaceKeydown: function isAndroidBackspaceKeydown(lastInputValue, currentInputValue) {\n          if (!this.isAndroid() || !lastInputValue || !currentInputValue) {\n            return false;\n          }\n\n          return currentInputValue === lastInputValue.slice(0, -1);\n        }\n      };\n      module.exports = Util;\n      /***/\n    },\n    /* 15 */\n\n    /***/\n    function (module, exports) {\n      'use strict';\n      /**\n       * Props Assignment\n       *\n       * Separate this, so react module can share the usage\n       */\n\n      var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n        return typeof obj;\n      } : function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n\n      var DefaultProperties = {\n        // Maybe change to object-assign\n        // for now just keep it as simple\n        assign: function assign(target, opts) {\n          target = target || {};\n          opts = opts || {}; // credit card\n\n          target.creditCard = !!opts.creditCard;\n          target.creditCardStrictMode = !!opts.creditCardStrictMode;\n          target.creditCardType = '';\n\n          target.onCreditCardTypeChanged = opts.onCreditCardTypeChanged || function () {}; // phone\n\n\n          target.phone = !!opts.phone;\n          target.phoneRegionCode = opts.phoneRegionCode || 'AU';\n          target.phoneFormatter = {}; // time\n\n          target.time = !!opts.time;\n          target.timePattern = opts.timePattern || ['h', 'm', 's'];\n          target.timeFormat = opts.timeFormat || '24';\n          target.timeFormatter = {}; // date\n\n          target.date = !!opts.date;\n          target.datePattern = opts.datePattern || ['d', 'm', 'Y'];\n          target.dateMin = opts.dateMin || '';\n          target.dateMax = opts.dateMax || '';\n          target.dateFormatter = {}; // numeral\n\n          target.numeral = !!opts.numeral;\n          target.numeralIntegerScale = opts.numeralIntegerScale > 0 ? opts.numeralIntegerScale : 0;\n          target.numeralDecimalScale = opts.numeralDecimalScale >= 0 ? opts.numeralDecimalScale : 2;\n          target.numeralDecimalMark = opts.numeralDecimalMark || '.';\n          target.numeralThousandsGroupStyle = opts.numeralThousandsGroupStyle || 'thousand';\n          target.numeralPositiveOnly = !!opts.numeralPositiveOnly;\n          target.stripLeadingZeroes = opts.stripLeadingZeroes !== false;\n          target.signBeforePrefix = !!opts.signBeforePrefix;\n          target.tailPrefix = !!opts.tailPrefix; // others\n\n          target.swapHiddenInput = !!opts.swapHiddenInput;\n          target.numericOnly = target.creditCard || target.date || !!opts.numericOnly;\n          target.uppercase = !!opts.uppercase;\n          target.lowercase = !!opts.lowercase;\n          target.prefix = target.creditCard || target.date ? '' : opts.prefix || '';\n          target.noImmediatePrefix = !!opts.noImmediatePrefix;\n          target.prefixLength = target.prefix.length;\n          target.rawValueTrimPrefix = !!opts.rawValueTrimPrefix;\n          target.copyDelimiter = !!opts.copyDelimiter;\n          target.initValue = opts.initValue !== undefined && opts.initValue !== null ? opts.initValue.toString() : '';\n          target.delimiter = opts.delimiter || opts.delimiter === '' ? opts.delimiter : opts.date ? '/' : opts.time ? ':' : opts.numeral ? ',' : opts.phone ? ' ' : ' ';\n          target.delimiterLength = target.delimiter.length;\n          target.delimiterLazyShow = !!opts.delimiterLazyShow;\n          target.delimiters = opts.delimiters || [];\n          target.blocks = opts.blocks || [];\n          target.blocksLength = target.blocks.length;\n          target.root = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) === 'object' && global ? global : window;\n          target.document = opts.document || target.root.document;\n          target.maxLength = 0;\n          target.backspace = false;\n          target.result = '';\n\n          target.onValueChanged = opts.onValueChanged || function () {};\n\n          return target;\n        }\n      };\n      module.exports = DefaultProperties;\n      /***/\n    }\n    /******/\n    ])\n  );\n});\n\n;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(\"yLpj\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2xlYXZlLmpzL2Rpc3QvY2xlYXZlLXJlYWN0LW5vZGUuanM/MDA0OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpRUFBTyxDQUFDLE1BQWlDOztBQUV6QztBQUNBLE1BQU0sSUFBeUQsMkJBQTJCLG1CQUFPLENBQUMsTUFBTyxHQUFHLEtBQUssRUFBNE07QUFDN1QsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlDQUF5Qzs7O0FBR3pDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7O0FBR1gsNERBQTREOztBQUU1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7OztBQUdBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsa0VBQWtFLFFBQVE7QUFDMUU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNB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O0FBQzlEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7OztBQUdYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7OztBQUdYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7O0FBR1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTs7QUFFQSwwRkFBMEY7OztBQUcxRjtBQUNBO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxDIiwiZmlsZSI6Ik0vZE4uanMiLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnJlZHVjZVwiKTtcblxuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JykgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJyZWFjdFwiKSk7ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSBkZWZpbmUoW1wicmVhY3RcIl0sIGZhY3RvcnkpO2Vsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JykgZXhwb3J0c1tcIkNsZWF2ZVwiXSA9IGZhY3RvcnkocmVxdWlyZShcInJlYWN0XCIpKTtlbHNlIHJvb3RbXCJDbGVhdmVcIl0gPSBmYWN0b3J5KHJvb3RbXCJSZWFjdFwiXSk7XG59KSh0aGlzLCBmdW5jdGlvbiAoX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8xX18pIHtcbiAgcmV0dXJuIChcbiAgICAvKioqKioqL1xuICAgIGZ1bmN0aW9uIChtb2R1bGVzKSB7XG4gICAgICAvLyB3ZWJwYWNrQm9vdHN0cmFwXG5cbiAgICAgIC8qKioqKiovXG4gICAgICAvLyBUaGUgbW9kdWxlIGNhY2hlXG5cbiAgICAgIC8qKioqKiovXG4gICAgICB2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuICAgICAgLyoqKioqKi9cbiAgICAgIC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5cbiAgICAgIC8qKioqKiovXG5cbiAgICAgIGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbiAgICAgICAgLyoqKioqKi9cbiAgICAgICAgLy8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cbiAgICAgICAgLyoqKioqKi9cbiAgICAgICAgaWYgKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuICAgICAgICAgIC8qKioqKiovXG4gICAgICAgICAgcmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gICAgICAgIC8qKioqKiovXG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cbiAgICAgICAgLyoqKioqKi9cblxuICAgICAgICB2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gICAgICAgICAgLyoqKioqKi9cbiAgICAgICAgICBleHBvcnRzOiB7fSxcblxuICAgICAgICAgIC8qKioqKiovXG4gICAgICAgICAgaWQ6IG1vZHVsZUlkLFxuXG4gICAgICAgICAgLyoqKioqKi9cbiAgICAgICAgICBsb2FkZWQ6IGZhbHNlXG4gICAgICAgICAgLyoqKioqKi9cblxuICAgICAgICB9O1xuICAgICAgICAvKioqKioqL1xuICAgICAgICAvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblxuICAgICAgICAvKioqKioqL1xuXG4gICAgICAgIG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuICAgICAgICAvKioqKioqL1xuICAgICAgICAvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG5cbiAgICAgICAgLyoqKioqKi9cblxuICAgICAgICBtb2R1bGUubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgLyoqKioqKi9cbiAgICAgICAgLy8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblxuICAgICAgICAvKioqKioqL1xuXG4gICAgICAgIHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiAgICAgICAgLyoqKioqKi9cbiAgICAgIH1cbiAgICAgIC8qKioqKiovXG4gICAgICAvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuXG4gICAgICAvKioqKioqL1xuXG5cbiAgICAgIF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4gICAgICAvKioqKioqL1xuICAgICAgLy8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcblxuICAgICAgLyoqKioqKi9cblxuICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbiAgICAgIC8qKioqKiovXG4gICAgICAvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuXG4gICAgICAvKioqKioqL1xuXG4gICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuICAgICAgLyoqKioqKi9cbiAgICAgIC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuXG4gICAgICAvKioqKioqL1xuXG4gICAgICByZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbiAgICAgIC8qKioqKiovXG4gICAgfShcbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgLyoqKioqKi9cbiAgICBbXG4gICAgLyogMCAqL1xuXG4gICAgLyoqKi9cbiAgICBmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgIHZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSB7fTtcblxuICAgICAgICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgICAgICAgIGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7XG4gICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7XG4gICAgICAgICAgdGFyZ2V0W2ldID0gb2JqW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIH1cblxuICAgICAgdmFyIFJlYWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG5cbiAgICAgIHZhciBDcmVhdGVSZWFjdENsYXNzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxuICAgICAgdmFyIE51bWVyYWxGb3JtYXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG4gICAgICB2YXIgRGF0ZUZvcm1hdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXG4gICAgICB2YXIgVGltZUZvcm1hdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG4gICAgICB2YXIgUGhvbmVGb3JtYXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcblxuICAgICAgdmFyIENyZWRpdENhcmREZXRlY3RvciA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXG4gICAgICB2YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXG4gICAgICB2YXIgRGVmYXVsdFByb3BlcnRpZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblxuICAgICAgdmFyIGNsZWF2ZVJlYWN0Q2xhc3MgPSBDcmVhdGVSZWFjdENsYXNzKHtcbiAgICAgICAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICB9LFxuICAgICAgICBjb21wb25lbnREaWRVcGRhdGU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgICAgICB2YXIgb3duZXIgPSB0aGlzLFxuICAgICAgICAgICAgICBwaG9uZVJlZ2lvbkNvZGUgPSAob3duZXIucHJvcHMub3B0aW9ucyB8fCB7fSkucGhvbmVSZWdpb25Db2RlLFxuICAgICAgICAgICAgICBuZXdWYWx1ZSA9IG93bmVyLnByb3BzLnZhbHVlLFxuICAgICAgICAgICAgICBwcHMgPSBvd25lci5wcm9wZXJ0aWVzO1xuICAgICAgICAgIG93bmVyLnVwZGF0ZVJlZ2lzdGVyZWRFdmVudHMob3duZXIucHJvcHMpO1xuXG4gICAgICAgICAgaWYgKHByZXZQcm9wcy52YWx1ZSAhPT0gbmV3VmFsdWUgJiYgbmV3VmFsdWUgIT09IHVuZGVmaW5lZCAmJiBuZXdWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBuZXdWYWx1ZS50b1N0cmluZygpO1xuXG4gICAgICAgICAgICBpZiAobmV3VmFsdWUgIT09IG93bmVyLnByb3BlcnRpZXMucmVzdWx0KSB7XG4gICAgICAgICAgICAgIG93bmVyLnByb3BlcnRpZXMuaW5pdFZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgIG93bmVyLm9uSW5wdXQobmV3VmFsdWUsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gdXBkYXRlIHBob25lIHJlZ2lvbiBjb2RlXG5cblxuICAgICAgICAgIHZhciBwcmV2UGhvbmVSZWdpb25Db2RlID0gKHByZXZQcm9wcy5vcHRpb25zIHx8IHt9KS5waG9uZVJlZ2lvbkNvZGU7XG5cbiAgICAgICAgICBpZiAocHJldlBob25lUmVnaW9uQ29kZSAhPT0gcGhvbmVSZWdpb25Db2RlICYmIHBob25lUmVnaW9uQ29kZSAmJiBwaG9uZVJlZ2lvbkNvZGUgIT09IG93bmVyLnByb3BlcnRpZXMucGhvbmVSZWdpb25Db2RlKSB7XG4gICAgICAgICAgICBvd25lci5wcm9wZXJ0aWVzLnBob25lUmVnaW9uQ29kZSA9IHBob25lUmVnaW9uQ29kZTtcbiAgICAgICAgICAgIG93bmVyLmluaXRQaG9uZUZvcm1hdHRlcigpO1xuICAgICAgICAgICAgb3duZXIub25JbnB1dChvd25lci5wcm9wZXJ0aWVzLnJlc3VsdCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgVXRpbC5zZXRTZWxlY3Rpb24ob3duZXIuZWxlbWVudCwgb3duZXIuc3RhdGUuY3Vyc29yUG9zaXRpb24sIHBwcy5kb2N1bWVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZVJlZ2lzdGVyZWRFdmVudHM6IGZ1bmN0aW9uIHVwZGF0ZVJlZ2lzdGVyZWRFdmVudHMocHJvcHMpIHtcbiAgICAgICAgICB2YXIgb3duZXIgPSB0aGlzLFxuICAgICAgICAgICAgICBfb3duZXIkcmVnaXN0ZXJlZEV2ZW4gPSBvd25lci5yZWdpc3RlcmVkRXZlbnRzLFxuICAgICAgICAgICAgICBvbktleURvd24gPSBfb3duZXIkcmVnaXN0ZXJlZEV2ZW4ub25LZXlEb3duLFxuICAgICAgICAgICAgICBvbkNoYW5nZSA9IF9vd25lciRyZWdpc3RlcmVkRXZlbi5vbkNoYW5nZSxcbiAgICAgICAgICAgICAgb25Gb2N1cyA9IF9vd25lciRyZWdpc3RlcmVkRXZlbi5vbkZvY3VzLFxuICAgICAgICAgICAgICBvbkJsdXIgPSBfb3duZXIkcmVnaXN0ZXJlZEV2ZW4ub25CbHVyLFxuICAgICAgICAgICAgICBvbkluaXQgPSBfb3duZXIkcmVnaXN0ZXJlZEV2ZW4ub25Jbml0O1xuICAgICAgICAgIGlmIChwcm9wcy5vbkluaXQgJiYgcHJvcHMub25Jbml0ICE9PSBvbkluaXQpIG93bmVyLnJlZ2lzdGVyZWRFdmVudHMub25Jbml0ID0gcHJvcHMub25Jbml0O1xuICAgICAgICAgIGlmIChwcm9wcy5vbkNoYW5nZSAmJiBwcm9wcy5vbkNoYW5nZSAhPT0gb25DaGFuZ2UpIG93bmVyLnJlZ2lzdGVyZWRFdmVudHMub25DaGFuZ2UgPSBwcm9wcy5vbkNoYW5nZTtcbiAgICAgICAgICBpZiAocHJvcHMub25Gb2N1cyAmJiBwcm9wcy5vbkZvY3VzICE9PSBvbkZvY3VzKSBvd25lci5yZWdpc3RlcmVkRXZlbnRzLm9uRm9jdXMgPSBwcm9wcy5vbkZvY3VzO1xuICAgICAgICAgIGlmIChwcm9wcy5vbkJsdXIgJiYgcHJvcHMub25CbHVyICE9PSBvbkJsdXIpIG93bmVyLnJlZ2lzdGVyZWRFdmVudHMub25CbHVyID0gcHJvcHMub25CbHVyO1xuICAgICAgICAgIGlmIChwcm9wcy5vbktleURvd24gJiYgcHJvcHMub25LZXlEb3duICE9PSBvbktleURvd24pIG93bmVyLnJlZ2lzdGVyZWRFdmVudHMub25LZXlEb3duID0gcHJvcHMub25LZXlEb3duO1xuICAgICAgICB9LFxuICAgICAgICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZSgpIHtcbiAgICAgICAgICB2YXIgb3duZXIgPSB0aGlzLFxuICAgICAgICAgICAgICBfb3duZXIkcHJvcHMgPSBvd25lci5wcm9wcyxcbiAgICAgICAgICAgICAgdmFsdWUgPSBfb3duZXIkcHJvcHMudmFsdWUsXG4gICAgICAgICAgICAgIG9wdGlvbnMgPSBfb3duZXIkcHJvcHMub3B0aW9ucyxcbiAgICAgICAgICAgICAgb25LZXlEb3duID0gX293bmVyJHByb3BzLm9uS2V5RG93bixcbiAgICAgICAgICAgICAgb25DaGFuZ2UgPSBfb3duZXIkcHJvcHMub25DaGFuZ2UsXG4gICAgICAgICAgICAgIG9uRm9jdXMgPSBfb3duZXIkcHJvcHMub25Gb2N1cyxcbiAgICAgICAgICAgICAgb25CbHVyID0gX293bmVyJHByb3BzLm9uQmx1cixcbiAgICAgICAgICAgICAgb25Jbml0ID0gX293bmVyJHByb3BzLm9uSW5pdDtcbiAgICAgICAgICBvd25lci5yZWdpc3RlcmVkRXZlbnRzID0ge1xuICAgICAgICAgICAgb25Jbml0OiBvbkluaXQgfHwgVXRpbC5ub29wLFxuICAgICAgICAgICAgb25DaGFuZ2U6IG9uQ2hhbmdlIHx8IFV0aWwubm9vcCxcbiAgICAgICAgICAgIG9uRm9jdXM6IG9uRm9jdXMgfHwgVXRpbC5ub29wLFxuICAgICAgICAgICAgb25CbHVyOiBvbkJsdXIgfHwgVXRpbC5ub29wLFxuICAgICAgICAgICAgb25LZXlEb3duOiBvbktleURvd24gfHwgVXRpbC5ub29wXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG9wdGlvbnMuaW5pdFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgb3duZXIucHJvcGVydGllcyA9IERlZmF1bHRQcm9wZXJ0aWVzLmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiBvd25lci5wcm9wZXJ0aWVzLnJlc3VsdCxcbiAgICAgICAgICAgIGN1cnNvclBvc2l0aW9uOiAwXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5pdDogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgICAgICB2YXIgb3duZXIgPSB0aGlzLFxuICAgICAgICAgICAgICBwcHMgPSBvd25lci5wcm9wZXJ0aWVzOyAvLyBzbyBubyBuZWVkIGZvciB0aGlzIGxpYiBhdCBhbGxcblxuICAgICAgICAgIGlmICghcHBzLm51bWVyYWwgJiYgIXBwcy5waG9uZSAmJiAhcHBzLmNyZWRpdENhcmQgJiYgIXBwcy50aW1lICYmICFwcHMuZGF0ZSAmJiBwcHMuYmxvY2tzTGVuZ3RoID09PSAwICYmICFwcHMucHJlZml4KSB7XG4gICAgICAgICAgICBvd25lci5vbklucHV0KHBwcy5pbml0VmFsdWUpO1xuICAgICAgICAgICAgb3duZXIucmVnaXN0ZXJlZEV2ZW50cy5vbkluaXQob3duZXIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBwcy5tYXhMZW5ndGggPSBVdGlsLmdldE1heExlbmd0aChwcHMuYmxvY2tzKTtcbiAgICAgICAgICBvd25lci5pc0FuZHJvaWQgPSBVdGlsLmlzQW5kcm9pZCgpO1xuICAgICAgICAgIG93bmVyLmluaXRQaG9uZUZvcm1hdHRlcigpO1xuICAgICAgICAgIG93bmVyLmluaXREYXRlRm9ybWF0dGVyKCk7XG4gICAgICAgICAgb3duZXIuaW5pdFRpbWVGb3JtYXR0ZXIoKTtcbiAgICAgICAgICBvd25lci5pbml0TnVtZXJhbEZvcm1hdHRlcigpOyAvLyBhdm9pZCB0b3VjaCBpbnB1dCBmaWVsZCBpZiB2YWx1ZSBpcyBudWxsXG4gICAgICAgICAgLy8gb3RoZXJ3aXNlIEZpcmVmb3ggd2lsbCBhZGQgcmVkIGJveC1zaGFkb3cgZm9yIDxpbnB1dCByZXF1aXJlZCAvPlxuXG4gICAgICAgICAgaWYgKHBwcy5pbml0VmFsdWUgfHwgcHBzLnByZWZpeCAmJiAhcHBzLm5vSW1tZWRpYXRlUHJlZml4KSB7XG4gICAgICAgICAgICBvd25lci5vbklucHV0KHBwcy5pbml0VmFsdWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG93bmVyLnJlZ2lzdGVyZWRFdmVudHMub25Jbml0KG93bmVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5pdE51bWVyYWxGb3JtYXR0ZXI6IGZ1bmN0aW9uIGluaXROdW1lcmFsRm9ybWF0dGVyKCkge1xuICAgICAgICAgIHZhciBvd25lciA9IHRoaXMsXG4gICAgICAgICAgICAgIHBwcyA9IG93bmVyLnByb3BlcnRpZXM7XG5cbiAgICAgICAgICBpZiAoIXBwcy5udW1lcmFsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcHBzLm51bWVyYWxGb3JtYXR0ZXIgPSBuZXcgTnVtZXJhbEZvcm1hdHRlcihwcHMubnVtZXJhbERlY2ltYWxNYXJrLCBwcHMubnVtZXJhbEludGVnZXJTY2FsZSwgcHBzLm51bWVyYWxEZWNpbWFsU2NhbGUsIHBwcy5udW1lcmFsVGhvdXNhbmRzR3JvdXBTdHlsZSwgcHBzLm51bWVyYWxQb3NpdGl2ZU9ubHksIHBwcy5zdHJpcExlYWRpbmdaZXJvZXMsIHBwcy5wcmVmaXgsIHBwcy5zaWduQmVmb3JlUHJlZml4LCBwcHMudGFpbFByZWZpeCwgcHBzLmRlbGltaXRlcik7XG4gICAgICAgIH0sXG4gICAgICAgIGluaXRUaW1lRm9ybWF0dGVyOiBmdW5jdGlvbiBpbml0VGltZUZvcm1hdHRlcigpIHtcbiAgICAgICAgICB2YXIgb3duZXIgPSB0aGlzLFxuICAgICAgICAgICAgICBwcHMgPSBvd25lci5wcm9wZXJ0aWVzO1xuXG4gICAgICAgICAgaWYgKCFwcHMudGltZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBwcy50aW1lRm9ybWF0dGVyID0gbmV3IFRpbWVGb3JtYXR0ZXIocHBzLnRpbWVQYXR0ZXJuLCBwcHMudGltZUZvcm1hdCk7XG4gICAgICAgICAgcHBzLmJsb2NrcyA9IHBwcy50aW1lRm9ybWF0dGVyLmdldEJsb2NrcygpO1xuICAgICAgICAgIHBwcy5ibG9ja3NMZW5ndGggPSBwcHMuYmxvY2tzLmxlbmd0aDtcbiAgICAgICAgICBwcHMubWF4TGVuZ3RoID0gVXRpbC5nZXRNYXhMZW5ndGgocHBzLmJsb2Nrcyk7XG4gICAgICAgIH0sXG4gICAgICAgIGluaXREYXRlRm9ybWF0dGVyOiBmdW5jdGlvbiBpbml0RGF0ZUZvcm1hdHRlcigpIHtcbiAgICAgICAgICB2YXIgb3duZXIgPSB0aGlzLFxuICAgICAgICAgICAgICBwcHMgPSBvd25lci5wcm9wZXJ0aWVzO1xuXG4gICAgICAgICAgaWYgKCFwcHMuZGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBwcy5kYXRlRm9ybWF0dGVyID0gbmV3IERhdGVGb3JtYXR0ZXIocHBzLmRhdGVQYXR0ZXJuLCBwcHMuZGF0ZU1pbiwgcHBzLmRhdGVNYXgpO1xuICAgICAgICAgIHBwcy5ibG9ja3MgPSBwcHMuZGF0ZUZvcm1hdHRlci5nZXRCbG9ja3MoKTtcbiAgICAgICAgICBwcHMuYmxvY2tzTGVuZ3RoID0gcHBzLmJsb2Nrcy5sZW5ndGg7XG4gICAgICAgICAgcHBzLm1heExlbmd0aCA9IFV0aWwuZ2V0TWF4TGVuZ3RoKHBwcy5ibG9ja3MpO1xuICAgICAgICB9LFxuICAgICAgICBpbml0UGhvbmVGb3JtYXR0ZXI6IGZ1bmN0aW9uIGluaXRQaG9uZUZvcm1hdHRlcigpIHtcbiAgICAgICAgICB2YXIgb3duZXIgPSB0aGlzLFxuICAgICAgICAgICAgICBwcHMgPSBvd25lci5wcm9wZXJ0aWVzO1xuXG4gICAgICAgICAgaWYgKCFwcHMucGhvbmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IC8vIENsZWF2ZS5Bc1lvdVR5cGVGb3JtYXR0ZXIgc2hvdWxkIGJlIHByb3ZpZGVkIGJ5XG4gICAgICAgICAgLy8gZXh0ZXJuYWwgZ29vZ2xlIGNsb3N1cmUgbGliXG5cblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwcHMucGhvbmVGb3JtYXR0ZXIgPSBuZXcgUGhvbmVGb3JtYXR0ZXIobmV3IHBwcy5yb290LkNsZWF2ZS5Bc1lvdVR5cGVGb3JtYXR0ZXIocHBzLnBob25lUmVnaW9uQ29kZSksIHBwcy5kZWxpbWl0ZXIpO1xuICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBpbmNsdWRlIHBob25lLXR5cGUtZm9ybWF0dGVyLntjb3VudHJ5fS5qcyBsaWInKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNldFJhd1ZhbHVlOiBmdW5jdGlvbiBzZXRSYXdWYWx1ZSh2YWx1ZSkge1xuICAgICAgICAgIHZhciBvd25lciA9IHRoaXMsXG4gICAgICAgICAgICAgIHBwcyA9IG93bmVyLnByb3BlcnRpZXM7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsID8gdmFsdWUudG9TdHJpbmcoKSA6ICcnO1xuXG4gICAgICAgICAgaWYgKHBwcy5udW1lcmFsKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoJy4nLCBwcHMubnVtZXJhbERlY2ltYWxNYXJrKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwcHMucG9zdERlbGltaXRlckJhY2tzcGFjZSA9IGZhbHNlO1xuICAgICAgICAgIG93bmVyLm9uQ2hhbmdlKHtcbiAgICAgICAgICAgIHRhcmdldDoge1xuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBNZXRob2RzIHRvIGJldHRlciByZXNlbWJsZSBhIFN5bnRoZXRpY0V2ZW50XG4gICAgICAgICAgICBzdG9wUHJvcGFnYXRpb246IFV0aWwubm9vcCxcbiAgICAgICAgICAgIHByZXZlbnREZWZhdWx0OiBVdGlsLm5vb3AsXG4gICAgICAgICAgICBwZXJzaXN0OiBVdGlsLm5vb3BcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0UmF3VmFsdWU6IGZ1bmN0aW9uIGdldFJhd1ZhbHVlKCkge1xuICAgICAgICAgIHZhciBvd25lciA9IHRoaXMsXG4gICAgICAgICAgICAgIHBwcyA9IG93bmVyLnByb3BlcnRpZXMsXG4gICAgICAgICAgICAgIHJhd1ZhbHVlID0gcHBzLnJlc3VsdDtcblxuICAgICAgICAgIGlmIChwcHMucmF3VmFsdWVUcmltUHJlZml4KSB7XG4gICAgICAgICAgICByYXdWYWx1ZSA9IFV0aWwuZ2V0UHJlZml4U3RyaXBwZWRWYWx1ZShyYXdWYWx1ZSwgcHBzLnByZWZpeCwgcHBzLnByZWZpeExlbmd0aCwgcHBzLnJlc3VsdCwgcHBzLmRlbGltaXRlciwgcHBzLmRlbGltaXRlcnMsIHBwcy5ub0ltbWVkaWF0ZVByZWZpeCwgcHBzLnRhaWxQcmVmaXgsIHBwcy5zaWduQmVmb3JlUHJlZml4KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocHBzLm51bWVyYWwpIHtcbiAgICAgICAgICAgIHJhd1ZhbHVlID0gcHBzLm51bWVyYWxGb3JtYXR0ZXIgPyBwcHMubnVtZXJhbEZvcm1hdHRlci5nZXRSYXdWYWx1ZShyYXdWYWx1ZSkgOiAnJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmF3VmFsdWUgPSBVdGlsLnN0cmlwRGVsaW1pdGVycyhyYXdWYWx1ZSwgcHBzLmRlbGltaXRlciwgcHBzLmRlbGltaXRlcnMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByYXdWYWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0SVNPRm9ybWF0RGF0ZTogZnVuY3Rpb24gZ2V0SVNPRm9ybWF0RGF0ZSgpIHtcbiAgICAgICAgICB2YXIgb3duZXIgPSB0aGlzLFxuICAgICAgICAgICAgICBwcHMgPSBvd25lci5wcm9wZXJ0aWVzO1xuICAgICAgICAgIHJldHVybiBwcHMuZGF0ZSA/IHBwcy5kYXRlRm9ybWF0dGVyLmdldElTT0Zvcm1hdERhdGUoKSA6ICcnO1xuICAgICAgICB9LFxuICAgICAgICBnZXRJU09Gb3JtYXRUaW1lOiBmdW5jdGlvbiBnZXRJU09Gb3JtYXRUaW1lKCkge1xuICAgICAgICAgIHZhciBvd25lciA9IHRoaXMsXG4gICAgICAgICAgICAgIHBwcyA9IG93bmVyLnByb3BlcnRpZXM7XG4gICAgICAgICAgcmV0dXJuIHBwcy50aW1lID8gcHBzLnRpbWVGb3JtYXR0ZXIuZ2V0SVNPRm9ybWF0VGltZSgpIDogJyc7XG4gICAgICAgIH0sXG4gICAgICAgIG9uSW5pdDogZnVuY3Rpb24gb25Jbml0KG93bmVyKSB7XG4gICAgICAgICAgcmV0dXJuIG93bmVyO1xuICAgICAgICB9LFxuICAgICAgICBvbktleURvd246IGZ1bmN0aW9uIG9uS2V5RG93bihldmVudCkge1xuICAgICAgICAgIHZhciBvd25lciA9IHRoaXMsXG4gICAgICAgICAgICAgIHBwcyA9IG93bmVyLnByb3BlcnRpZXMsXG4gICAgICAgICAgICAgIGNoYXJDb2RlID0gZXZlbnQud2hpY2ggfHwgZXZlbnQua2V5Q29kZTtcbiAgICAgICAgICBvd25lci5sYXN0SW5wdXRWYWx1ZSA9IHBwcy5yZXN1bHQ7XG4gICAgICAgICAgb3duZXIuaXNCYWNrd2FyZCA9IGNoYXJDb2RlID09PSA4O1xuICAgICAgICAgIG93bmVyLnJlZ2lzdGVyZWRFdmVudHMub25LZXlEb3duKGV2ZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Gb2N1czogZnVuY3Rpb24gb25Gb2N1cyhldmVudCkge1xuICAgICAgICAgIHZhciBvd25lciA9IHRoaXMsXG4gICAgICAgICAgICAgIHBwcyA9IG93bmVyLnByb3BlcnRpZXM7XG5cbiAgICAgICAgICBpZiAocHBzLnByZWZpeCAmJiBwcHMubm9JbW1lZGlhdGVQcmVmaXggJiYgIWV2ZW50LnRhcmdldC52YWx1ZSkge1xuICAgICAgICAgICAgb3duZXIub25JbnB1dChwcHMucHJlZml4KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBldmVudC50YXJnZXQucmF3VmFsdWUgPSBvd25lci5nZXRSYXdWYWx1ZSgpO1xuICAgICAgICAgIGV2ZW50LnRhcmdldC52YWx1ZSA9IHBwcy5yZXN1bHQ7XG4gICAgICAgICAgb3duZXIucmVnaXN0ZXJlZEV2ZW50cy5vbkZvY3VzKGV2ZW50KTtcbiAgICAgICAgICBVdGlsLmZpeFByZWZpeEN1cnNvcihvd25lci5lbGVtZW50LCBwcHMucHJlZml4LCBwcHMuZGVsaW1pdGVyLCBwcHMuZGVsaW1pdGVycyk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQmx1cjogZnVuY3Rpb24gb25CbHVyKGV2ZW50KSB7XG4gICAgICAgICAgdmFyIG93bmVyID0gdGhpcyxcbiAgICAgICAgICAgICAgcHBzID0gb3duZXIucHJvcGVydGllcztcbiAgICAgICAgICBldmVudC50YXJnZXQucmF3VmFsdWUgPSBvd25lci5nZXRSYXdWYWx1ZSgpO1xuICAgICAgICAgIGV2ZW50LnRhcmdldC52YWx1ZSA9IHBwcy5yZXN1bHQ7XG4gICAgICAgICAgb3duZXIucmVnaXN0ZXJlZEV2ZW50cy5vbkJsdXIoZXZlbnQpO1xuICAgICAgICB9LFxuICAgICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UoZXZlbnQpIHtcbiAgICAgICAgICB2YXIgb3duZXIgPSB0aGlzLFxuICAgICAgICAgICAgICBwcHMgPSBvd25lci5wcm9wZXJ0aWVzO1xuICAgICAgICAgIG93bmVyLmlzQmFja3dhcmQgPSBvd25lci5pc0JhY2t3YXJkIHx8IGV2ZW50LmlucHV0VHlwZSA9PT0gJ2RlbGV0ZUNvbnRlbnRCYWNrd2FyZCc7IC8vIGhpdCBiYWNrc3BhY2Ugd2hlbiBsYXN0IGNoYXJhY3RlciBpcyBkZWxpbWl0ZXJcblxuICAgICAgICAgIHZhciBwb3N0RGVsaW1pdGVyID0gVXRpbC5nZXRQb3N0RGVsaW1pdGVyKG93bmVyLmxhc3RJbnB1dFZhbHVlLCBwcHMuZGVsaW1pdGVyLCBwcHMuZGVsaW1pdGVycyk7XG5cbiAgICAgICAgICBpZiAob3duZXIuaXNCYWNrd2FyZCAmJiBwb3N0RGVsaW1pdGVyKSB7XG4gICAgICAgICAgICBwcHMucG9zdERlbGltaXRlckJhY2tzcGFjZSA9IHBvc3REZWxpbWl0ZXI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBwcy5wb3N0RGVsaW1pdGVyQmFja3NwYWNlID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb3duZXIub25JbnB1dChldmVudC50YXJnZXQudmFsdWUpO1xuICAgICAgICAgIGV2ZW50LnRhcmdldC5yYXdWYWx1ZSA9IG93bmVyLmdldFJhd1ZhbHVlKCk7XG4gICAgICAgICAgZXZlbnQudGFyZ2V0LnZhbHVlID0gcHBzLnJlc3VsdDtcbiAgICAgICAgICBvd25lci5yZWdpc3RlcmVkRXZlbnRzLm9uQ2hhbmdlKGV2ZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25JbnB1dDogZnVuY3Rpb24gb25JbnB1dCh2YWx1ZSwgZnJvbVByb3BzKSB7XG4gICAgICAgICAgdmFyIG93bmVyID0gdGhpcyxcbiAgICAgICAgICAgICAgcHBzID0gb3duZXIucHJvcGVydGllczsgLy8gY2FzZSAxOiBkZWxldGUgb25lIG1vcmUgY2hhcmFjdGVyIFwiNFwiXG4gICAgICAgICAgLy8gMTIzNCp8IC0+IGhpdCBiYWNrc3BhY2UgLT4gMTIzfFxuICAgICAgICAgIC8vIGNhc2UgMjogbGFzdCBjaGFyYWN0ZXIgaXMgbm90IGRlbGltaXRlciB3aGljaCBpczpcbiAgICAgICAgICAvLyAxMnwzNCogLT4gaGl0IGJhY2tzcGFjZSAtPiAxfDM0KlxuXG4gICAgICAgICAgdmFyIHBvc3REZWxpbWl0ZXJBZnRlciA9IFV0aWwuZ2V0UG9zdERlbGltaXRlcih2YWx1ZSwgcHBzLmRlbGltaXRlciwgcHBzLmRlbGltaXRlcnMpO1xuXG4gICAgICAgICAgaWYgKCFmcm9tUHJvcHMgJiYgIXBwcy5udW1lcmFsICYmIHBwcy5wb3N0RGVsaW1pdGVyQmFja3NwYWNlICYmICFwb3N0RGVsaW1pdGVyQWZ0ZXIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gVXRpbC5oZWFkU3RyKHZhbHVlLCB2YWx1ZS5sZW5ndGggLSBwcHMucG9zdERlbGltaXRlckJhY2tzcGFjZS5sZW5ndGgpO1xuICAgICAgICAgIH0gLy8gcGhvbmUgZm9ybWF0dGVyXG5cblxuICAgICAgICAgIGlmIChwcHMucGhvbmUpIHtcbiAgICAgICAgICAgIGlmIChwcHMucHJlZml4ICYmICghcHBzLm5vSW1tZWRpYXRlUHJlZml4IHx8IHZhbHVlLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgcHBzLnJlc3VsdCA9IHBwcy5wcmVmaXggKyBwcHMucGhvbmVGb3JtYXR0ZXIuZm9ybWF0KHZhbHVlKS5zbGljZShwcHMucHJlZml4Lmxlbmd0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwcHMucmVzdWx0ID0gcHBzLnBob25lRm9ybWF0dGVyLmZvcm1hdCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG93bmVyLnVwZGF0ZVZhbHVlU3RhdGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IC8vIG51bWVyYWwgZm9ybWF0dGVyXG5cblxuICAgICAgICAgIGlmIChwcHMubnVtZXJhbCkge1xuICAgICAgICAgICAgLy8gRG8gbm90IHNob3cgcHJlZml4IHdoZW4gbm9JbW1lZGlhdGVQcmVmaXggaXMgc3BlY2lmaWVkXG4gICAgICAgICAgICAvLyBUaGlzIG1vc3RseSBiZWNhdXNlIHdlIG5lZWQgdG8gc2hvdyB1c2VyIHRoZSBuYXRpdmUgaW5wdXQgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgIGlmIChwcHMucHJlZml4ICYmIHBwcy5ub0ltbWVkaWF0ZVByZWZpeCAmJiB2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgcHBzLnJlc3VsdCA9ICcnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcHBzLnJlc3VsdCA9IHBwcy5udW1lcmFsRm9ybWF0dGVyLmZvcm1hdCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG93bmVyLnVwZGF0ZVZhbHVlU3RhdGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IC8vIGRhdGVcblxuXG4gICAgICAgICAgaWYgKHBwcy5kYXRlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHBwcy5kYXRlRm9ybWF0dGVyLmdldFZhbGlkYXRlZERhdGUodmFsdWUpO1xuICAgICAgICAgIH0gLy8gdGltZVxuXG5cbiAgICAgICAgICBpZiAocHBzLnRpbWUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gcHBzLnRpbWVGb3JtYXR0ZXIuZ2V0VmFsaWRhdGVkVGltZSh2YWx1ZSk7XG4gICAgICAgICAgfSAvLyBzdHJpcCBkZWxpbWl0ZXJzXG5cblxuICAgICAgICAgIHZhbHVlID0gVXRpbC5zdHJpcERlbGltaXRlcnModmFsdWUsIHBwcy5kZWxpbWl0ZXIsIHBwcy5kZWxpbWl0ZXJzKTsgLy8gc3RyaXAgcHJlZml4XG5cbiAgICAgICAgICB2YWx1ZSA9IFV0aWwuZ2V0UHJlZml4U3RyaXBwZWRWYWx1ZSh2YWx1ZSwgcHBzLnByZWZpeCwgcHBzLnByZWZpeExlbmd0aCwgcHBzLnJlc3VsdCwgcHBzLmRlbGltaXRlciwgcHBzLmRlbGltaXRlcnMsIHBwcy5ub0ltbWVkaWF0ZVByZWZpeCwgcHBzLnRhaWxQcmVmaXgsIHBwcy5zaWduQmVmb3JlUHJlZml4KTsgLy8gc3RyaXAgbm9uLW51bWVyaWMgY2hhcmFjdGVyc1xuXG4gICAgICAgICAgdmFsdWUgPSBwcHMubnVtZXJpY09ubHkgPyBVdGlsLnN0cmlwKHZhbHVlLCAvW15cXGRdL2cpIDogdmFsdWU7IC8vIGNvbnZlcnQgY2FzZVxuXG4gICAgICAgICAgdmFsdWUgPSBwcHMudXBwZXJjYXNlID8gdmFsdWUudG9VcHBlckNhc2UoKSA6IHZhbHVlO1xuICAgICAgICAgIHZhbHVlID0gcHBzLmxvd2VyY2FzZSA/IHZhbHVlLnRvTG93ZXJDYXNlKCkgOiB2YWx1ZTsgLy8gcHJldmVudCBmcm9tIHNob3dpbmcgcHJlZml4IHdoZW4gbm8gaW1tZWRpYXRlIG9wdGlvbiBlbmFibGVkIHdpdGggZW1wdHkgaW5wdXQgdmFsdWVcblxuICAgICAgICAgIGlmIChwcHMucHJlZml4KSB7XG4gICAgICAgICAgICBpZiAocHBzLnRhaWxQcmVmaXgpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSArIHBwcy5wcmVmaXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YWx1ZSA9IHBwcy5wcmVmaXggKyB2YWx1ZTtcbiAgICAgICAgICAgIH0gLy8gbm8gYmxvY2tzIHNwZWNpZmllZCwgbm8gbmVlZCB0byBkbyBmb3JtYXR0aW5nXG5cblxuICAgICAgICAgICAgaWYgKHBwcy5ibG9ja3NMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgcHBzLnJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgICAgICBvd25lci51cGRhdGVWYWx1ZVN0YXRlKCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIHVwZGF0ZSBjcmVkaXQgY2FyZCBwcm9wc1xuXG5cbiAgICAgICAgICBpZiAocHBzLmNyZWRpdENhcmQpIHtcbiAgICAgICAgICAgIG93bmVyLnVwZGF0ZUNyZWRpdENhcmRQcm9wc0J5VmFsdWUodmFsdWUpO1xuICAgICAgICAgIH0gLy8gc3RyaXAgb3ZlciBsZW5ndGggY2hhcmFjdGVyc1xuXG5cbiAgICAgICAgICB2YWx1ZSA9IHBwcy5tYXhMZW5ndGggPiAwID8gVXRpbC5oZWFkU3RyKHZhbHVlLCBwcHMubWF4TGVuZ3RoKSA6IHZhbHVlOyAvLyBhcHBseSBibG9ja3NcblxuICAgICAgICAgIHBwcy5yZXN1bHQgPSBVdGlsLmdldEZvcm1hdHRlZFZhbHVlKHZhbHVlLCBwcHMuYmxvY2tzLCBwcHMuYmxvY2tzTGVuZ3RoLCBwcHMuZGVsaW1pdGVyLCBwcHMuZGVsaW1pdGVycywgcHBzLmRlbGltaXRlckxhenlTaG93KTtcbiAgICAgICAgICBvd25lci51cGRhdGVWYWx1ZVN0YXRlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZUNyZWRpdENhcmRQcm9wc0J5VmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUNyZWRpdENhcmRQcm9wc0J5VmFsdWUodmFsdWUpIHtcbiAgICAgICAgICB2YXIgb3duZXIgPSB0aGlzLFxuICAgICAgICAgICAgICBwcHMgPSBvd25lci5wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICBjcmVkaXRDYXJkSW5mbzsgLy8gQXQgbGVhc3Qgb25lIG9mIHRoZSBmaXJzdCA0IGNoYXJhY3RlcnMgaGFzIGNoYW5nZWRcblxuICAgICAgICAgIGlmIChVdGlsLmhlYWRTdHIocHBzLnJlc3VsdCwgNCkgPT09IFV0aWwuaGVhZFN0cih2YWx1ZSwgNCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjcmVkaXRDYXJkSW5mbyA9IENyZWRpdENhcmREZXRlY3Rvci5nZXRJbmZvKHZhbHVlLCBwcHMuY3JlZGl0Q2FyZFN0cmljdE1vZGUpO1xuICAgICAgICAgIHBwcy5ibG9ja3MgPSBjcmVkaXRDYXJkSW5mby5ibG9ja3M7XG4gICAgICAgICAgcHBzLmJsb2Nrc0xlbmd0aCA9IHBwcy5ibG9ja3MubGVuZ3RoO1xuICAgICAgICAgIHBwcy5tYXhMZW5ndGggPSBVdGlsLmdldE1heExlbmd0aChwcHMuYmxvY2tzKTsgLy8gY3JlZGl0IGNhcmQgdHlwZSBjaGFuZ2VkXG5cbiAgICAgICAgICBpZiAocHBzLmNyZWRpdENhcmRUeXBlICE9PSBjcmVkaXRDYXJkSW5mby50eXBlKSB7XG4gICAgICAgICAgICBwcHMuY3JlZGl0Q2FyZFR5cGUgPSBjcmVkaXRDYXJkSW5mby50eXBlO1xuICAgICAgICAgICAgcHBzLm9uQ3JlZGl0Q2FyZFR5cGVDaGFuZ2VkLmNhbGwob3duZXIsIHBwcy5jcmVkaXRDYXJkVHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1cGRhdGVWYWx1ZVN0YXRlOiBmdW5jdGlvbiB1cGRhdGVWYWx1ZVN0YXRlKCkge1xuICAgICAgICAgIHZhciBvd25lciA9IHRoaXMsXG4gICAgICAgICAgICAgIHBwcyA9IG93bmVyLnByb3BlcnRpZXM7XG5cbiAgICAgICAgICBpZiAoIW93bmVyLmVsZW1lbnQpIHtcbiAgICAgICAgICAgIG93bmVyLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgdmFsdWU6IHBwcy5yZXN1bHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBlbmRQb3MgPSBvd25lci5lbGVtZW50LnNlbGVjdGlvbkVuZDtcbiAgICAgICAgICB2YXIgb2xkVmFsdWUgPSBvd25lci5lbGVtZW50LnZhbHVlO1xuICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IHBwcy5yZXN1bHQ7XG4gICAgICAgICAgb3duZXIubGFzdElucHV0VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICBlbmRQb3MgPSBVdGlsLmdldE5leHRDdXJzb3JQb3NpdGlvbihlbmRQb3MsIG9sZFZhbHVlLCBuZXdWYWx1ZSwgcHBzLmRlbGltaXRlciwgcHBzLmRlbGltaXRlcnMpO1xuXG4gICAgICAgICAgaWYgKG93bmVyLmlzQW5kcm9pZCkge1xuICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBvd25lci5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ld1ZhbHVlLFxuICAgICAgICAgICAgICAgIGN1cnNvclBvc2l0aW9uOiBlbmRQb3NcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCAxKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvd25lci5zZXRTdGF0ZSh7XG4gICAgICAgICAgICB2YWx1ZTogbmV3VmFsdWUsXG4gICAgICAgICAgICBjdXJzb3JQb3NpdGlvbjogZW5kUG9zXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICAgIHZhciBvd25lciA9IHRoaXM7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuXG4gICAgICAgICAgdmFyIF9vd25lciRwcm9wczIgPSBvd25lci5wcm9wcyxcbiAgICAgICAgICAgICAgdmFsdWUgPSBfb3duZXIkcHJvcHMyLnZhbHVlLFxuICAgICAgICAgICAgICBvcHRpb25zID0gX293bmVyJHByb3BzMi5vcHRpb25zLFxuICAgICAgICAgICAgICBvbktleURvd24gPSBfb3duZXIkcHJvcHMyLm9uS2V5RG93bixcbiAgICAgICAgICAgICAgb25Gb2N1cyA9IF9vd25lciRwcm9wczIub25Gb2N1cyxcbiAgICAgICAgICAgICAgb25CbHVyID0gX293bmVyJHByb3BzMi5vbkJsdXIsXG4gICAgICAgICAgICAgIG9uQ2hhbmdlID0gX293bmVyJHByb3BzMi5vbkNoYW5nZSxcbiAgICAgICAgICAgICAgb25Jbml0ID0gX293bmVyJHByb3BzMi5vbkluaXQsXG4gICAgICAgICAgICAgIGh0bWxSZWYgPSBfb3duZXIkcHJvcHMyLmh0bWxSZWYsXG4gICAgICAgICAgICAgIHByb3BzVG9UcmFuc2ZlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfb3duZXIkcHJvcHMyLCBbJ3ZhbHVlJywgJ29wdGlvbnMnLCAnb25LZXlEb3duJywgJ29uRm9jdXMnLCAnb25CbHVyJywgJ29uQ2hhbmdlJywgJ29uSW5pdCcsICdodG1sUmVmJ10pO1xuXG4gICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JywgX2V4dGVuZHMoe1xuICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgcmVmOiBmdW5jdGlvbiByZWYoX3JlZikge1xuICAgICAgICAgICAgICBvd25lci5lbGVtZW50ID0gX3JlZjtcblxuICAgICAgICAgICAgICBpZiAoIWh0bWxSZWYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBodG1sUmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsdWU6IG93bmVyLnN0YXRlLnZhbHVlLFxuICAgICAgICAgICAgb25LZXlEb3duOiBvd25lci5vbktleURvd24sXG4gICAgICAgICAgICBvbkNoYW5nZTogb3duZXIub25DaGFuZ2UsXG4gICAgICAgICAgICBvbkZvY3VzOiBvd25lci5vbkZvY3VzLFxuICAgICAgICAgICAgb25CbHVyOiBvd25lci5vbkJsdXJcbiAgICAgICAgICB9LCBwcm9wc1RvVHJhbnNmZXIpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IGNsZWF2ZVJlYWN0Q2xhc3M7XG4gICAgICAvKioqL1xuICAgIH0sXG4gICAgLyogMSAqL1xuXG4gICAgLyoqKi9cbiAgICBmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMV9fO1xuICAgICAgLyoqKi9cbiAgICB9LFxuICAgIC8qIDIgKi9cblxuICAgIC8qKiovXG4gICAgZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgLyoqXG4gICAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAgICAgICAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAgICAgICAqXG4gICAgICAgKi9cbiAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgdmFyIFJlYWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuICAgICAgdmFyIGZhY3RvcnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG4gICAgICBpZiAodHlwZW9mIFJlYWN0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBFcnJvcignY3JlYXRlLXJlYWN0LWNsYXNzIGNvdWxkIG5vdCBmaW5kIHRoZSBSZWFjdCBvYmplY3QuIElmIHlvdSBhcmUgdXNpbmcgc2NyaXB0IHRhZ3MsICcgKyAnbWFrZSBzdXJlIHRoYXQgUmVhY3QgaXMgYmVpbmcgbG9hZGVkIGJlZm9yZSBjcmVhdGUtcmVhY3QtY2xhc3MuJyk7XG4gICAgICB9IC8vIEhhY2sgdG8gZ3JhYiBOb29wVXBkYXRlUXVldWUgZnJvbSBpc29tb3JwaGljIFJlYWN0XG5cblxuICAgICAgdmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0gbmV3IFJlYWN0LkNvbXBvbmVudCgpLnVwZGF0ZXI7XG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoUmVhY3QuQ29tcG9uZW50LCBSZWFjdC5pc1ZhbGlkRWxlbWVudCwgUmVhY3ROb29wVXBkYXRlUXVldWUpO1xuICAgICAgLyoqKi9cbiAgICB9LFxuICAgIC8qIDMgKi9cblxuICAgIC8qKiovXG4gICAgZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgLyoqXG4gICAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAgICAgICAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAgICAgICAqXG4gICAgICAgKi9cbiAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgdmFyIF9hc3NpZ24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG4gICAgICB2YXIgZW1wdHlPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG4gICAgICB2YXIgX2ludmFyaWFudCA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhciB3YXJuaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcbiAgICAgIH1cblxuICAgICAgdmFyIE1JWElOU19LRVkgPSAnbWl4aW5zJzsgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGFsbG93IHRoZSBjcmVhdGlvbiBvZiBhbm9ueW1vdXMgZnVuY3Rpb25zIHdoaWNoIGRvIG5vdFxuICAgICAgLy8gaGF2ZSAubmFtZSBzZXQgdG8gdGhlIG5hbWUgb2YgdGhlIHZhcmlhYmxlIGJlaW5nIGFzc2lnbmVkIHRvLlxuXG4gICAgICBmdW5jdGlvbiBpZGVudGl0eShmbikge1xuICAgICAgICByZXR1cm4gZm47XG4gICAgICB9XG5cbiAgICAgIHZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcztcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSB7XG4gICAgICAgICAgcHJvcDogJ3Byb3AnLFxuICAgICAgICAgIGNvbnRleHQ6ICdjb250ZXh0JyxcbiAgICAgICAgICBjaGlsZENvbnRleHQ6ICdjaGlsZCBjb250ZXh0J1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZmFjdG9yeShSZWFjdENvbXBvbmVudCwgaXNWYWxpZEVsZW1lbnQsIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQb2xpY2llcyB0aGF0IGRlc2NyaWJlIG1ldGhvZHMgaW4gYFJlYWN0Q2xhc3NJbnRlcmZhY2VgLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGluamVjdGVkTWl4aW5zID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wb3NpdGUgY29tcG9uZW50cyBhcmUgaGlnaGVyLWxldmVsIGNvbXBvbmVudHMgdGhhdCBjb21wb3NlIG90aGVyIGNvbXBvc2l0ZVxuICAgICAgICAgKiBvciBob3N0IGNvbXBvbmVudHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRvIGNyZWF0ZSBhIG5ldyB0eXBlIG9mIGBSZWFjdENsYXNzYCwgcGFzcyBhIHNwZWNpZmljYXRpb24gb2ZcbiAgICAgICAgICogeW91ciBuZXcgY2xhc3MgdG8gYFJlYWN0LmNyZWF0ZUNsYXNzYC4gVGhlIG9ubHkgcmVxdWlyZW1lbnQgb2YgeW91ciBjbGFzc1xuICAgICAgICAgKiBzcGVjaWZpY2F0aW9uIGlzIHRoYXQgeW91IGltcGxlbWVudCBhIGByZW5kZXJgIG1ldGhvZC5cbiAgICAgICAgICpcbiAgICAgICAgICogICB2YXIgTXlDb21wb25lbnQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAgICAgICAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgKiAgICAgICByZXR1cm4gPGRpdj5IZWxsbyBXb3JsZDwvZGl2PjtcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogICB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGNsYXNzIHNwZWNpZmljYXRpb24gc3VwcG9ydHMgYSBzcGVjaWZpYyBwcm90b2NvbCBvZiBtZXRob2RzIHRoYXQgaGF2ZVxuICAgICAgICAgKiBzcGVjaWFsIG1lYW5pbmcgKGUuZy4gYHJlbmRlcmApLiBTZWUgYFJlYWN0Q2xhc3NJbnRlcmZhY2VgIGZvclxuICAgICAgICAgKiBtb3JlIHRoZSBjb21wcmVoZW5zaXZlIHByb3RvY29sLiBBbnkgb3RoZXIgcHJvcGVydGllcyBhbmQgbWV0aG9kcyBpbiB0aGVcbiAgICAgICAgICogY2xhc3Mgc3BlY2lmaWNhdGlvbiB3aWxsIGJlIGF2YWlsYWJsZSBvbiB0aGUgcHJvdG90eXBlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW50ZXJmYWNlIFJlYWN0Q2xhc3NJbnRlcmZhY2VcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuXG4gICAgICAgIHZhciBSZWFjdENsYXNzSW50ZXJmYWNlID0ge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEFuIGFycmF5IG9mIE1peGluIG9iamVjdHMgdG8gaW5jbHVkZSB3aGVuIGRlZmluaW5nIHlvdXIgY29tcG9uZW50LlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQHR5cGUge2FycmF5fVxuICAgICAgICAgICAqIEBvcHRpb25hbFxuICAgICAgICAgICAqL1xuICAgICAgICAgIG1peGluczogJ0RFRklORV9NQU5ZJyxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEFuIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgdGhhdCBzaG91bGQgYmUgZGVmaW5lZCBvblxuICAgICAgICAgICAqIHRoZSBjb21wb25lbnQncyBjb25zdHJ1Y3RvciBpbnN0ZWFkIG9mIGl0cyBwcm90b3R5cGUgKHN0YXRpYyBtZXRob2RzKS5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAgICogQG9wdGlvbmFsXG4gICAgICAgICAgICovXG4gICAgICAgICAgc3RhdGljczogJ0RFRklORV9NQU5ZJyxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIERlZmluaXRpb24gb2YgcHJvcCB0eXBlcyBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgICAqIEBvcHRpb25hbFxuICAgICAgICAgICAqL1xuICAgICAgICAgIHByb3BUeXBlczogJ0RFRklORV9NQU5ZJyxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIERlZmluaXRpb24gb2YgY29udGV4dCB0eXBlcyBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgICAqIEBvcHRpb25hbFxuICAgICAgICAgICAqL1xuICAgICAgICAgIGNvbnRleHRUeXBlczogJ0RFRklORV9NQU5ZJyxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIERlZmluaXRpb24gb2YgY29udGV4dCB0eXBlcyB0aGlzIGNvbXBvbmVudCBzZXRzIGZvciBpdHMgY2hpbGRyZW4uXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgICAqIEBvcHRpb25hbFxuICAgICAgICAgICAqL1xuICAgICAgICAgIGNoaWxkQ29udGV4dFR5cGVzOiAnREVGSU5FX01BTlknLFxuICAgICAgICAgIC8vID09PT0gRGVmaW5pdGlvbiBtZXRob2RzID09PT1cblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuIFZhbHVlcyBpbiB0aGUgbWFwcGluZyB3aWxsIGJlIHNldCBvblxuICAgICAgICAgICAqIGB0aGlzLnByb3BzYCBpZiB0aGF0IHByb3AgaXMgbm90IHNwZWNpZmllZCAoaS5lLiB1c2luZyBhbiBgaW5gIGNoZWNrKS5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIFRoaXMgbWV0aG9kIGlzIGludm9rZWQgYmVmb3JlIGBnZXRJbml0aWFsU3RhdGVgIGFuZCB0aGVyZWZvcmUgY2Fubm90IHJlbHlcbiAgICAgICAgICAgKiBvbiBgdGhpcy5zdGF0ZWAgb3IgdXNlIGB0aGlzLnNldFN0YXRlYC5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEByZXR1cm4ge29iamVjdH1cbiAgICAgICAgICAgKiBAb3B0aW9uYWxcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBnZXREZWZhdWx0UHJvcHM6ICdERUZJTkVfTUFOWV9NRVJHRUQnLFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogSW52b2tlZCBvbmNlIGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSB1c2VkXG4gICAgICAgICAgICogYXMgdGhlIGluaXRpYWwgdmFsdWUgb2YgYHRoaXMuc3RhdGVgLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAqICAgICByZXR1cm4ge1xuICAgICAgICAgICAqICAgICAgIGlzT246IGZhbHNlLFxuICAgICAgICAgICAqICAgICAgIGZvb0JhejogbmV3IEJhekZvbygpXG4gICAgICAgICAgICogICAgIH1cbiAgICAgICAgICAgKiAgIH1cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEByZXR1cm4ge29iamVjdH1cbiAgICAgICAgICAgKiBAb3B0aW9uYWxcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBnZXRJbml0aWFsU3RhdGU6ICdERUZJTkVfTUFOWV9NRVJHRUQnLFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQHJldHVybiB7b2JqZWN0fVxuICAgICAgICAgICAqIEBvcHRpb25hbFxuICAgICAgICAgICAqL1xuICAgICAgICAgIGdldENoaWxkQ29udGV4dDogJ0RFRklORV9NQU5ZX01FUkdFRCcsXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBVc2VzIHByb3BzIGZyb20gYHRoaXMucHJvcHNgIGFuZCBzdGF0ZSBmcm9tIGB0aGlzLnN0YXRlYCB0byByZW5kZXIgdGhlXG4gICAgICAgICAgICogc3RydWN0dXJlIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBObyBndWFyYW50ZWVzIGFyZSBtYWRlIGFib3V0IHdoZW4gb3IgaG93IG9mdGVuIHRoaXMgbWV0aG9kIGlzIGludm9rZWQsIHNvXG4gICAgICAgICAgICogaXQgbXVzdCBub3QgaGF2ZSBzaWRlIGVmZmVjdHMuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICogICAgIHZhciBuYW1lID0gdGhpcy5wcm9wcy5uYW1lO1xuICAgICAgICAgICAqICAgICByZXR1cm4gPGRpdj5IZWxsbywge25hbWV9ITwvZGl2PjtcbiAgICAgICAgICAgKiAgIH1cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fVxuICAgICAgICAgICAqIEByZXF1aXJlZFxuICAgICAgICAgICAqL1xuICAgICAgICAgIHJlbmRlcjogJ0RFRklORV9PTkNFJyxcbiAgICAgICAgICAvLyA9PT09IERlbGVnYXRlIG1ldGhvZHMgPT09PVxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgaW5pdGlhbGx5IGNyZWF0ZWQgYW5kIGFib3V0IHRvIGJlIG1vdW50ZWQuXG4gICAgICAgICAgICogVGhpcyBtYXkgaGF2ZSBzaWRlIGVmZmVjdHMsIGJ1dCBhbnkgZXh0ZXJuYWwgc3Vic2NyaXB0aW9ucyBvciBkYXRhIGNyZWF0ZWRcbiAgICAgICAgICAgKiBieSB0aGlzIG1ldGhvZCBtdXN0IGJlIGNsZWFuZWQgdXAgaW4gYGNvbXBvbmVudFdpbGxVbm1vdW50YC5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBvcHRpb25hbFxuICAgICAgICAgICAqL1xuICAgICAgICAgIGNvbXBvbmVudFdpbGxNb3VudDogJ0RFRklORV9NQU5ZJyxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGhhcyBiZWVuIG1vdW50ZWQgYW5kIGhhcyBhIERPTSByZXByZXNlbnRhdGlvbi5cbiAgICAgICAgICAgKiBIb3dldmVyLCB0aGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGUgRE9NIG5vZGUgaXMgaW4gdGhlIGRvY3VtZW50LlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gb3BlcmF0ZSBvbiB0aGUgRE9NIHdoZW4gdGhlIGNvbXBvbmVudCBoYXNcbiAgICAgICAgICAgKiBiZWVuIG1vdW50ZWQgKGluaXRpYWxpemVkIGFuZCByZW5kZXJlZCkgZm9yIHRoZSBmaXJzdCB0aW1lLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQHBhcmFtIHtET01FbGVtZW50fSByb290Tm9kZSBET00gZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIGNvbXBvbmVudC5cbiAgICAgICAgICAgKiBAb3B0aW9uYWxcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBjb21wb25lbnREaWRNb3VudDogJ0RFRklORV9NQU5ZJyxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEludm9rZWQgYmVmb3JlIHRoZSBjb21wb25lbnQgcmVjZWl2ZXMgbmV3IHByb3BzLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gcmVhY3QgdG8gYSBwcm9wIHRyYW5zaXRpb24gYnkgdXBkYXRpbmcgdGhlXG4gICAgICAgICAgICogc3RhdGUgdXNpbmcgYHRoaXMuc2V0U3RhdGVgLiBDdXJyZW50IHByb3BzIGFyZSBhY2Nlc3NlZCB2aWEgYHRoaXMucHJvcHNgLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbihuZXh0UHJvcHMsIG5leHRDb250ZXh0KSB7XG4gICAgICAgICAgICogICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAqICAgICAgIGxpa2VzSW5jcmVhc2luZzogbmV4dFByb3BzLmxpa2VDb3VudCA+IHRoaXMucHJvcHMubGlrZUNvdW50XG4gICAgICAgICAgICogICAgIH0pO1xuICAgICAgICAgICAqICAgfVxuICAgICAgICAgICAqXG4gICAgICAgICAgICogTk9URTogVGhlcmUgaXMgbm8gZXF1aXZhbGVudCBgY29tcG9uZW50V2lsbFJlY2VpdmVTdGF0ZWAuIEFuIGluY29taW5nIHByb3BcbiAgICAgICAgICAgKiB0cmFuc2l0aW9uIG1heSBjYXVzZSBhIHN0YXRlIGNoYW5nZSwgYnV0IHRoZSBvcHBvc2l0ZSBpcyBub3QgdHJ1ZS4gSWYgeW91XG4gICAgICAgICAgICogbmVlZCBpdCwgeW91IGFyZSBwcm9iYWJseSBsb29raW5nIGZvciBgY29tcG9uZW50V2lsbFVwZGF0ZWAuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAgICAgICAgICogQG9wdGlvbmFsXG4gICAgICAgICAgICovXG4gICAgICAgICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogJ0RFRklORV9NQU5ZJyxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEludm9rZWQgd2hpbGUgZGVjaWRpbmcgaWYgdGhlIGNvbXBvbmVudCBzaG91bGQgYmUgdXBkYXRlZCBhcyBhIHJlc3VsdCBvZlxuICAgICAgICAgICAqIHJlY2VpdmluZyBuZXcgcHJvcHMsIHN0YXRlIGFuZC9vciBjb250ZXh0LlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gYHJldHVybiBmYWxzZWAgd2hlbiB5b3UncmUgY2VydGFpbiB0aGF0IHRoZVxuICAgICAgICAgICAqIHRyYW5zaXRpb24gdG8gdGhlIG5ldyBwcm9wcy9zdGF0ZS9jb250ZXh0IHdpbGwgbm90IHJlcXVpcmUgYSBjb21wb25lbnRcbiAgICAgICAgICAgKiB1cGRhdGUuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiAgIHNob3VsZENvbXBvbmVudFVwZGF0ZTogZnVuY3Rpb24obmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0KSB7XG4gICAgICAgICAgICogICAgIHJldHVybiAhZXF1YWwobmV4dFByb3BzLCB0aGlzLnByb3BzKSB8fFxuICAgICAgICAgICAqICAgICAgICFlcXVhbChuZXh0U3RhdGUsIHRoaXMuc3RhdGUpIHx8XG4gICAgICAgICAgICogICAgICAgIWVxdWFsKG5leHRDb250ZXh0LCB0aGlzLmNvbnRleHQpO1xuICAgICAgICAgICAqICAgfVxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgICAgICAgICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dFN0YXRlXG4gICAgICAgICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0Q29udGV4dFxuICAgICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGNvbXBvbmVudCBzaG91bGQgdXBkYXRlLlxuICAgICAgICAgICAqIEBvcHRpb25hbFxuICAgICAgICAgICAqL1xuICAgICAgICAgIHNob3VsZENvbXBvbmVudFVwZGF0ZTogJ0RFRklORV9PTkNFJyxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGFib3V0IHRvIHVwZGF0ZSBkdWUgdG8gYSB0cmFuc2l0aW9uIGZyb21cbiAgICAgICAgICAgKiBgdGhpcy5wcm9wc2AsIGB0aGlzLnN0YXRlYCBhbmQgYHRoaXMuY29udGV4dGAgdG8gYG5leHRQcm9wc2AsIGBuZXh0U3RhdGVgXG4gICAgICAgICAgICogYW5kIGBuZXh0Q29udGV4dGAuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBwZXJmb3JtIHByZXBhcmF0aW9uIGJlZm9yZSBhbiB1cGRhdGUgb2NjdXJzLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogTk9URTogWW91ICoqY2Fubm90KiogdXNlIGB0aGlzLnNldFN0YXRlKClgIGluIHRoaXMgbWV0aG9kLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgICAgICAgICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dFN0YXRlXG4gICAgICAgICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0Q29udGV4dFxuICAgICAgICAgICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICAgICAgICAgKiBAb3B0aW9uYWxcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBjb21wb25lbnRXaWxsVXBkYXRlOiAnREVGSU5FX01BTlknLFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQncyBET00gcmVwcmVzZW50YXRpb24gaGFzIGJlZW4gdXBkYXRlZC5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIG9wZXJhdGUgb24gdGhlIERPTSB3aGVuIHRoZSBjb21wb25lbnQgaGFzXG4gICAgICAgICAgICogYmVlbiB1cGRhdGVkLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IHByZXZQcm9wc1xuICAgICAgICAgICAqIEBwYXJhbSB7P29iamVjdH0gcHJldlN0YXRlXG4gICAgICAgICAgICogQHBhcmFtIHs/b2JqZWN0fSBwcmV2Q29udGV4dFxuICAgICAgICAgICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gcm9vdE5vZGUgRE9NIGVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSBjb21wb25lbnQuXG4gICAgICAgICAgICogQG9wdGlvbmFsXG4gICAgICAgICAgICovXG4gICAgICAgICAgY29tcG9uZW50RGlkVXBkYXRlOiAnREVGSU5FX01BTlknLFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgYWJvdXQgdG8gYmUgcmVtb3ZlZCBmcm9tIGl0cyBwYXJlbnQgYW5kIGhhdmVcbiAgICAgICAgICAgKiBpdHMgRE9NIHJlcHJlc2VudGF0aW9uIGRlc3Ryb3llZC5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIGRlYWxsb2NhdGUgYW55IGV4dGVybmFsIHJlc291cmNlcy5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIE5PVEU6IFRoZXJlIGlzIG5vIGBjb21wb25lbnREaWRVbm1vdW50YCBzaW5jZSB5b3VyIGNvbXBvbmVudCB3aWxsIGhhdmUgYmVlblxuICAgICAgICAgICAqIGRlc3Ryb3llZCBieSB0aGF0IHBvaW50LlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQG9wdGlvbmFsXG4gICAgICAgICAgICovXG4gICAgICAgICAgY29tcG9uZW50V2lsbFVubW91bnQ6ICdERUZJTkVfTUFOWScsXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBSZXBsYWNlbWVudCBmb3IgKGRlcHJlY2F0ZWQpIGBjb21wb25lbnRXaWxsTW91bnRgLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQG9wdGlvbmFsXG4gICAgICAgICAgICovXG4gICAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudDogJ0RFRklORV9NQU5ZJyxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFJlcGxhY2VtZW50IGZvciAoZGVwcmVjYXRlZCkgYGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNgLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQG9wdGlvbmFsXG4gICAgICAgICAgICovXG4gICAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6ICdERUZJTkVfTUFOWScsXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBSZXBsYWNlbWVudCBmb3IgKGRlcHJlY2F0ZWQpIGBjb21wb25lbnRXaWxsVXBkYXRlYC5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBvcHRpb25hbFxuICAgICAgICAgICAqL1xuICAgICAgICAgIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlOiAnREVGSU5FX01BTlknLFxuICAgICAgICAgIC8vID09PT0gQWR2YW5jZWQgbWV0aG9kcyA9PT09XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBVcGRhdGVzIHRoZSBjb21wb25lbnQncyBjdXJyZW50bHkgbW91bnRlZCBET00gcmVwcmVzZW50YXRpb24uXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBCeSBkZWZhdWx0LCB0aGlzIGltcGxlbWVudHMgUmVhY3QncyByZW5kZXJpbmcgYW5kIHJlY29uY2lsaWF0aW9uIGFsZ29yaXRobS5cbiAgICAgICAgICAgKiBTb3BoaXN0aWNhdGVkIGNsaWVudHMgbWF5IHdpc2ggdG8gb3ZlcnJpZGUgdGhpcy5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICAgKiBAb3ZlcnJpZGFibGVcbiAgICAgICAgICAgKi9cbiAgICAgICAgICB1cGRhdGVDb21wb25lbnQ6ICdPVkVSUklERV9CQVNFJ1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2ltaWxhciB0byBSZWFjdENsYXNzSW50ZXJmYWNlIGJ1dCBmb3Igc3RhdGljIG1ldGhvZHMuXG4gICAgICAgICAqL1xuXG4gICAgICAgIHZhciBSZWFjdENsYXNzU3RhdGljSW50ZXJmYWNlID0ge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRoaXMgbWV0aG9kIGlzIGludm9rZWQgYWZ0ZXIgYSBjb21wb25lbnQgaXMgaW5zdGFudGlhdGVkIGFuZCB3aGVuIGl0XG4gICAgICAgICAgICogcmVjZWl2ZXMgbmV3IHByb3BzLiBSZXR1cm4gYW4gb2JqZWN0IHRvIHVwZGF0ZSBzdGF0ZSBpbiByZXNwb25zZSB0b1xuICAgICAgICAgICAqIHByb3AgY2hhbmdlcy4gUmV0dXJuIG51bGwgdG8gaW5kaWNhdGUgbm8gY2hhbmdlIHRvIHN0YXRlLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogSWYgYW4gb2JqZWN0IGlzIHJldHVybmVkLCBpdHMga2V5cyB3aWxsIGJlIG1lcmdlZCBpbnRvIHRoZSBleGlzdGluZyBzdGF0ZS5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEByZXR1cm4ge29iamVjdCB8fCBudWxsfVxuICAgICAgICAgICAqIEBvcHRpb25hbFxuICAgICAgICAgICAqL1xuICAgICAgICAgIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wczogJ0RFRklORV9NQU5ZX01FUkdFRCdcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcHBpbmcgZnJvbSBjbGFzcyBzcGVjaWZpY2F0aW9uIGtleXMgdG8gc3BlY2lhbCBwcm9jZXNzaW5nIGZ1bmN0aW9ucy5cbiAgICAgICAgICpcbiAgICAgICAgICogQWx0aG91Z2ggdGhlc2UgYXJlIGRlY2xhcmVkIGxpa2UgaW5zdGFuY2UgcHJvcGVydGllcyBpbiB0aGUgc3BlY2lmaWNhdGlvblxuICAgICAgICAgKiB3aGVuIGRlZmluaW5nIGNsYXNzZXMgdXNpbmcgYFJlYWN0LmNyZWF0ZUNsYXNzYCwgdGhleSBhcmUgYWN0dWFsbHkgc3RhdGljXG4gICAgICAgICAqIGFuZCBhcmUgYWNjZXNzaWJsZSBvbiB0aGUgY29uc3RydWN0b3IgaW5zdGVhZCBvZiB0aGUgcHJvdG90eXBlLiBEZXNwaXRlXG4gICAgICAgICAqIGJlaW5nIHN0YXRpYywgdGhleSBtdXN0IGJlIGRlZmluZWQgb3V0c2lkZSBvZiB0aGUgXCJzdGF0aWNzXCIga2V5IHVuZGVyXG4gICAgICAgICAqIHdoaWNoIGFsbCBvdGhlciBzdGF0aWMgbWV0aG9kcyBhcmUgZGVmaW5lZC5cbiAgICAgICAgICovXG5cbiAgICAgICAgdmFyIFJFU0VSVkVEX1NQRUNfS0VZUyA9IHtcbiAgICAgICAgICBkaXNwbGF5TmFtZTogZnVuY3Rpb24gZGlzcGxheU5hbWUoQ29uc3RydWN0b3IsIF9kaXNwbGF5TmFtZSkge1xuICAgICAgICAgICAgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgPSBfZGlzcGxheU5hbWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBtaXhpbnM6IGZ1bmN0aW9uIG1peGlucyhDb25zdHJ1Y3RvciwgX21peGlucykge1xuICAgICAgICAgICAgaWYgKF9taXhpbnMpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfbWl4aW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIF9taXhpbnNbaV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjaGlsZENvbnRleHRUeXBlczogZnVuY3Rpb24gY2hpbGRDb250ZXh0VHlwZXMoQ29uc3RydWN0b3IsIF9jaGlsZENvbnRleHRUeXBlcykge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCBfY2hpbGRDb250ZXh0VHlwZXMsICdjaGlsZENvbnRleHQnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQ29uc3RydWN0b3IuY2hpbGRDb250ZXh0VHlwZXMgPSBfYXNzaWduKHt9LCBDb25zdHJ1Y3Rvci5jaGlsZENvbnRleHRUeXBlcywgX2NoaWxkQ29udGV4dFR5cGVzKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNvbnRleHRUeXBlczogZnVuY3Rpb24gY29udGV4dFR5cGVzKENvbnN0cnVjdG9yLCBfY29udGV4dFR5cGVzKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICB2YWxpZGF0ZVR5cGVEZWYoQ29uc3RydWN0b3IsIF9jb250ZXh0VHlwZXMsICdjb250ZXh0Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIENvbnN0cnVjdG9yLmNvbnRleHRUeXBlcyA9IF9hc3NpZ24oe30sIENvbnN0cnVjdG9yLmNvbnRleHRUeXBlcywgX2NvbnRleHRUeXBlcyk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFNwZWNpYWwgY2FzZSBnZXREZWZhdWx0UHJvcHMgd2hpY2ggc2hvdWxkIG1vdmUgaW50byBzdGF0aWNzIGJ1dCByZXF1aXJlc1xuICAgICAgICAgICAqIGF1dG9tYXRpYyBtZXJnaW5nLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKENvbnN0cnVjdG9yLCBfZ2V0RGVmYXVsdFByb3BzKSB7XG4gICAgICAgICAgICBpZiAoQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKSB7XG4gICAgICAgICAgICAgIENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcyA9IGNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uKENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcywgX2dldERlZmF1bHRQcm9wcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMgPSBfZ2V0RGVmYXVsdFByb3BzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcHJvcFR5cGVzOiBmdW5jdGlvbiBwcm9wVHlwZXMoQ29uc3RydWN0b3IsIF9wcm9wVHlwZXMpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgX3Byb3BUeXBlcywgJ3Byb3AnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQ29uc3RydWN0b3IucHJvcFR5cGVzID0gX2Fzc2lnbih7fSwgQ29uc3RydWN0b3IucHJvcFR5cGVzLCBfcHJvcFR5cGVzKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHN0YXRpY3M6IGZ1bmN0aW9uIHN0YXRpY3MoQ29uc3RydWN0b3IsIF9zdGF0aWNzKSB7XG4gICAgICAgICAgICBtaXhTdGF0aWNTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3RvciwgX3N0YXRpY3MpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYXV0b2JpbmQ6IGZ1bmN0aW9uIGF1dG9iaW5kKCkge31cbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZVR5cGVEZWYoQ29uc3RydWN0b3IsIHR5cGVEZWYsIGxvY2F0aW9uKSB7XG4gICAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gdHlwZURlZikge1xuICAgICAgICAgICAgaWYgKHR5cGVEZWYuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgICAgICAgIC8vIHVzZSBhIHdhcm5pbmcgaW5zdGVhZCBvZiBhbiBfaW52YXJpYW50IHNvIGNvbXBvbmVudHNcbiAgICAgICAgICAgICAgLy8gZG9uJ3Qgc2hvdyB1cCBpbiBwcm9kIGJ1dCBvbmx5IGluIF9fREVWX19cbiAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICB3YXJuaW5nKHR5cGVvZiB0eXBlRGVmW3Byb3BOYW1lXSA9PT0gJ2Z1bmN0aW9uJywgJyVzOiAlcyB0eXBlIGAlc2AgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gJyArICdSZWFjdC5Qcm9wVHlwZXMuJywgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJ1JlYWN0Q2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHByb3BOYW1lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlTWV0aG9kT3ZlcnJpZGUoaXNBbHJlYWR5RGVmaW5lZCwgbmFtZSkge1xuICAgICAgICAgIHZhciBzcGVjUG9saWN5ID0gUmVhY3RDbGFzc0ludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IFJlYWN0Q2xhc3NJbnRlcmZhY2VbbmFtZV0gOiBudWxsOyAvLyBEaXNhbGxvdyBvdmVycmlkaW5nIG9mIGJhc2UgY2xhc3MgbWV0aG9kcyB1bmxlc3MgZXhwbGljaXRseSBhbGxvd2VkLlxuXG4gICAgICAgICAgaWYgKFJlYWN0Q2xhc3NNaXhpbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgX2ludmFyaWFudChzcGVjUG9saWN5ID09PSAnT1ZFUlJJREVfQkFTRScsICdSZWFjdENsYXNzSW50ZXJmYWNlOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gb3ZlcnJpZGUgJyArICdgJXNgIGZyb20geW91ciBjbGFzcyBzcGVjaWZpY2F0aW9uLiBFbnN1cmUgdGhhdCB5b3VyIG1ldGhvZCBuYW1lcyAnICsgJ2RvIG5vdCBvdmVybGFwIHdpdGggUmVhY3QgbWV0aG9kcy4nLCBuYW1lKTtcbiAgICAgICAgICB9IC8vIERpc2FsbG93IGRlZmluaW5nIG1ldGhvZHMgbW9yZSB0aGFuIG9uY2UgdW5sZXNzIGV4cGxpY2l0bHkgYWxsb3dlZC5cblxuXG4gICAgICAgICAgaWYgKGlzQWxyZWFkeURlZmluZWQpIHtcbiAgICAgICAgICAgIF9pbnZhcmlhbnQoc3BlY1BvbGljeSA9PT0gJ0RFRklORV9NQU5ZJyB8fCBzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTllfTUVSR0VEJywgJ1JlYWN0Q2xhc3NJbnRlcmZhY2U6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBkZWZpbmUgJyArICdgJXNgIG9uIHlvdXIgY29tcG9uZW50IG1vcmUgdGhhbiBvbmNlLiBUaGlzIGNvbmZsaWN0IG1heSBiZSBkdWUgJyArICd0byBhIG1peGluLicsIG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogTWl4aW4gaGVscGVyIHdoaWNoIGhhbmRsZXMgcG9saWN5IHZhbGlkYXRpb24gYW5kIHJlc2VydmVkXG4gICAgICAgICAqIHNwZWNpZmljYXRpb24ga2V5cyB3aGVuIGJ1aWxkaW5nIFJlYWN0IGNsYXNzZXMuXG4gICAgICAgICAqL1xuXG5cbiAgICAgICAgZnVuY3Rpb24gbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHNwZWMpIHtcbiAgICAgICAgICBpZiAoIXNwZWMpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgIHZhciB0eXBlb2ZTcGVjID0gdHlwZW9mIHNwZWM7XG4gICAgICAgICAgICAgIHZhciBpc01peGluVmFsaWQgPSB0eXBlb2ZTcGVjID09PSAnb2JqZWN0JyAmJiBzcGVjICE9PSBudWxsO1xuXG4gICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgd2FybmluZyhpc01peGluVmFsaWQsIFwiJXM6IFlvdSdyZSBhdHRlbXB0aW5nIHRvIGluY2x1ZGUgYSBtaXhpbiB0aGF0IGlzIGVpdGhlciBudWxsIFwiICsgJ29yIG5vdCBhbiBvYmplY3QuIENoZWNrIHRoZSBtaXhpbnMgaW5jbHVkZWQgYnkgdGhlIGNvbXBvbmVudCwgJyArICdhcyB3ZWxsIGFzIGFueSBtaXhpbnMgdGhleSBpbmNsdWRlIHRoZW1zZWx2ZXMuICcgKyAnRXhwZWN0ZWQgb2JqZWN0IGJ1dCBnb3QgJXMuJywgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJ1JlYWN0Q2xhc3MnLCBzcGVjID09PSBudWxsID8gbnVsbCA6IHR5cGVvZlNwZWMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfaW52YXJpYW50KHR5cGVvZiBzcGVjICE9PSAnZnVuY3Rpb24nLCBcIlJlYWN0Q2xhc3M6IFlvdSdyZSBhdHRlbXB0aW5nIHRvIFwiICsgJ3VzZSBhIGNvbXBvbmVudCBjbGFzcyBvciBmdW5jdGlvbiBhcyBhIG1peGluLiBJbnN0ZWFkLCBqdXN0IHVzZSBhICcgKyAncmVndWxhciBvYmplY3QuJyk7XG5cbiAgICAgICAgICBfaW52YXJpYW50KCFpc1ZhbGlkRWxlbWVudChzcGVjKSwgXCJSZWFjdENsYXNzOiBZb3UncmUgYXR0ZW1wdGluZyB0byBcIiArICd1c2UgYSBjb21wb25lbnQgYXMgYSBtaXhpbi4gSW5zdGVhZCwganVzdCB1c2UgYSByZWd1bGFyIG9iamVjdC4nKTtcblxuICAgICAgICAgIHZhciBwcm90byA9IENvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgICAgICAgICB2YXIgYXV0b0JpbmRQYWlycyA9IHByb3RvLl9fcmVhY3RBdXRvQmluZFBhaXJzOyAvLyBCeSBoYW5kbGluZyBtaXhpbnMgYmVmb3JlIGFueSBvdGhlciBwcm9wZXJ0aWVzLCB3ZSBlbnN1cmUgdGhlIHNhbWVcbiAgICAgICAgICAvLyBjaGFpbmluZyBvcmRlciBpcyBhcHBsaWVkIHRvIG1ldGhvZHMgd2l0aCBERUZJTkVfTUFOWSBwb2xpY3ksIHdoZXRoZXJcbiAgICAgICAgICAvLyBtaXhpbnMgYXJlIGxpc3RlZCBiZWZvcmUgb3IgYWZ0ZXIgdGhlc2UgbWV0aG9kcyBpbiB0aGUgc3BlYy5cblxuICAgICAgICAgIGlmIChzcGVjLmhhc093blByb3BlcnR5KE1JWElOU19LRVkpKSB7XG4gICAgICAgICAgICBSRVNFUlZFRF9TUEVDX0tFWVMubWl4aW5zKENvbnN0cnVjdG9yLCBzcGVjLm1peGlucyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBzcGVjKSB7XG4gICAgICAgICAgICBpZiAoIXNwZWMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChuYW1lID09PSBNSVhJTlNfS0VZKSB7XG4gICAgICAgICAgICAgIC8vIFdlIGhhdmUgYWxyZWFkeSBoYW5kbGVkIG1peGlucyBpbiBhIHNwZWNpYWwgY2FzZSBhYm92ZS5cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHNwZWNbbmFtZV07XG4gICAgICAgICAgICB2YXIgaXNBbHJlYWR5RGVmaW5lZCA9IHByb3RvLmhhc093blByb3BlcnR5KG5hbWUpO1xuICAgICAgICAgICAgdmFsaWRhdGVNZXRob2RPdmVycmlkZShpc0FscmVhZHlEZWZpbmVkLCBuYW1lKTtcblxuICAgICAgICAgICAgaWYgKFJFU0VSVkVEX1NQRUNfS0VZUy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICBSRVNFUlZFRF9TUEVDX0tFWVNbbmFtZV0oQ29uc3RydWN0b3IsIHByb3BlcnR5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFNldHVwIG1ldGhvZHMgb24gcHJvdG90eXBlOlxuICAgICAgICAgICAgICAvLyBUaGUgZm9sbG93aW5nIG1lbWJlciBtZXRob2RzIHNob3VsZCBub3QgYmUgYXV0b21hdGljYWxseSBib3VuZDpcbiAgICAgICAgICAgICAgLy8gMS4gRXhwZWN0ZWQgUmVhY3RDbGFzcyBtZXRob2RzIChpbiB0aGUgXCJpbnRlcmZhY2VcIikuXG4gICAgICAgICAgICAgIC8vIDIuIE92ZXJyaWRkZW4gbWV0aG9kcyAodGhhdCB3ZXJlIG1peGVkIGluKS5cbiAgICAgICAgICAgICAgdmFyIGlzUmVhY3RDbGFzc01ldGhvZCA9IFJlYWN0Q2xhc3NJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkobmFtZSk7XG4gICAgICAgICAgICAgIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIHByb3BlcnR5ID09PSAnZnVuY3Rpb24nO1xuICAgICAgICAgICAgICB2YXIgc2hvdWxkQXV0b0JpbmQgPSBpc0Z1bmN0aW9uICYmICFpc1JlYWN0Q2xhc3NNZXRob2QgJiYgIWlzQWxyZWFkeURlZmluZWQgJiYgc3BlYy5hdXRvYmluZCAhPT0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgaWYgKHNob3VsZEF1dG9CaW5kKSB7XG4gICAgICAgICAgICAgICAgYXV0b0JpbmRQYWlycy5wdXNoKG5hbWUsIHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgICBwcm90b1tuYW1lXSA9IHByb3BlcnR5O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpc0FscmVhZHlEZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgc3BlY1BvbGljeSA9IFJlYWN0Q2xhc3NJbnRlcmZhY2VbbmFtZV07IC8vIFRoZXNlIGNhc2VzIHNob3VsZCBhbHJlYWR5IGJlIGNhdWdodCBieSB2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlLlxuXG4gICAgICAgICAgICAgICAgICBfaW52YXJpYW50KGlzUmVhY3RDbGFzc01ldGhvZCAmJiAoc3BlY1BvbGljeSA9PT0gJ0RFRklORV9NQU5ZX01FUkdFRCcgfHwgc3BlY1BvbGljeSA9PT0gJ0RFRklORV9NQU5ZJyksICdSZWFjdENsYXNzOiBVbmV4cGVjdGVkIHNwZWMgcG9saWN5ICVzIGZvciBrZXkgJXMgJyArICd3aGVuIG1peGluZyBpbiBjb21wb25lbnQgc3BlY3MuJywgc3BlY1BvbGljeSwgbmFtZSk7IC8vIEZvciBtZXRob2RzIHdoaWNoIGFyZSBkZWZpbmVkIG1vcmUgdGhhbiBvbmNlLCBjYWxsIHRoZSBleGlzdGluZ1xuICAgICAgICAgICAgICAgICAgLy8gbWV0aG9kcyBiZWZvcmUgY2FsbGluZyB0aGUgbmV3IHByb3BlcnR5LCBtZXJnaW5nIGlmIGFwcHJvcHJpYXRlLlxuXG5cbiAgICAgICAgICAgICAgICAgIGlmIChzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTllfTUVSR0VEJykge1xuICAgICAgICAgICAgICAgICAgICBwcm90b1tuYW1lXSA9IGNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uKHByb3RvW25hbWVdLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNwZWNQb2xpY3kgPT09ICdERUZJTkVfTUFOWScpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdG9bbmFtZV0gPSBjcmVhdGVDaGFpbmVkRnVuY3Rpb24ocHJvdG9bbmFtZV0sIHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcHJvdG9bbmFtZV0gPSBwcm9wZXJ0eTtcblxuICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHZlcmJvc2UgZGlzcGxheU5hbWUgdG8gdGhlIGZ1bmN0aW9uLCB3aGljaCBoZWxwcyB3aGVuIGxvb2tpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gYXQgcHJvZmlsaW5nIHRvb2xzLlxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb3BlcnR5ID09PSAnZnVuY3Rpb24nICYmIHNwZWMuZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBwcm90b1tuYW1lXS5kaXNwbGF5TmFtZSA9IHNwZWMuZGlzcGxheU5hbWUgKyAnXycgKyBuYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbWl4U3RhdGljU3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHN0YXRpY3MpIHtcbiAgICAgICAgICBpZiAoIXN0YXRpY3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIHN0YXRpY3MpIHtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHN0YXRpY3NbbmFtZV07XG5cbiAgICAgICAgICAgIGlmICghc3RhdGljcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGlzUmVzZXJ2ZWQgPSAobmFtZSBpbiBSRVNFUlZFRF9TUEVDX0tFWVMpO1xuXG4gICAgICAgICAgICBfaW52YXJpYW50KCFpc1Jlc2VydmVkLCAnUmVhY3RDbGFzczogWW91IGFyZSBhdHRlbXB0aW5nIHRvIGRlZmluZSBhIHJlc2VydmVkICcgKyAncHJvcGVydHksIGAlc2AsIHRoYXQgc2hvdWxkblxcJ3QgYmUgb24gdGhlIFwic3RhdGljc1wiIGtleS4gRGVmaW5lIGl0ICcgKyAnYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgaW5zdGVhZDsgaXQgd2lsbCBzdGlsbCBiZSBhY2Nlc3NpYmxlIG9uIHRoZSAnICsgJ2NvbnN0cnVjdG9yLicsIG5hbWUpO1xuXG4gICAgICAgICAgICB2YXIgaXNBbHJlYWR5RGVmaW5lZCA9IChuYW1lIGluIENvbnN0cnVjdG9yKTtcblxuICAgICAgICAgICAgaWYgKGlzQWxyZWFkeURlZmluZWQpIHtcbiAgICAgICAgICAgICAgdmFyIHNwZWNQb2xpY3kgPSBSZWFjdENsYXNzU3RhdGljSW50ZXJmYWNlLmhhc093blByb3BlcnR5KG5hbWUpID8gUmVhY3RDbGFzc1N0YXRpY0ludGVyZmFjZVtuYW1lXSA6IG51bGw7XG5cbiAgICAgICAgICAgICAgX2ludmFyaWFudChzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTllfTUVSR0VEJywgJ1JlYWN0Q2xhc3M6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBkZWZpbmUgJyArICdgJXNgIG9uIHlvdXIgY29tcG9uZW50IG1vcmUgdGhhbiBvbmNlLiBUaGlzIGNvbmZsaWN0IG1heSBiZSAnICsgJ2R1ZSB0byBhIG1peGluLicsIG5hbWUpO1xuXG4gICAgICAgICAgICAgIENvbnN0cnVjdG9yW25hbWVdID0gY3JlYXRlTWVyZ2VkUmVzdWx0RnVuY3Rpb24oQ29uc3RydWN0b3JbbmFtZV0sIHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBDb25zdHJ1Y3RvcltuYW1lXSA9IHByb3BlcnR5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogTWVyZ2UgdHdvIG9iamVjdHMsIGJ1dCB0aHJvdyBpZiBib3RoIGNvbnRhaW4gdGhlIHNhbWUga2V5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gb25lIFRoZSBmaXJzdCBvYmplY3QsIHdoaWNoIGlzIG11dGF0ZWQuXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0d28gVGhlIHNlY29uZCBvYmplY3RcbiAgICAgICAgICogQHJldHVybiB7b2JqZWN0fSBvbmUgYWZ0ZXIgaXQgaGFzIGJlZW4gbXV0YXRlZCB0byBjb250YWluIGV2ZXJ5dGhpbmcgaW4gdHdvLlxuICAgICAgICAgKi9cblxuXG4gICAgICAgIGZ1bmN0aW9uIG1lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMob25lLCB0d28pIHtcbiAgICAgICAgICBfaW52YXJpYW50KG9uZSAmJiB0d28gJiYgdHlwZW9mIG9uZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHR3byA9PT0gJ29iamVjdCcsICdtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKCk6IENhbm5vdCBtZXJnZSBub24tb2JqZWN0cy4nKTtcblxuICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0d28pIHtcbiAgICAgICAgICAgIGlmICh0d28uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICBfaW52YXJpYW50KG9uZVtrZXldID09PSB1bmRlZmluZWQsICdtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKCk6ICcgKyAnVHJpZWQgdG8gbWVyZ2UgdHdvIG9iamVjdHMgd2l0aCB0aGUgc2FtZSBrZXk6IGAlc2AuIFRoaXMgY29uZmxpY3QgJyArICdtYXkgYmUgZHVlIHRvIGEgbWl4aW47IGluIHBhcnRpY3VsYXIsIHRoaXMgbWF5IGJlIGNhdXNlZCBieSB0d28gJyArICdnZXRJbml0aWFsU3RhdGUoKSBvciBnZXREZWZhdWx0UHJvcHMoKSBtZXRob2RzIHJldHVybmluZyBvYmplY3RzICcgKyAnd2l0aCBjbGFzaGluZyBrZXlzLicsIGtleSk7XG5cbiAgICAgICAgICAgICAgb25lW2tleV0gPSB0d29ba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gb25lO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHR3byBmdW5jdGlvbnMgYW5kIG1lcmdlcyB0aGVpciByZXR1cm4gdmFsdWVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbmUgRnVuY3Rpb24gdG8gaW52b2tlIGZpcnN0LlxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSB0d28gRnVuY3Rpb24gdG8gaW52b2tlIHNlY29uZC5cbiAgICAgICAgICogQHJldHVybiB7ZnVuY3Rpb259IEZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgdHdvIGFyZ3VtZW50IGZ1bmN0aW9ucy5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG5cblxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbihvbmUsIHR3bykge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWRSZXN1bHQoKSB7XG4gICAgICAgICAgICB2YXIgYSA9IG9uZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgdmFyIGIgPSB0d28uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgaWYgKGEgPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYyA9IHt9O1xuICAgICAgICAgICAgbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cyhjLCBhKTtcbiAgICAgICAgICAgIG1lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoYywgYik7XG4gICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHR3byBmdW5jdGlvbnMgYW5kIGlnbm9yZXMgdGhlaXIgcmV0dXJuIHZhbGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbmUgRnVuY3Rpb24gdG8gaW52b2tlIGZpcnN0LlxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSB0d28gRnVuY3Rpb24gdG8gaW52b2tlIHNlY29uZC5cbiAgICAgICAgICogQHJldHVybiB7ZnVuY3Rpb259IEZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgdHdvIGFyZ3VtZW50IGZ1bmN0aW9ucy5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG5cblxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVDaGFpbmVkRnVuY3Rpb24ob25lLCB0d28pIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gY2hhaW5lZEZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgb25lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB0d28uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCaW5kcyBhIG1ldGhvZCB0byB0aGUgY29tcG9uZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gY29tcG9uZW50IENvbXBvbmVudCB3aG9zZSBtZXRob2QgaXMgZ29pbmcgdG8gYmUgYm91bmQuXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IG1ldGhvZCBNZXRob2QgdG8gYmUgYm91bmQuXG4gICAgICAgICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBUaGUgYm91bmQgbWV0aG9kLlxuICAgICAgICAgKi9cblxuXG4gICAgICAgIGZ1bmN0aW9uIGJpbmRBdXRvQmluZE1ldGhvZChjb21wb25lbnQsIG1ldGhvZCkge1xuICAgICAgICAgIHZhciBib3VuZE1ldGhvZCA9IG1ldGhvZC5iaW5kKGNvbXBvbmVudCk7XG5cbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQ29udGV4dCA9IGNvbXBvbmVudDtcbiAgICAgICAgICAgIGJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZE1ldGhvZCA9IG1ldGhvZDtcbiAgICAgICAgICAgIGJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZEFyZ3VtZW50cyA9IG51bGw7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudC5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZTtcbiAgICAgICAgICAgIHZhciBfYmluZCA9IGJvdW5kTWV0aG9kLmJpbmQ7XG5cbiAgICAgICAgICAgIGJvdW5kTWV0aG9kLmJpbmQgPSBmdW5jdGlvbiAobmV3VGhpcykge1xuICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgICAgfSAvLyBVc2VyIGlzIHRyeWluZyB0byBiaW5kKCkgYW4gYXV0b2JvdW5kIG1ldGhvZDsgd2UgZWZmZWN0aXZlbHkgd2lsbFxuICAgICAgICAgICAgICAvLyBpZ25vcmUgdGhlIHZhbHVlIG9mIFwidGhpc1wiIHRoYXQgdGhlIHVzZXIgaXMgdHJ5aW5nIHRvIHVzZSwgc29cbiAgICAgICAgICAgICAgLy8gbGV0J3Mgd2Fybi5cblxuXG4gICAgICAgICAgICAgIGlmIChuZXdUaGlzICE9PSBjb21wb25lbnQgJiYgbmV3VGhpcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnYmluZCgpOiBSZWFjdCBjb21wb25lbnQgbWV0aG9kcyBtYXkgb25seSBiZSBib3VuZCB0byB0aGUgJyArICdjb21wb25lbnQgaW5zdGFuY2UuIFNlZSAlcycsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmICghYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgd2FybmluZyhmYWxzZSwgJ2JpbmQoKTogWW91IGFyZSBiaW5kaW5nIGEgY29tcG9uZW50IG1ldGhvZCB0byB0aGUgY29tcG9uZW50LiAnICsgJ1JlYWN0IGRvZXMgdGhpcyBmb3IgeW91IGF1dG9tYXRpY2FsbHkgaW4gYSBoaWdoLXBlcmZvcm1hbmNlICcgKyAnd2F5LCBzbyB5b3UgY2FuIHNhZmVseSByZW1vdmUgdGhpcyBjYWxsLiBTZWUgJXMnLCBjb21wb25lbnROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gYm91bmRNZXRob2Q7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgcmVib3VuZE1ldGhvZCA9IF9iaW5kLmFwcGx5KGJvdW5kTWV0aG9kLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICAgIHJlYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQ29udGV4dCA9IGNvbXBvbmVudDtcbiAgICAgICAgICAgICAgcmVib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRNZXRob2QgPSBtZXRob2Q7XG4gICAgICAgICAgICAgIHJlYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQXJndW1lbnRzID0gYXJncztcbiAgICAgICAgICAgICAgcmV0dXJuIHJlYm91bmRNZXRob2Q7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBib3VuZE1ldGhvZDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQmluZHMgYWxsIGF1dG8tYm91bmQgbWV0aG9kcyBpbiBhIGNvbXBvbmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBvbmVudCBDb21wb25lbnQgd2hvc2UgbWV0aG9kIGlzIGdvaW5nIHRvIGJlIGJvdW5kLlxuICAgICAgICAgKi9cblxuXG4gICAgICAgIGZ1bmN0aW9uIGJpbmRBdXRvQmluZE1ldGhvZHMoY29tcG9uZW50KSB7XG4gICAgICAgICAgdmFyIHBhaXJzID0gY29tcG9uZW50Ll9fcmVhY3RBdXRvQmluZFBhaXJzO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgdmFyIGF1dG9CaW5kS2V5ID0gcGFpcnNbaV07XG4gICAgICAgICAgICB2YXIgbWV0aG9kID0gcGFpcnNbaSArIDFdO1xuICAgICAgICAgICAgY29tcG9uZW50W2F1dG9CaW5kS2V5XSA9IGJpbmRBdXRvQmluZE1ldGhvZChjb21wb25lbnQsIG1ldGhvZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIElzTW91bnRlZFByZU1peGluID0ge1xuICAgICAgICAgIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgICAgIHRoaXMuX19pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIElzTW91bnRlZFBvc3RNaXhpbiA9IHtcbiAgICAgICAgICBjb21wb25lbnRXaWxsVW5tb3VudDogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgICAgICB0aGlzLl9faXNNb3VudGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIG1vcmUgdG8gdGhlIFJlYWN0Q2xhc3MgYmFzZSBjbGFzcy4gVGhlc2UgYXJlIGFsbCBsZWdhY3kgZmVhdHVyZXMgYW5kXG4gICAgICAgICAqIHRoZXJlZm9yZSBub3QgYWxyZWFkeSBwYXJ0IG9mIHRoZSBtb2Rlcm4gUmVhY3RDb21wb25lbnQuXG4gICAgICAgICAqL1xuXG4gICAgICAgIHZhciBSZWFjdENsYXNzTWl4aW4gPSB7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogVE9ETzogVGhpcyB3aWxsIGJlIGRlcHJlY2F0ZWQgYmVjYXVzZSBzdGF0ZSBzaG91bGQgYWx3YXlzIGtlZXAgYSBjb25zaXN0ZW50XG4gICAgICAgICAgICogdHlwZSBzaWduYXR1cmUgYW5kIHRoZSBvbmx5IHVzZSBjYXNlIGZvciB0aGlzLCBpcyB0byBhdm9pZCB0aGF0LlxuICAgICAgICAgICAqL1xuICAgICAgICAgIHJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gcmVwbGFjZVN0YXRlKG5ld1N0YXRlLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVyLmVucXVldWVSZXBsYWNlU3RhdGUodGhpcywgbmV3U3RhdGUsIGNhbGxiYWNrKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICAgKiBAZmluYWxcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBpc01vdW50ZWQ6IGZ1bmN0aW9uIGlzTW91bnRlZCgpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgIHdhcm5pbmcodGhpcy5fX2RpZFdhcm5Jc01vdW50ZWQsICclczogaXNNb3VudGVkIGlzIGRlcHJlY2F0ZWQuIEluc3RlYWQsIG1ha2Ugc3VyZSB0byBjbGVhbiB1cCAnICsgJ3N1YnNjcmlwdGlvbnMgYW5kIHBlbmRpbmcgcmVxdWVzdHMgaW4gY29tcG9uZW50V2lsbFVubW91bnQgdG8gJyArICdwcmV2ZW50IG1lbW9yeSBsZWFrcy4nLCB0aGlzLmNvbnN0cnVjdG9yICYmIHRoaXMuY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgdGhpcy5uYW1lIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgICAgICAgdGhpcy5fX2RpZFdhcm5Jc01vdW50ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gISF0aGlzLl9faXNNb3VudGVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgUmVhY3RDbGFzc0NvbXBvbmVudCA9IGZ1bmN0aW9uIFJlYWN0Q2xhc3NDb21wb25lbnQoKSB7fTtcblxuICAgICAgICBfYXNzaWduKFJlYWN0Q2xhc3NDb21wb25lbnQucHJvdG90eXBlLCBSZWFjdENvbXBvbmVudC5wcm90b3R5cGUsIFJlYWN0Q2xhc3NNaXhpbik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgY29tcG9zaXRlIGNvbXBvbmVudCBjbGFzcyBnaXZlbiBhIGNsYXNzIHNwZWNpZmljYXRpb24uXG4gICAgICAgICAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jcmVhdGVjbGFzc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gc3BlYyBDbGFzcyBzcGVjaWZpY2F0aW9uICh3aGljaCBtdXN0IGRlZmluZSBgcmVuZGVyYCkuXG4gICAgICAgICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBDb21wb25lbnQgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICovXG5cblxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVDbGFzcyhzcGVjKSB7XG4gICAgICAgICAgLy8gVG8ga2VlcCBvdXIgd2FybmluZ3MgbW9yZSB1bmRlcnN0YW5kYWJsZSwgd2UnbGwgdXNlIGEgbGl0dGxlIGhhY2sgaGVyZSB0b1xuICAgICAgICAgIC8vIGVuc3VyZSB0aGF0IENvbnN0cnVjdG9yLm5hbWUgIT09ICdDb25zdHJ1Y3RvcicuIFRoaXMgbWFrZXMgc3VyZSB3ZSBkb24ndFxuICAgICAgICAgIC8vIHVubmVjZXNzYXJpbHkgaWRlbnRpZnkgYSBjbGFzcyB3aXRob3V0IGRpc3BsYXlOYW1lIGFzICdDb25zdHJ1Y3RvcicuXG4gICAgICAgICAgdmFyIENvbnN0cnVjdG9yID0gaWRlbnRpdHkoZnVuY3Rpb24gKHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGNvbnN0cnVjdG9yIGdldHMgb3ZlcnJpZGRlbiBieSBtb2Nrcy4gVGhlIGFyZ3VtZW50IGlzIHVzZWRcbiAgICAgICAgICAgIC8vIGJ5IG1vY2tzIHRvIGFzc2VydCBvbiB3aGF0IGdldHMgbW91bnRlZC5cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgIHdhcm5pbmcodGhpcyBpbnN0YW5jZW9mIENvbnN0cnVjdG9yLCAnU29tZXRoaW5nIGlzIGNhbGxpbmcgYSBSZWFjdCBjb21wb25lbnQgZGlyZWN0bHkuIFVzZSBhIGZhY3Rvcnkgb3IgJyArICdKU1ggaW5zdGVhZC4gU2VlOiBodHRwczovL2ZiLm1lL3JlYWN0LWxlZ2FjeWZhY3RvcnknKTtcbiAgICAgICAgICAgIH0gLy8gV2lyZSB1cCBhdXRvLWJpbmRpbmdcblxuXG4gICAgICAgICAgICBpZiAodGhpcy5fX3JlYWN0QXV0b0JpbmRQYWlycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgYmluZEF1dG9CaW5kTWV0aG9kcyh0aGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAgICAgICAgICAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBudWxsOyAvLyBSZWFjdENsYXNzZXMgZG9lc24ndCBoYXZlIGNvbnN0cnVjdG9ycy4gSW5zdGVhZCwgdGhleSB1c2UgdGhlXG4gICAgICAgICAgICAvLyBnZXRJbml0aWFsU3RhdGUgYW5kIGNvbXBvbmVudFdpbGxNb3VudCBtZXRob2RzIGZvciBpbml0aWFsaXphdGlvbi5cblxuICAgICAgICAgICAgdmFyIGluaXRpYWxTdGF0ZSA9IHRoaXMuZ2V0SW5pdGlhbFN0YXRlID8gdGhpcy5nZXRJbml0aWFsU3RhdGUoKSA6IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgIC8vIFdlIGFsbG93IGF1dG8tbW9ja3MgdG8gcHJvY2VlZCBhcyBpZiB0aGV5J3JlIHJldHVybmluZyBudWxsLlxuICAgICAgICAgICAgICBpZiAoaW5pdGlhbFN0YXRlID09PSB1bmRlZmluZWQgJiYgdGhpcy5nZXRJbml0aWFsU3RhdGUuX2lzTW9ja0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBwcm9iYWJseSBiYWQgcHJhY3RpY2UuIENvbnNpZGVyIHdhcm5pbmcgaGVyZSBhbmRcbiAgICAgICAgICAgICAgICAvLyBkZXByZWNhdGluZyB0aGlzIGNvbnZlbmllbmNlLlxuICAgICAgICAgICAgICAgIGluaXRpYWxTdGF0ZSA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2ludmFyaWFudCh0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShpbml0aWFsU3RhdGUpLCAnJXMuZ2V0SW5pdGlhbFN0YXRlKCk6IG11c3QgcmV0dXJuIGFuIG9iamVjdCBvciBudWxsJywgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50Jyk7XG5cbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gbmV3IFJlYWN0Q2xhc3NDb21wb25lbnQoKTtcbiAgICAgICAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvcjtcbiAgICAgICAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuX19yZWFjdEF1dG9CaW5kUGFpcnMgPSBbXTtcbiAgICAgICAgICBpbmplY3RlZE1peGlucy5mb3JFYWNoKG1peFNwZWNJbnRvQ29tcG9uZW50LmJpbmQobnVsbCwgQ29uc3RydWN0b3IpKTtcbiAgICAgICAgICBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3RvciwgSXNNb3VudGVkUHJlTWl4aW4pO1xuICAgICAgICAgIG1peFNwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzcGVjKTtcbiAgICAgICAgICBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3RvciwgSXNNb3VudGVkUG9zdE1peGluKTsgLy8gSW5pdGlhbGl6ZSB0aGUgZGVmYXVsdFByb3BzIHByb3BlcnR5IGFmdGVyIGFsbCBtaXhpbnMgaGF2ZSBiZWVuIG1lcmdlZC5cblxuICAgICAgICAgIGlmIChDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgICAgIENvbnN0cnVjdG9yLmRlZmF1bHRQcm9wcyA9IENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcygpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgdGFnIHRvIGluZGljYXRlIHRoYXQgdGhlIHVzZSBvZiB0aGVzZSBtZXRob2QgbmFtZXMgaXMgb2ssXG4gICAgICAgICAgICAvLyBzaW5jZSBpdCdzIHVzZWQgd2l0aCBjcmVhdGVDbGFzcy4gSWYgaXQncyBub3QsIHRoZW4gaXQncyBsaWtlbHkgYVxuICAgICAgICAgICAgLy8gbWlzdGFrZSBzbyB3ZSdsbCB3YXJuIHlvdSB0byB1c2UgdGhlIHN0YXRpYyBwcm9wZXJ0eSwgcHJvcGVydHlcbiAgICAgICAgICAgIC8vIGluaXRpYWxpemVyIG9yIGNvbnN0cnVjdG9yIHJlc3BlY3RpdmVseS5cbiAgICAgICAgICAgIGlmIChDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgICAgICAgQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChDb25zdHJ1Y3Rvci5wcm90b3R5cGUuZ2V0SW5pdGlhbFN0YXRlKSB7XG4gICAgICAgICAgICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5nZXRJbml0aWFsU3RhdGUuaXNSZWFjdENsYXNzQXBwcm92ZWQgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfaW52YXJpYW50KENvbnN0cnVjdG9yLnByb3RvdHlwZS5yZW5kZXIsICdjcmVhdGVDbGFzcyguLi4pOiBDbGFzcyBzcGVjaWZpY2F0aW9uIG11c3QgaW1wbGVtZW50IGEgYHJlbmRlcmAgbWV0aG9kLicpO1xuXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIHdhcm5pbmcoIUNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb21wb25lbnRTaG91bGRVcGRhdGUsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50U2hvdWxkVXBkYXRlKCkuIERpZCB5b3UgbWVhbiBzaG91bGRDb21wb25lbnRVcGRhdGUoKT8gJyArICdUaGUgbmFtZSBpcyBwaHJhc2VkIGFzIGEgcXVlc3Rpb24gYmVjYXVzZSB0aGUgZnVuY3Rpb24gaXMgJyArICdleHBlY3RlZCB0byByZXR1cm4gYSB2YWx1ZS4nLCBzcGVjLmRpc3BsYXlOYW1lIHx8ICdBIGNvbXBvbmVudCcpO1xuICAgICAgICAgICAgd2FybmluZyghQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsIHNwZWMuZGlzcGxheU5hbWUgfHwgJ0EgY29tcG9uZW50Jyk7XG4gICAgICAgICAgICB3YXJuaW5nKCFDb25zdHJ1Y3Rvci5wcm90b3R5cGUuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuICcgKyAnRGlkIHlvdSBtZWFuIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/Jywgc3BlYy5kaXNwbGF5TmFtZSB8fCAnQSBjb21wb25lbnQnKTtcbiAgICAgICAgICB9IC8vIFJlZHVjZSB0aW1lIHNwZW50IGRvaW5nIGxvb2t1cHMgYnkgc2V0dGluZyB0aGVzZSBvbiB0aGUgcHJvdG90eXBlLlxuXG5cbiAgICAgICAgICBmb3IgKHZhciBtZXRob2ROYW1lIGluIFJlYWN0Q2xhc3NJbnRlcmZhY2UpIHtcbiAgICAgICAgICAgIGlmICghQ29uc3RydWN0b3IucHJvdG90eXBlW21ldGhvZE5hbWVdKSB7XG4gICAgICAgICAgICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNsYXNzO1xuICAgICAgfVxuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3Rvcnk7XG4gICAgICAvKioqL1xuICAgIH0sXG4gICAgLyogNCAqL1xuXG4gICAgLyoqKi9cbiAgICBmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAvKlxuICAgICAgb2JqZWN0LWFzc2lnblxuICAgICAgKGMpIFNpbmRyZSBTb3JodXNcbiAgICAgIEBsaWNlbnNlIE1JVFxuICAgICAgKi9cbiAgICAgICd1c2Ugc3RyaWN0JztcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5cbiAgICAgIHZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuICAgICAgdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgICAgIHZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuICAgICAgZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG4gICAgICAgIGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE9iamVjdCh2YWwpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFPYmplY3QuYXNzaWduKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSAvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG4gICAgICAgICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXG5cbiAgICAgICAgICB2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblxuICAgICAgICAgIHRlc3QxWzVdID0gJ2RlJztcblxuICAgICAgICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0gLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXG5cbiAgICAgICAgICB2YXIgdGVzdDIgPSB7fTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICAgICAgdGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGVzdDJbbl07XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9IC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblxuXG4gICAgICAgICAgdmFyIHRlc3QzID0ge307XG4gICAgICAgICAgJ2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG4gICAgICAgICAgICB0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgLy8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgICAgdmFyIGZyb207XG4gICAgICAgIHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG4gICAgICAgIHZhciBzeW1ib2xzO1xuXG4gICAgICAgIGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG4gICAgICAgICAgZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIGZyb20pIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcbiAgICAgICAgICAgICAgdG9ba2V5XSA9IGZyb21ba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICAgICAgICBzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuICAgICAgICAgICAgICAgIHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0bztcbiAgICAgIH07XG4gICAgICAvKioqL1xuICAgIH0sXG4gICAgLyogNSAqL1xuXG4gICAgLyoqKi9cbiAgICBmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAvKipcbiAgICAgICAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICAgICAgICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICAgICAgICpcbiAgICAgICAqL1xuICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICB2YXIgZW1wdHlPYmplY3QgPSB7fTtcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZShlbXB0eU9iamVjdCk7XG4gICAgICB9XG5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gZW1wdHlPYmplY3Q7XG4gICAgICAvKioqL1xuICAgIH0sXG4gICAgLyogNiAqL1xuXG4gICAgLyoqKi9cbiAgICBmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAvKipcbiAgICAgICAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICAgICAgICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICAgICAgICpcbiAgICAgICAqL1xuICAgICAgJ3VzZSBzdHJpY3QnO1xuICAgICAgLyoqXG4gICAgICAgKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gICAgICAgKlxuICAgICAgICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAgICAgICAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICAgICAgICogZXhwZWN0aW5nLlxuICAgICAgICpcbiAgICAgICAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gICAgICAgKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gICAgICAgKi9cblxuICAgICAgdmFyIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoZm9ybWF0KSB7fTtcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xuICAgICAgICB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpO1xuXG4gICAgICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgICAgdmFyIGVycm9yO1xuXG4gICAgICAgICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcignTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLicpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgICAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuXG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7XG4gICAgICAvKioqL1xuICAgIH0sXG4gICAgLyogNyAqL1xuXG4gICAgLyoqKi9cbiAgICBmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAvKipcbiAgICAgICAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICAgICAgICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICAgICAgICpcbiAgICAgICAqL1xuICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICB2YXIgZW1wdHlGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG4gICAgICAvKipcbiAgICAgICAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAgICAgICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAgICAgICAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gICAgICAgKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAgICAgICAqL1xuXG5cbiAgICAgIHZhciB3YXJuaW5nID0gZW1wdHlGdW5jdGlvbjtcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uIHByaW50V2FybmluZyhmb3JtYXQpIHtcbiAgICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICAgICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgICAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfTtcblxuICAgICAgICB3YXJuaW5nID0gZnVuY3Rpb24gd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCkge1xuICAgICAgICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ0ZhaWxlZCBDb21wb3NpdGUgcHJvcFR5cGU6ICcpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIElnbm9yZSBDb21wb3NpdGVDb21wb25lbnQgcHJvcHR5cGUgY2hlY2suXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yID4gMiA/IF9sZW4yIC0gMiA6IDApLCBfa2V5MiA9IDI7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJpbnRXYXJuaW5nLmFwcGx5KHVuZGVmaW5lZCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gd2FybmluZztcbiAgICAgIC8qKiovXG4gICAgfSxcbiAgICAvKiA4ICovXG5cbiAgICAvKioqL1xuICAgIGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgLyoqXG4gICAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAgICAgICAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAgICAgICAqXG4gICAgICAgKiBcbiAgICAgICAqL1xuXG4gICAgICBmdW5jdGlvbiBtYWtlRW1wdHlGdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYW5kIGRpc2NhcmRzIGlucHV0czsgaXQgaGFzIG5vIHNpZGUgZWZmZWN0cy4gVGhpcyBpc1xuICAgICAgICogcHJpbWFyaWx5IHVzZWZ1bCBpZGlvbWF0aWNhbGx5IGZvciBvdmVycmlkYWJsZSBmdW5jdGlvbiBlbmRwb2ludHMgd2hpY2hcbiAgICAgICAqIGFsd2F5cyBuZWVkIHRvIGJlIGNhbGxhYmxlLCBzaW5jZSBKUyBsYWNrcyBhIG51bGwtY2FsbCBpZGlvbSBhbGEgQ29jb2EuXG4gICAgICAgKi9cblxuXG4gICAgICB2YXIgZW1wdHlGdW5jdGlvbiA9IGZ1bmN0aW9uIGVtcHR5RnVuY3Rpb24oKSB7fTtcblxuICAgICAgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJucyA9IG1ha2VFbXB0eUZ1bmN0aW9uO1xuICAgICAgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlID0gbWFrZUVtcHR5RnVuY3Rpb24oZmFsc2UpO1xuICAgICAgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWUgPSBtYWtlRW1wdHlGdW5jdGlvbih0cnVlKTtcbiAgICAgIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsID0gbWFrZUVtcHR5RnVuY3Rpb24obnVsbCk7XG5cbiAgICAgIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUaGlzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG5cbiAgICAgIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgcmV0dXJuIGFyZztcbiAgICAgIH07XG5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gZW1wdHlGdW5jdGlvbjtcbiAgICAgIC8qKiovXG4gICAgfSxcbiAgICAvKiA5ICovXG5cbiAgICAvKioqL1xuICAgIGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgdmFyIE51bWVyYWxGb3JtYXR0ZXIgPSBmdW5jdGlvbiBOdW1lcmFsRm9ybWF0dGVyKG51bWVyYWxEZWNpbWFsTWFyaywgbnVtZXJhbEludGVnZXJTY2FsZSwgbnVtZXJhbERlY2ltYWxTY2FsZSwgbnVtZXJhbFRob3VzYW5kc0dyb3VwU3R5bGUsIG51bWVyYWxQb3NpdGl2ZU9ubHksIHN0cmlwTGVhZGluZ1plcm9lcywgcHJlZml4LCBzaWduQmVmb3JlUHJlZml4LCB0YWlsUHJlZml4LCBkZWxpbWl0ZXIpIHtcbiAgICAgICAgdmFyIG93bmVyID0gdGhpcztcbiAgICAgICAgb3duZXIubnVtZXJhbERlY2ltYWxNYXJrID0gbnVtZXJhbERlY2ltYWxNYXJrIHx8ICcuJztcbiAgICAgICAgb3duZXIubnVtZXJhbEludGVnZXJTY2FsZSA9IG51bWVyYWxJbnRlZ2VyU2NhbGUgPiAwID8gbnVtZXJhbEludGVnZXJTY2FsZSA6IDA7XG4gICAgICAgIG93bmVyLm51bWVyYWxEZWNpbWFsU2NhbGUgPSBudW1lcmFsRGVjaW1hbFNjYWxlID49IDAgPyBudW1lcmFsRGVjaW1hbFNjYWxlIDogMjtcbiAgICAgICAgb3duZXIubnVtZXJhbFRob3VzYW5kc0dyb3VwU3R5bGUgPSBudW1lcmFsVGhvdXNhbmRzR3JvdXBTdHlsZSB8fCBOdW1lcmFsRm9ybWF0dGVyLmdyb3VwU3R5bGUudGhvdXNhbmQ7XG4gICAgICAgIG93bmVyLm51bWVyYWxQb3NpdGl2ZU9ubHkgPSAhIW51bWVyYWxQb3NpdGl2ZU9ubHk7XG4gICAgICAgIG93bmVyLnN0cmlwTGVhZGluZ1plcm9lcyA9IHN0cmlwTGVhZGluZ1plcm9lcyAhPT0gZmFsc2U7XG4gICAgICAgIG93bmVyLnByZWZpeCA9IHByZWZpeCB8fCBwcmVmaXggPT09ICcnID8gcHJlZml4IDogJyc7XG4gICAgICAgIG93bmVyLnNpZ25CZWZvcmVQcmVmaXggPSAhIXNpZ25CZWZvcmVQcmVmaXg7XG4gICAgICAgIG93bmVyLnRhaWxQcmVmaXggPSAhIXRhaWxQcmVmaXg7XG4gICAgICAgIG93bmVyLmRlbGltaXRlciA9IGRlbGltaXRlciB8fCBkZWxpbWl0ZXIgPT09ICcnID8gZGVsaW1pdGVyIDogJywnO1xuICAgICAgICBvd25lci5kZWxpbWl0ZXJSRSA9IGRlbGltaXRlciA/IG5ldyBSZWdFeHAoJ1xcXFwnICsgZGVsaW1pdGVyLCAnZycpIDogJyc7XG4gICAgICB9O1xuXG4gICAgICBOdW1lcmFsRm9ybWF0dGVyLmdyb3VwU3R5bGUgPSB7XG4gICAgICAgIHRob3VzYW5kOiAndGhvdXNhbmQnLFxuICAgICAgICBsYWtoOiAnbGFraCcsXG4gICAgICAgIHdhbjogJ3dhbicsXG4gICAgICAgIG5vbmU6ICdub25lJ1xuICAgICAgfTtcbiAgICAgIE51bWVyYWxGb3JtYXR0ZXIucHJvdG90eXBlID0ge1xuICAgICAgICBnZXRSYXdWYWx1ZTogZnVuY3Rpb24gZ2V0UmF3VmFsdWUodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUucmVwbGFjZSh0aGlzLmRlbGltaXRlclJFLCAnJykucmVwbGFjZSh0aGlzLm51bWVyYWxEZWNpbWFsTWFyaywgJy4nKTtcbiAgICAgICAgfSxcbiAgICAgICAgZm9ybWF0OiBmdW5jdGlvbiBmb3JtYXQodmFsdWUpIHtcbiAgICAgICAgICB2YXIgb3duZXIgPSB0aGlzLFxuICAgICAgICAgICAgICBwYXJ0cyxcbiAgICAgICAgICAgICAgcGFydFNpZ24sXG4gICAgICAgICAgICAgIHBhcnRTaWduQW5kUHJlZml4LFxuICAgICAgICAgICAgICBwYXJ0SW50ZWdlcixcbiAgICAgICAgICAgICAgcGFydERlY2ltYWwgPSAnJzsgLy8gc3RyaXAgYWxwaGFiZXQgbGV0dGVyc1xuXG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bQS1aYS16XS9nLCAnJykgLy8gcmVwbGFjZSB0aGUgZmlyc3QgZGVjaW1hbCBtYXJrIHdpdGggcmVzZXJ2ZWQgcGxhY2Vob2xkZXJcbiAgICAgICAgICAucmVwbGFjZShvd25lci5udW1lcmFsRGVjaW1hbE1hcmssICdNJykgLy8gc3RyaXAgbm9uIG51bWVyaWMgbGV0dGVycyBleGNlcHQgbWludXMgYW5kIFwiTVwiXG4gICAgICAgICAgLy8gdGhpcyBpcyB0byBlbnN1cmUgcHJlZml4IGhhcyBiZWVuIHN0cmlwcGVkXG4gICAgICAgICAgLnJlcGxhY2UoL1teXFxkTS1dL2csICcnKSAvLyByZXBsYWNlIHRoZSBsZWFkaW5nIG1pbnVzIHdpdGggcmVzZXJ2ZWQgcGxhY2Vob2xkZXJcbiAgICAgICAgICAucmVwbGFjZSgvXlxcLS8sICdOJykgLy8gc3RyaXAgdGhlIG90aGVyIG1pbnVzIHNpZ24gKGlmIHByZXNlbnQpXG4gICAgICAgICAgLnJlcGxhY2UoL1xcLS9nLCAnJykgLy8gcmVwbGFjZSB0aGUgbWludXMgc2lnbiAoaWYgcHJlc2VudClcbiAgICAgICAgICAucmVwbGFjZSgnTicsIG93bmVyLm51bWVyYWxQb3NpdGl2ZU9ubHkgPyAnJyA6ICctJykgLy8gcmVwbGFjZSBkZWNpbWFsIG1hcmtcbiAgICAgICAgICAucmVwbGFjZSgnTScsIG93bmVyLm51bWVyYWxEZWNpbWFsTWFyayk7IC8vIHN0cmlwIGFueSBsZWFkaW5nIHplcm9zXG5cbiAgICAgICAgICBpZiAob3duZXIuc3RyaXBMZWFkaW5nWmVyb2VzKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL14oLSk/MCsoPz1cXGQpLywgJyQxJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGFydFNpZ24gPSB2YWx1ZS5zbGljZSgwLCAxKSA9PT0gJy0nID8gJy0nIDogJyc7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIG93bmVyLnByZWZpeCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaWYgKG93bmVyLnNpZ25CZWZvcmVQcmVmaXgpIHtcbiAgICAgICAgICAgICAgcGFydFNpZ25BbmRQcmVmaXggPSBwYXJ0U2lnbiArIG93bmVyLnByZWZpeDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBhcnRTaWduQW5kUHJlZml4ID0gb3duZXIucHJlZml4ICsgcGFydFNpZ247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnRTaWduQW5kUHJlZml4ID0gcGFydFNpZ247XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGFydEludGVnZXIgPSB2YWx1ZTtcblxuICAgICAgICAgIGlmICh2YWx1ZS5pbmRleE9mKG93bmVyLm51bWVyYWxEZWNpbWFsTWFyaykgPj0gMCkge1xuICAgICAgICAgICAgcGFydHMgPSB2YWx1ZS5zcGxpdChvd25lci5udW1lcmFsRGVjaW1hbE1hcmspO1xuICAgICAgICAgICAgcGFydEludGVnZXIgPSBwYXJ0c1swXTtcbiAgICAgICAgICAgIHBhcnREZWNpbWFsID0gb3duZXIubnVtZXJhbERlY2ltYWxNYXJrICsgcGFydHNbMV0uc2xpY2UoMCwgb3duZXIubnVtZXJhbERlY2ltYWxTY2FsZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHBhcnRTaWduID09PSAnLScpIHtcbiAgICAgICAgICAgIHBhcnRJbnRlZ2VyID0gcGFydEludGVnZXIuc2xpY2UoMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG93bmVyLm51bWVyYWxJbnRlZ2VyU2NhbGUgPiAwKSB7XG4gICAgICAgICAgICBwYXJ0SW50ZWdlciA9IHBhcnRJbnRlZ2VyLnNsaWNlKDAsIG93bmVyLm51bWVyYWxJbnRlZ2VyU2NhbGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN3aXRjaCAob3duZXIubnVtZXJhbFRob3VzYW5kc0dyb3VwU3R5bGUpIHtcbiAgICAgICAgICAgIGNhc2UgTnVtZXJhbEZvcm1hdHRlci5ncm91cFN0eWxlLmxha2g6XG4gICAgICAgICAgICAgIHBhcnRJbnRlZ2VyID0gcGFydEludGVnZXIucmVwbGFjZSgvKFxcZCkoPz0oXFxkXFxkKStcXGQkKS9nLCAnJDEnICsgb3duZXIuZGVsaW1pdGVyKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgTnVtZXJhbEZvcm1hdHRlci5ncm91cFN0eWxlLndhbjpcbiAgICAgICAgICAgICAgcGFydEludGVnZXIgPSBwYXJ0SW50ZWdlci5yZXBsYWNlKC8oXFxkKSg/PShcXGR7NH0pKyQpL2csICckMScgKyBvd25lci5kZWxpbWl0ZXIpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBOdW1lcmFsRm9ybWF0dGVyLmdyb3VwU3R5bGUudGhvdXNhbmQ6XG4gICAgICAgICAgICAgIHBhcnRJbnRlZ2VyID0gcGFydEludGVnZXIucmVwbGFjZSgvKFxcZCkoPz0oXFxkezN9KSskKS9nLCAnJDEnICsgb3duZXIuZGVsaW1pdGVyKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG93bmVyLnRhaWxQcmVmaXgpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJ0U2lnbiArIHBhcnRJbnRlZ2VyLnRvU3RyaW5nKCkgKyAob3duZXIubnVtZXJhbERlY2ltYWxTY2FsZSA+IDAgPyBwYXJ0RGVjaW1hbC50b1N0cmluZygpIDogJycpICsgb3duZXIucHJlZml4O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBwYXJ0U2lnbkFuZFByZWZpeCArIHBhcnRJbnRlZ2VyLnRvU3RyaW5nKCkgKyAob3duZXIubnVtZXJhbERlY2ltYWxTY2FsZSA+IDAgPyBwYXJ0RGVjaW1hbC50b1N0cmluZygpIDogJycpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBOdW1lcmFsRm9ybWF0dGVyO1xuICAgICAgLyoqKi9cbiAgICB9LFxuICAgIC8qIDEwICovXG5cbiAgICAvKioqL1xuICAgIGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgdmFyIERhdGVGb3JtYXR0ZXIgPSBmdW5jdGlvbiBEYXRlRm9ybWF0dGVyKGRhdGVQYXR0ZXJuLCBkYXRlTWluLCBkYXRlTWF4KSB7XG4gICAgICAgIHZhciBvd25lciA9IHRoaXM7XG4gICAgICAgIG93bmVyLmRhdGUgPSBbXTtcbiAgICAgICAgb3duZXIuYmxvY2tzID0gW107XG4gICAgICAgIG93bmVyLmRhdGVQYXR0ZXJuID0gZGF0ZVBhdHRlcm47XG4gICAgICAgIG93bmVyLmRhdGVNaW4gPSBkYXRlTWluLnNwbGl0KCctJykucmV2ZXJzZSgpLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHJldHVybiBwYXJzZUludCh4LCAxMCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob3duZXIuZGF0ZU1pbi5sZW5ndGggPT09IDIpIG93bmVyLmRhdGVNaW4udW5zaGlmdCgwKTtcbiAgICAgICAgb3duZXIuZGF0ZU1heCA9IGRhdGVNYXguc3BsaXQoJy0nKS5yZXZlcnNlKCkubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHgsIDEwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvd25lci5kYXRlTWF4Lmxlbmd0aCA9PT0gMikgb3duZXIuZGF0ZU1heC51bnNoaWZ0KDApO1xuICAgICAgICBvd25lci5pbml0QmxvY2tzKCk7XG4gICAgICB9O1xuXG4gICAgICBEYXRlRm9ybWF0dGVyLnByb3RvdHlwZSA9IHtcbiAgICAgICAgaW5pdEJsb2NrczogZnVuY3Rpb24gaW5pdEJsb2NrcygpIHtcbiAgICAgICAgICB2YXIgb3duZXIgPSB0aGlzO1xuICAgICAgICAgIG93bmVyLmRhdGVQYXR0ZXJuLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09ICdZJykge1xuICAgICAgICAgICAgICBvd25lci5ibG9ja3MucHVzaCg0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG93bmVyLmJsb2Nrcy5wdXNoKDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBnZXRJU09Gb3JtYXREYXRlOiBmdW5jdGlvbiBnZXRJU09Gb3JtYXREYXRlKCkge1xuICAgICAgICAgIHZhciBvd25lciA9IHRoaXMsXG4gICAgICAgICAgICAgIGRhdGUgPSBvd25lci5kYXRlO1xuICAgICAgICAgIHJldHVybiBkYXRlWzJdID8gZGF0ZVsyXSArICctJyArIG93bmVyLmFkZExlYWRpbmdaZXJvKGRhdGVbMV0pICsgJy0nICsgb3duZXIuYWRkTGVhZGluZ1plcm8oZGF0ZVswXSkgOiAnJztcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0QmxvY2tzOiBmdW5jdGlvbiBnZXRCbG9ja3MoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYmxvY2tzO1xuICAgICAgICB9LFxuICAgICAgICBnZXRWYWxpZGF0ZWREYXRlOiBmdW5jdGlvbiBnZXRWYWxpZGF0ZWREYXRlKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIG93bmVyID0gdGhpcyxcbiAgICAgICAgICAgICAgcmVzdWx0ID0gJyc7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bXlxcZF0vZywgJycpO1xuICAgICAgICAgIG93bmVyLmJsb2Nrcy5mb3JFYWNoKGZ1bmN0aW9uIChsZW5ndGgsIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICB2YXIgc3ViID0gdmFsdWUuc2xpY2UoMCwgbGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgIHN1YjAgPSBzdWIuc2xpY2UoMCwgMSksXG4gICAgICAgICAgICAgICAgICByZXN0ID0gdmFsdWUuc2xpY2UobGVuZ3RoKTtcblxuICAgICAgICAgICAgICBzd2l0Y2ggKG93bmVyLmRhdGVQYXR0ZXJuW2luZGV4XSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgICAgICAgICAgaWYgKHN1YiA9PT0gJzAwJykge1xuICAgICAgICAgICAgICAgICAgICBzdWIgPSAnMDEnO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJzZUludChzdWIwLCAxMCkgPiAzKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YiA9ICcwJyArIHN1YjA7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnNlSW50KHN1YiwgMTApID4gMzEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ViID0gJzMxJztcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdtJzpcbiAgICAgICAgICAgICAgICAgIGlmIChzdWIgPT09ICcwMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ViID0gJzAxJztcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyc2VJbnQoc3ViMCwgMTApID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBzdWIgPSAnMCcgKyBzdWIwO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJzZUludChzdWIsIDEwKSA+IDEyKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YiA9ICcxMic7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmVzdWx0ICs9IHN1YjsgLy8gdXBkYXRlIHJlbWFpbmluZyBzdHJpbmdcblxuICAgICAgICAgICAgICB2YWx1ZSA9IHJlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Rml4ZWREYXRlU3RyaW5nKHJlc3VsdCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEZpeGVkRGF0ZVN0cmluZzogZnVuY3Rpb24gZ2V0Rml4ZWREYXRlU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIG93bmVyID0gdGhpcyxcbiAgICAgICAgICAgICAgZGF0ZVBhdHRlcm4gPSBvd25lci5kYXRlUGF0dGVybixcbiAgICAgICAgICAgICAgZGF0ZSA9IFtdLFxuICAgICAgICAgICAgICBkYXlJbmRleCA9IDAsXG4gICAgICAgICAgICAgIG1vbnRoSW5kZXggPSAwLFxuICAgICAgICAgICAgICB5ZWFySW5kZXggPSAwLFxuICAgICAgICAgICAgICBkYXlTdGFydEluZGV4ID0gMCxcbiAgICAgICAgICAgICAgbW9udGhTdGFydEluZGV4ID0gMCxcbiAgICAgICAgICAgICAgeWVhclN0YXJ0SW5kZXggPSAwLFxuICAgICAgICAgICAgICBkYXksXG4gICAgICAgICAgICAgIG1vbnRoLFxuICAgICAgICAgICAgICB5ZWFyLFxuICAgICAgICAgICAgICBmdWxsWWVhckRvbmUgPSBmYWxzZTsgLy8gbW0tZGQgfHwgZGQtbW1cblxuICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDQgJiYgZGF0ZVBhdHRlcm5bMF0udG9Mb3dlckNhc2UoKSAhPT0gJ3knICYmIGRhdGVQYXR0ZXJuWzFdLnRvTG93ZXJDYXNlKCkgIT09ICd5Jykge1xuICAgICAgICAgICAgZGF5U3RhcnRJbmRleCA9IGRhdGVQYXR0ZXJuWzBdID09PSAnZCcgPyAwIDogMjtcbiAgICAgICAgICAgIG1vbnRoU3RhcnRJbmRleCA9IDIgLSBkYXlTdGFydEluZGV4O1xuICAgICAgICAgICAgZGF5ID0gcGFyc2VJbnQodmFsdWUuc2xpY2UoZGF5U3RhcnRJbmRleCwgZGF5U3RhcnRJbmRleCArIDIpLCAxMCk7XG4gICAgICAgICAgICBtb250aCA9IHBhcnNlSW50KHZhbHVlLnNsaWNlKG1vbnRoU3RhcnRJbmRleCwgbW9udGhTdGFydEluZGV4ICsgMiksIDEwKTtcbiAgICAgICAgICAgIGRhdGUgPSB0aGlzLmdldEZpeGVkRGF0ZShkYXksIG1vbnRoLCAwKTtcbiAgICAgICAgICB9IC8vIHl5eXktbW0tZGQgfHwgeXl5eS1kZC1tbSB8fCBtbS1kZC15eXl5IHx8IGRkLW1tLXl5eXkgfHwgZGQteXl5eS1tbSB8fCBtbS15eXl5LWRkXG5cblxuICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDgpIHtcbiAgICAgICAgICAgIGRhdGVQYXR0ZXJuLmZvckVhY2goZnVuY3Rpb24gKHR5cGUsIGluZGV4KSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgICAgICAgICAgZGF5SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICAgICAgICBtb250aEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICB5ZWFySW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHllYXJTdGFydEluZGV4ID0geWVhckluZGV4ICogMjtcbiAgICAgICAgICAgIGRheVN0YXJ0SW5kZXggPSBkYXlJbmRleCA8PSB5ZWFySW5kZXggPyBkYXlJbmRleCAqIDIgOiBkYXlJbmRleCAqIDIgKyAyO1xuICAgICAgICAgICAgbW9udGhTdGFydEluZGV4ID0gbW9udGhJbmRleCA8PSB5ZWFySW5kZXggPyBtb250aEluZGV4ICogMiA6IG1vbnRoSW5kZXggKiAyICsgMjtcbiAgICAgICAgICAgIGRheSA9IHBhcnNlSW50KHZhbHVlLnNsaWNlKGRheVN0YXJ0SW5kZXgsIGRheVN0YXJ0SW5kZXggKyAyKSwgMTApO1xuICAgICAgICAgICAgbW9udGggPSBwYXJzZUludCh2YWx1ZS5zbGljZShtb250aFN0YXJ0SW5kZXgsIG1vbnRoU3RhcnRJbmRleCArIDIpLCAxMCk7XG4gICAgICAgICAgICB5ZWFyID0gcGFyc2VJbnQodmFsdWUuc2xpY2UoeWVhclN0YXJ0SW5kZXgsIHllYXJTdGFydEluZGV4ICsgNCksIDEwKTtcbiAgICAgICAgICAgIGZ1bGxZZWFyRG9uZSA9IHZhbHVlLnNsaWNlKHllYXJTdGFydEluZGV4LCB5ZWFyU3RhcnRJbmRleCArIDQpLmxlbmd0aCA9PT0gNDtcbiAgICAgICAgICAgIGRhdGUgPSB0aGlzLmdldEZpeGVkRGF0ZShkYXksIG1vbnRoLCB5ZWFyKTtcbiAgICAgICAgICB9IC8vIG1tLXl5IHx8IHl5LW1tXG5cblxuICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDQgJiYgKGRhdGVQYXR0ZXJuWzBdID09PSAneScgfHwgZGF0ZVBhdHRlcm5bMV0gPT09ICd5JykpIHtcbiAgICAgICAgICAgIG1vbnRoU3RhcnRJbmRleCA9IGRhdGVQYXR0ZXJuWzBdID09PSAnbScgPyAwIDogMjtcbiAgICAgICAgICAgIHllYXJTdGFydEluZGV4ID0gMiAtIG1vbnRoU3RhcnRJbmRleDtcbiAgICAgICAgICAgIG1vbnRoID0gcGFyc2VJbnQodmFsdWUuc2xpY2UobW9udGhTdGFydEluZGV4LCBtb250aFN0YXJ0SW5kZXggKyAyKSwgMTApO1xuICAgICAgICAgICAgeWVhciA9IHBhcnNlSW50KHZhbHVlLnNsaWNlKHllYXJTdGFydEluZGV4LCB5ZWFyU3RhcnRJbmRleCArIDIpLCAxMCk7XG4gICAgICAgICAgICBmdWxsWWVhckRvbmUgPSB2YWx1ZS5zbGljZSh5ZWFyU3RhcnRJbmRleCwgeWVhclN0YXJ0SW5kZXggKyAyKS5sZW5ndGggPT09IDI7XG4gICAgICAgICAgICBkYXRlID0gWzAsIG1vbnRoLCB5ZWFyXTtcbiAgICAgICAgICB9IC8vIG1tLXl5eXkgfHwgeXl5eS1tbVxuXG5cbiAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSA2ICYmIChkYXRlUGF0dGVyblswXSA9PT0gJ1knIHx8IGRhdGVQYXR0ZXJuWzFdID09PSAnWScpKSB7XG4gICAgICAgICAgICBtb250aFN0YXJ0SW5kZXggPSBkYXRlUGF0dGVyblswXSA9PT0gJ20nID8gMCA6IDQ7XG4gICAgICAgICAgICB5ZWFyU3RhcnRJbmRleCA9IDIgLSAwLjUgKiBtb250aFN0YXJ0SW5kZXg7XG4gICAgICAgICAgICBtb250aCA9IHBhcnNlSW50KHZhbHVlLnNsaWNlKG1vbnRoU3RhcnRJbmRleCwgbW9udGhTdGFydEluZGV4ICsgMiksIDEwKTtcbiAgICAgICAgICAgIHllYXIgPSBwYXJzZUludCh2YWx1ZS5zbGljZSh5ZWFyU3RhcnRJbmRleCwgeWVhclN0YXJ0SW5kZXggKyA0KSwgMTApO1xuICAgICAgICAgICAgZnVsbFllYXJEb25lID0gdmFsdWUuc2xpY2UoeWVhclN0YXJ0SW5kZXgsIHllYXJTdGFydEluZGV4ICsgNCkubGVuZ3RoID09PSA0O1xuICAgICAgICAgICAgZGF0ZSA9IFswLCBtb250aCwgeWVhcl07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGF0ZSA9IG93bmVyLmdldFJhbmdlRml4ZWREYXRlKGRhdGUpO1xuICAgICAgICAgIG93bmVyLmRhdGUgPSBkYXRlO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBkYXRlLmxlbmd0aCA9PT0gMCA/IHZhbHVlIDogZGF0ZVBhdHRlcm4ucmVkdWNlKGZ1bmN0aW9uIChwcmV2aW91cywgY3VycmVudCkge1xuICAgICAgICAgICAgc3dpdGNoIChjdXJyZW50KSB7XG4gICAgICAgICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwcmV2aW91cyArIChkYXRlWzBdID09PSAwID8gJycgOiBvd25lci5hZGRMZWFkaW5nWmVybyhkYXRlWzBdKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzICsgKGRhdGVbMV0gPT09IDAgPyAnJyA6IG93bmVyLmFkZExlYWRpbmdaZXJvKGRhdGVbMV0pKTtcblxuICAgICAgICAgICAgICBjYXNlICd5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJldmlvdXMgKyAoZnVsbFllYXJEb25lID8gb3duZXIuYWRkTGVhZGluZ1plcm9Gb3JZZWFyKGRhdGVbMl0sIGZhbHNlKSA6ICcnKTtcblxuICAgICAgICAgICAgICBjYXNlICdZJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJldmlvdXMgKyAoZnVsbFllYXJEb25lID8gb3duZXIuYWRkTGVhZGluZ1plcm9Gb3JZZWFyKGRhdGVbMl0sIHRydWUpIDogJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sICcnKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuICAgICAgICBnZXRSYW5nZUZpeGVkRGF0ZTogZnVuY3Rpb24gZ2V0UmFuZ2VGaXhlZERhdGUoZGF0ZSkge1xuICAgICAgICAgIHZhciBvd25lciA9IHRoaXMsXG4gICAgICAgICAgICAgIGRhdGVQYXR0ZXJuID0gb3duZXIuZGF0ZVBhdHRlcm4sXG4gICAgICAgICAgICAgIGRhdGVNaW4gPSBvd25lci5kYXRlTWluIHx8IFtdLFxuICAgICAgICAgICAgICBkYXRlTWF4ID0gb3duZXIuZGF0ZU1heCB8fCBbXTtcbiAgICAgICAgICBpZiAoIWRhdGUubGVuZ3RoIHx8IGRhdGVNaW4ubGVuZ3RoIDwgMyAmJiBkYXRlTWF4Lmxlbmd0aCA8IDMpIHJldHVybiBkYXRlO1xuICAgICAgICAgIGlmIChkYXRlUGF0dGVybi5maW5kKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4geC50b0xvd2VyQ2FzZSgpID09PSAneSc7XG4gICAgICAgICAgfSkgJiYgZGF0ZVsyXSA9PT0gMCkgcmV0dXJuIGRhdGU7XG4gICAgICAgICAgaWYgKGRhdGVNYXgubGVuZ3RoICYmIChkYXRlTWF4WzJdIDwgZGF0ZVsyXSB8fCBkYXRlTWF4WzJdID09PSBkYXRlWzJdICYmIChkYXRlTWF4WzFdIDwgZGF0ZVsxXSB8fCBkYXRlTWF4WzFdID09PSBkYXRlWzFdICYmIGRhdGVNYXhbMF0gPCBkYXRlWzBdKSkpIHJldHVybiBkYXRlTWF4O1xuICAgICAgICAgIGlmIChkYXRlTWluLmxlbmd0aCAmJiAoZGF0ZU1pblsyXSA+IGRhdGVbMl0gfHwgZGF0ZU1pblsyXSA9PT0gZGF0ZVsyXSAmJiAoZGF0ZU1pblsxXSA+IGRhdGVbMV0gfHwgZGF0ZU1pblsxXSA9PT0gZGF0ZVsxXSAmJiBkYXRlTWluWzBdID4gZGF0ZVswXSkpKSByZXR1cm4gZGF0ZU1pbjtcbiAgICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Rml4ZWREYXRlOiBmdW5jdGlvbiBnZXRGaXhlZERhdGUoZGF5LCBtb250aCwgeWVhcikge1xuICAgICAgICAgIGRheSA9IE1hdGgubWluKGRheSwgMzEpO1xuICAgICAgICAgIG1vbnRoID0gTWF0aC5taW4obW9udGgsIDEyKTtcbiAgICAgICAgICB5ZWFyID0gcGFyc2VJbnQoeWVhciB8fCAwLCAxMCk7XG5cbiAgICAgICAgICBpZiAobW9udGggPCA3ICYmIG1vbnRoICUgMiA9PT0gMCB8fCBtb250aCA+IDggJiYgbW9udGggJSAyID09PSAxKSB7XG4gICAgICAgICAgICBkYXkgPSBNYXRoLm1pbihkYXksIG1vbnRoID09PSAyID8gdGhpcy5pc0xlYXBZZWFyKHllYXIpID8gMjkgOiAyOCA6IDMwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gW2RheSwgbW9udGgsIHllYXJdO1xuICAgICAgICB9LFxuICAgICAgICBpc0xlYXBZZWFyOiBmdW5jdGlvbiBpc0xlYXBZZWFyKHllYXIpIHtcbiAgICAgICAgICByZXR1cm4geWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMCB8fCB5ZWFyICUgNDAwID09PSAwO1xuICAgICAgICB9LFxuICAgICAgICBhZGRMZWFkaW5nWmVybzogZnVuY3Rpb24gYWRkTGVhZGluZ1plcm8obnVtYmVyKSB7XG4gICAgICAgICAgcmV0dXJuIChudW1iZXIgPCAxMCA/ICcwJyA6ICcnKSArIG51bWJlcjtcbiAgICAgICAgfSxcbiAgICAgICAgYWRkTGVhZGluZ1plcm9Gb3JZZWFyOiBmdW5jdGlvbiBhZGRMZWFkaW5nWmVyb0ZvclllYXIobnVtYmVyLCBmdWxsWWVhck1vZGUpIHtcbiAgICAgICAgICBpZiAoZnVsbFllYXJNb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gKG51bWJlciA8IDEwID8gJzAwMCcgOiBudW1iZXIgPCAxMDAgPyAnMDAnIDogbnVtYmVyIDwgMTAwMCA/ICcwJyA6ICcnKSArIG51bWJlcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gKG51bWJlciA8IDEwID8gJzAnIDogJycpICsgbnVtYmVyO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBEYXRlRm9ybWF0dGVyO1xuICAgICAgLyoqKi9cbiAgICB9LFxuICAgIC8qIDExICovXG5cbiAgICAvKioqL1xuICAgIGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgdmFyIFRpbWVGb3JtYXR0ZXIgPSBmdW5jdGlvbiBUaW1lRm9ybWF0dGVyKHRpbWVQYXR0ZXJuLCB0aW1lRm9ybWF0KSB7XG4gICAgICAgIHZhciBvd25lciA9IHRoaXM7XG4gICAgICAgIG93bmVyLnRpbWUgPSBbXTtcbiAgICAgICAgb3duZXIuYmxvY2tzID0gW107XG4gICAgICAgIG93bmVyLnRpbWVQYXR0ZXJuID0gdGltZVBhdHRlcm47XG4gICAgICAgIG93bmVyLnRpbWVGb3JtYXQgPSB0aW1lRm9ybWF0O1xuICAgICAgICBvd25lci5pbml0QmxvY2tzKCk7XG4gICAgICB9O1xuXG4gICAgICBUaW1lRm9ybWF0dGVyLnByb3RvdHlwZSA9IHtcbiAgICAgICAgaW5pdEJsb2NrczogZnVuY3Rpb24gaW5pdEJsb2NrcygpIHtcbiAgICAgICAgICB2YXIgb3duZXIgPSB0aGlzO1xuICAgICAgICAgIG93bmVyLnRpbWVQYXR0ZXJuLmZvckVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgb3duZXIuYmxvY2tzLnB1c2goMik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldElTT0Zvcm1hdFRpbWU6IGZ1bmN0aW9uIGdldElTT0Zvcm1hdFRpbWUoKSB7XG4gICAgICAgICAgdmFyIG93bmVyID0gdGhpcyxcbiAgICAgICAgICAgICAgdGltZSA9IG93bmVyLnRpbWU7XG4gICAgICAgICAgcmV0dXJuIHRpbWVbMl0gPyBvd25lci5hZGRMZWFkaW5nWmVybyh0aW1lWzBdKSArICc6JyArIG93bmVyLmFkZExlYWRpbmdaZXJvKHRpbWVbMV0pICsgJzonICsgb3duZXIuYWRkTGVhZGluZ1plcm8odGltZVsyXSkgOiAnJztcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0QmxvY2tzOiBmdW5jdGlvbiBnZXRCbG9ja3MoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYmxvY2tzO1xuICAgICAgICB9LFxuICAgICAgICBnZXRUaW1lRm9ybWF0T3B0aW9uczogZnVuY3Rpb24gZ2V0VGltZUZvcm1hdE9wdGlvbnMoKSB7XG4gICAgICAgICAgdmFyIG93bmVyID0gdGhpcztcblxuICAgICAgICAgIGlmIChTdHJpbmcob3duZXIudGltZUZvcm1hdCkgPT09ICcxMicpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIG1heEhvdXJGaXJzdERpZ2l0OiAxLFxuICAgICAgICAgICAgICBtYXhIb3VyczogMTIsXG4gICAgICAgICAgICAgIG1heE1pbnV0ZXNGaXJzdERpZ2l0OiA1LFxuICAgICAgICAgICAgICBtYXhNaW51dGVzOiA2MFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWF4SG91ckZpcnN0RGlnaXQ6IDIsXG4gICAgICAgICAgICBtYXhIb3VyczogMjMsXG4gICAgICAgICAgICBtYXhNaW51dGVzRmlyc3REaWdpdDogNSxcbiAgICAgICAgICAgIG1heE1pbnV0ZXM6IDYwXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0VmFsaWRhdGVkVGltZTogZnVuY3Rpb24gZ2V0VmFsaWRhdGVkVGltZSh2YWx1ZSkge1xuICAgICAgICAgIHZhciBvd25lciA9IHRoaXMsXG4gICAgICAgICAgICAgIHJlc3VsdCA9ICcnO1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvW15cXGRdL2csICcnKTtcbiAgICAgICAgICB2YXIgdGltZUZvcm1hdE9wdGlvbnMgPSBvd25lci5nZXRUaW1lRm9ybWF0T3B0aW9ucygpO1xuICAgICAgICAgIG93bmVyLmJsb2Nrcy5mb3JFYWNoKGZ1bmN0aW9uIChsZW5ndGgsIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICB2YXIgc3ViID0gdmFsdWUuc2xpY2UoMCwgbGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgIHN1YjAgPSBzdWIuc2xpY2UoMCwgMSksXG4gICAgICAgICAgICAgICAgICByZXN0ID0gdmFsdWUuc2xpY2UobGVuZ3RoKTtcblxuICAgICAgICAgICAgICBzd2l0Y2ggKG93bmVyLnRpbWVQYXR0ZXJuW2luZGV4XSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2gnOlxuICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlSW50KHN1YjAsIDEwKSA+IHRpbWVGb3JtYXRPcHRpb25zLm1heEhvdXJGaXJzdERpZ2l0KSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YiA9ICcwJyArIHN1YjA7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnNlSW50KHN1YiwgMTApID4gdGltZUZvcm1hdE9wdGlvbnMubWF4SG91cnMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ViID0gdGltZUZvcm1hdE9wdGlvbnMubWF4SG91cnMgKyAnJztcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdtJzpcbiAgICAgICAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZUludChzdWIwLCAxMCkgPiB0aW1lRm9ybWF0T3B0aW9ucy5tYXhNaW51dGVzRmlyc3REaWdpdCkge1xuICAgICAgICAgICAgICAgICAgICBzdWIgPSAnMCcgKyBzdWIwO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJzZUludChzdWIsIDEwKSA+IHRpbWVGb3JtYXRPcHRpb25zLm1heE1pbnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ViID0gdGltZUZvcm1hdE9wdGlvbnMubWF4TWludXRlcyArICcnO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJlc3VsdCArPSBzdWI7IC8vIHVwZGF0ZSByZW1haW5pbmcgc3RyaW5nXG5cbiAgICAgICAgICAgICAgdmFsdWUgPSByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB0aGlzLmdldEZpeGVkVGltZVN0cmluZyhyZXN1bHQpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRGaXhlZFRpbWVTdHJpbmc6IGZ1bmN0aW9uIGdldEZpeGVkVGltZVN0cmluZyh2YWx1ZSkge1xuICAgICAgICAgIHZhciBvd25lciA9IHRoaXMsXG4gICAgICAgICAgICAgIHRpbWVQYXR0ZXJuID0gb3duZXIudGltZVBhdHRlcm4sXG4gICAgICAgICAgICAgIHRpbWUgPSBbXSxcbiAgICAgICAgICAgICAgc2Vjb25kSW5kZXggPSAwLFxuICAgICAgICAgICAgICBtaW51dGVJbmRleCA9IDAsXG4gICAgICAgICAgICAgIGhvdXJJbmRleCA9IDAsXG4gICAgICAgICAgICAgIHNlY29uZFN0YXJ0SW5kZXggPSAwLFxuICAgICAgICAgICAgICBtaW51dGVTdGFydEluZGV4ID0gMCxcbiAgICAgICAgICAgICAgaG91clN0YXJ0SW5kZXggPSAwLFxuICAgICAgICAgICAgICBzZWNvbmQsXG4gICAgICAgICAgICAgIG1pbnV0ZSxcbiAgICAgICAgICAgICAgaG91cjtcblxuICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDYpIHtcbiAgICAgICAgICAgIHRpbWVQYXR0ZXJuLmZvckVhY2goZnVuY3Rpb24gKHR5cGUsIGluZGV4KSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICAgICAgc2Vjb25kSW5kZXggPSBpbmRleCAqIDI7XG4gICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgICAgICAgICAgbWludXRlSW5kZXggPSBpbmRleCAqIDI7XG4gICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2gnOlxuICAgICAgICAgICAgICAgICAgaG91ckluZGV4ID0gaW5kZXggKiAyO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaG91clN0YXJ0SW5kZXggPSBob3VySW5kZXg7XG4gICAgICAgICAgICBtaW51dGVTdGFydEluZGV4ID0gbWludXRlSW5kZXg7XG4gICAgICAgICAgICBzZWNvbmRTdGFydEluZGV4ID0gc2Vjb25kSW5kZXg7XG4gICAgICAgICAgICBzZWNvbmQgPSBwYXJzZUludCh2YWx1ZS5zbGljZShzZWNvbmRTdGFydEluZGV4LCBzZWNvbmRTdGFydEluZGV4ICsgMiksIDEwKTtcbiAgICAgICAgICAgIG1pbnV0ZSA9IHBhcnNlSW50KHZhbHVlLnNsaWNlKG1pbnV0ZVN0YXJ0SW5kZXgsIG1pbnV0ZVN0YXJ0SW5kZXggKyAyKSwgMTApO1xuICAgICAgICAgICAgaG91ciA9IHBhcnNlSW50KHZhbHVlLnNsaWNlKGhvdXJTdGFydEluZGV4LCBob3VyU3RhcnRJbmRleCArIDIpLCAxMCk7XG4gICAgICAgICAgICB0aW1lID0gdGhpcy5nZXRGaXhlZFRpbWUoaG91ciwgbWludXRlLCBzZWNvbmQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDQgJiYgb3duZXIudGltZVBhdHRlcm4uaW5kZXhPZigncycpIDwgMCkge1xuICAgICAgICAgICAgdGltZVBhdHRlcm4uZm9yRWFjaChmdW5jdGlvbiAodHlwZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICAgICAgICBtaW51dGVJbmRleCA9IGluZGV4ICogMjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgICAgICAgICAgICBob3VySW5kZXggPSBpbmRleCAqIDI7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBob3VyU3RhcnRJbmRleCA9IGhvdXJJbmRleDtcbiAgICAgICAgICAgIG1pbnV0ZVN0YXJ0SW5kZXggPSBtaW51dGVJbmRleDtcbiAgICAgICAgICAgIHNlY29uZCA9IDA7XG4gICAgICAgICAgICBtaW51dGUgPSBwYXJzZUludCh2YWx1ZS5zbGljZShtaW51dGVTdGFydEluZGV4LCBtaW51dGVTdGFydEluZGV4ICsgMiksIDEwKTtcbiAgICAgICAgICAgIGhvdXIgPSBwYXJzZUludCh2YWx1ZS5zbGljZShob3VyU3RhcnRJbmRleCwgaG91clN0YXJ0SW5kZXggKyAyKSwgMTApO1xuICAgICAgICAgICAgdGltZSA9IHRoaXMuZ2V0Rml4ZWRUaW1lKGhvdXIsIG1pbnV0ZSwgc2Vjb25kKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvd25lci50aW1lID0gdGltZTtcbiAgICAgICAgICByZXR1cm4gdGltZS5sZW5ndGggPT09IDAgPyB2YWx1ZSA6IHRpbWVQYXR0ZXJuLnJlZHVjZShmdW5jdGlvbiAocHJldmlvdXMsIGN1cnJlbnQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoY3VycmVudCkge1xuICAgICAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJldmlvdXMgKyBvd25lci5hZGRMZWFkaW5nWmVybyh0aW1lWzJdKTtcblxuICAgICAgICAgICAgICBjYXNlICdtJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJldmlvdXMgKyBvd25lci5hZGRMZWFkaW5nWmVybyh0aW1lWzFdKTtcblxuICAgICAgICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJldmlvdXMgKyBvd25lci5hZGRMZWFkaW5nWmVybyh0aW1lWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCAnJyk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEZpeGVkVGltZTogZnVuY3Rpb24gZ2V0Rml4ZWRUaW1lKGhvdXIsIG1pbnV0ZSwgc2Vjb25kKSB7XG4gICAgICAgICAgc2Vjb25kID0gTWF0aC5taW4ocGFyc2VJbnQoc2Vjb25kIHx8IDAsIDEwKSwgNjApO1xuICAgICAgICAgIG1pbnV0ZSA9IE1hdGgubWluKG1pbnV0ZSwgNjApO1xuICAgICAgICAgIGhvdXIgPSBNYXRoLm1pbihob3VyLCA2MCk7XG4gICAgICAgICAgcmV0dXJuIFtob3VyLCBtaW51dGUsIHNlY29uZF07XG4gICAgICAgIH0sXG4gICAgICAgIGFkZExlYWRpbmdaZXJvOiBmdW5jdGlvbiBhZGRMZWFkaW5nWmVybyhudW1iZXIpIHtcbiAgICAgICAgICByZXR1cm4gKG51bWJlciA8IDEwID8gJzAnIDogJycpICsgbnVtYmVyO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBUaW1lRm9ybWF0dGVyO1xuICAgICAgLyoqKi9cbiAgICB9LFxuICAgIC8qIDEyICovXG5cbiAgICAvKioqL1xuICAgIGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgdmFyIFBob25lRm9ybWF0dGVyID0gZnVuY3Rpb24gUGhvbmVGb3JtYXR0ZXIoZm9ybWF0dGVyLCBkZWxpbWl0ZXIpIHtcbiAgICAgICAgdmFyIG93bmVyID0gdGhpcztcbiAgICAgICAgb3duZXIuZGVsaW1pdGVyID0gZGVsaW1pdGVyIHx8IGRlbGltaXRlciA9PT0gJycgPyBkZWxpbWl0ZXIgOiAnICc7XG4gICAgICAgIG93bmVyLmRlbGltaXRlclJFID0gZGVsaW1pdGVyID8gbmV3IFJlZ0V4cCgnXFxcXCcgKyBkZWxpbWl0ZXIsICdnJykgOiAnJztcbiAgICAgICAgb3duZXIuZm9ybWF0dGVyID0gZm9ybWF0dGVyO1xuICAgICAgfTtcblxuICAgICAgUGhvbmVGb3JtYXR0ZXIucHJvdG90eXBlID0ge1xuICAgICAgICBzZXRGb3JtYXR0ZXI6IGZ1bmN0aW9uIHNldEZvcm1hdHRlcihmb3JtYXR0ZXIpIHtcbiAgICAgICAgICB0aGlzLmZvcm1hdHRlciA9IGZvcm1hdHRlcjtcbiAgICAgICAgfSxcbiAgICAgICAgZm9ybWF0OiBmdW5jdGlvbiBmb3JtYXQocGhvbmVOdW1iZXIpIHtcbiAgICAgICAgICB2YXIgb3duZXIgPSB0aGlzO1xuICAgICAgICAgIG93bmVyLmZvcm1hdHRlci5jbGVhcigpOyAvLyBvbmx5IGtlZXAgbnVtYmVyIGFuZCArXG5cbiAgICAgICAgICBwaG9uZU51bWJlciA9IHBob25lTnVtYmVyLnJlcGxhY2UoL1teXFxkK10vZywgJycpOyAvLyBzdHJpcCBub24tbGVhZGluZyArXG5cbiAgICAgICAgICBwaG9uZU51bWJlciA9IHBob25lTnVtYmVyLnJlcGxhY2UoL15cXCsvLCAnQicpLnJlcGxhY2UoL1xcKy9nLCAnJykucmVwbGFjZSgnQicsICcrJyk7IC8vIHN0cmlwIGRlbGltaXRlclxuXG4gICAgICAgICAgcGhvbmVOdW1iZXIgPSBwaG9uZU51bWJlci5yZXBsYWNlKG93bmVyLmRlbGltaXRlclJFLCAnJyk7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9ICcnLFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICB2YWxpZGF0ZWQgPSBmYWxzZTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpTWF4ID0gcGhvbmVOdW1iZXIubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgICAgICAgICBjdXJyZW50ID0gb3duZXIuZm9ybWF0dGVyLmlucHV0RGlnaXQocGhvbmVOdW1iZXIuY2hhckF0KGkpKTsgLy8gaGFzICgpLSBvciBzcGFjZSBpbnNpZGVcblxuICAgICAgICAgICAgaWYgKC9bXFxzKCktXS9nLnRlc3QoY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gY3VycmVudDtcbiAgICAgICAgICAgICAgdmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICghdmFsaWRhdGVkKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gY3VycmVudDtcbiAgICAgICAgICAgICAgfSAvLyBlbHNlOiBvdmVyIGxlbmd0aCBpbnB1dFxuICAgICAgICAgICAgICAvLyBpdCB0dXJucyB0byBpbnZhbGlkIG51bWJlciBhZ2FpblxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBzdHJpcCAoKVxuICAgICAgICAgIC8vIGUuZy4gVVM6IDcxNjEyMzQ1NjcgcmV0dXJucyAoNzE2KSAxMjMtNDU2N1xuXG5cbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZSgvWygpXS9nLCAnJyk7IC8vIHJlcGxhY2UgbGlicmFyeSBkZWxpbWl0ZXIgd2l0aCB1c2VyIGN1c3RvbWl6ZWQgZGVsaW1pdGVyXG5cbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZSgvW1xccy1dL2csIG93bmVyLmRlbGltaXRlcik7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gUGhvbmVGb3JtYXR0ZXI7XG4gICAgICAvKioqL1xuICAgIH0sXG4gICAgLyogMTMgKi9cblxuICAgIC8qKiovXG4gICAgZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICB2YXIgQ3JlZGl0Q2FyZERldGVjdG9yID0ge1xuICAgICAgICBibG9ja3M6IHtcbiAgICAgICAgICB1YXRwOiBbNCwgNSwgNl0sXG4gICAgICAgICAgYW1leDogWzQsIDYsIDVdLFxuICAgICAgICAgIGRpbmVyczogWzQsIDYsIDRdLFxuICAgICAgICAgIGRpc2NvdmVyOiBbNCwgNCwgNCwgNF0sXG4gICAgICAgICAgbWFzdGVyY2FyZDogWzQsIDQsIDQsIDRdLFxuICAgICAgICAgIGRhbmtvcnQ6IFs0LCA0LCA0LCA0XSxcbiAgICAgICAgICBpbnN0YXBheW1lbnQ6IFs0LCA0LCA0LCA0XSxcbiAgICAgICAgICBqY2IxNTogWzQsIDYsIDVdLFxuICAgICAgICAgIGpjYjogWzQsIDQsIDQsIDRdLFxuICAgICAgICAgIG1hZXN0cm86IFs0LCA0LCA0LCA0XSxcbiAgICAgICAgICB2aXNhOiBbNCwgNCwgNCwgNF0sXG4gICAgICAgICAgbWlyOiBbNCwgNCwgNCwgNF0sXG4gICAgICAgICAgdW5pb25QYXk6IFs0LCA0LCA0LCA0XSxcbiAgICAgICAgICBnZW5lcmFsOiBbNCwgNCwgNCwgNF1cbiAgICAgICAgfSxcbiAgICAgICAgcmU6IHtcbiAgICAgICAgICAvLyBzdGFydHMgd2l0aCAxOyAxNSBkaWdpdHMsIG5vdCBzdGFydHMgd2l0aCAxODAwIChqY2IgY2FyZClcbiAgICAgICAgICB1YXRwOiAvXig/ITE4MDApMVxcZHswLDE0fS8sXG4gICAgICAgICAgLy8gc3RhcnRzIHdpdGggMzQvMzc7IDE1IGRpZ2l0c1xuICAgICAgICAgIGFtZXg6IC9eM1s0N11cXGR7MCwxM30vLFxuICAgICAgICAgIC8vIHN0YXJ0cyB3aXRoIDYwMTEvNjUvNjQ0LTY0OTsgMTYgZGlnaXRzXG4gICAgICAgICAgZGlzY292ZXI6IC9eKD86NjAxMXw2NVxcZHswLDJ9fDY0WzQtOV1cXGQ/KVxcZHswLDEyfS8sXG4gICAgICAgICAgLy8gc3RhcnRzIHdpdGggMzAwLTMwNS8zMDkgb3IgMzYvMzgvMzk7IDE0IGRpZ2l0c1xuICAgICAgICAgIGRpbmVyczogL14zKD86MChbMC01XXw5KXxbNjg5XVxcZD8pXFxkezAsMTF9LyxcbiAgICAgICAgICAvLyBzdGFydHMgd2l0aCA1MS01NS8yMjIx4oCTMjcyMDsgMTYgZGlnaXRzXG4gICAgICAgICAgbWFzdGVyY2FyZDogL14oNVsxLTVdXFxkezAsMn18MjJbMi05XVxcZHswLDF9fDJbMy03XVxcZHswLDJ9KVxcZHswLDEyfS8sXG4gICAgICAgICAgLy8gc3RhcnRzIHdpdGggNTAxOS80MTc1LzQ1NzE7IDE2IGRpZ2l0c1xuICAgICAgICAgIGRhbmtvcnQ6IC9eKDUwMTl8NDE3NXw0NTcxKVxcZHswLDEyfS8sXG4gICAgICAgICAgLy8gc3RhcnRzIHdpdGggNjM3LTYzOTsgMTYgZGlnaXRzXG4gICAgICAgICAgaW5zdGFwYXltZW50OiAvXjYzWzctOV1cXGR7MCwxM30vLFxuICAgICAgICAgIC8vIHN0YXJ0cyB3aXRoIDIxMzEvMTgwMDsgMTUgZGlnaXRzXG4gICAgICAgICAgamNiMTU6IC9eKD86MjEzMXwxODAwKVxcZHswLDExfS8sXG4gICAgICAgICAgLy8gc3RhcnRzIHdpdGggMjEzMS8xODAwLzM1OyAxNiBkaWdpdHNcbiAgICAgICAgICBqY2I6IC9eKD86MzVcXGR7MCwyfSlcXGR7MCwxMn0vLFxuICAgICAgICAgIC8vIHN0YXJ0cyB3aXRoIDUwLzU2LTU4LzYzMDQvNjc7IDE2IGRpZ2l0c1xuICAgICAgICAgIG1hZXN0cm86IC9eKD86NVswNjc4XVxcZHswLDJ9fDYzMDR8NjdcXGR7MCwyfSlcXGR7MCwxMn0vLFxuICAgICAgICAgIC8vIHN0YXJ0cyB3aXRoIDIyOyAxNiBkaWdpdHNcbiAgICAgICAgICBtaXI6IC9eMjIwWzAtNF1cXGR7MCwxMn0vLFxuICAgICAgICAgIC8vIHN0YXJ0cyB3aXRoIDQ7IDE2IGRpZ2l0c1xuICAgICAgICAgIHZpc2E6IC9eNFxcZHswLDE1fS8sXG4gICAgICAgICAgLy8gc3RhcnRzIHdpdGggNjIvODE7IDE2IGRpZ2l0c1xuICAgICAgICAgIHVuaW9uUGF5OiAvXig2Mnw4MSlcXGR7MCwxNH0vXG4gICAgICAgIH0sXG4gICAgICAgIGdldFN0cmljdEJsb2NrczogZnVuY3Rpb24gZ2V0U3RyaWN0QmxvY2tzKGJsb2NrKSB7XG4gICAgICAgICAgdmFyIHRvdGFsID0gYmxvY2sucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gcHJldiArIGN1cnJlbnQ7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgcmV0dXJuIGJsb2NrLmNvbmNhdCgxOSAtIHRvdGFsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0SW5mbzogZnVuY3Rpb24gZ2V0SW5mbyh2YWx1ZSwgc3RyaWN0TW9kZSkge1xuICAgICAgICAgIHZhciBibG9ja3MgPSBDcmVkaXRDYXJkRGV0ZWN0b3IuYmxvY2tzLFxuICAgICAgICAgICAgICByZSA9IENyZWRpdENhcmREZXRlY3Rvci5yZTsgLy8gU29tZSBjcmVkaXQgY2FyZCBjYW4gaGF2ZSB1cCB0byAxOSBkaWdpdHMgbnVtYmVyLlxuICAgICAgICAgIC8vIFNldCBzdHJpY3RNb2RlIHRvIHRydWUgd2lsbCByZW1vdmUgdGhlIDE2IG1heC1sZW5ndGggcmVzdHJhaW4sXG4gICAgICAgICAgLy8gaG93ZXZlciwgSSBuZXZlciBmb3VuZCBhbnkgd2Vic2l0ZSB2YWxpZGF0ZSBjYXJkIG51bWJlciBsaWtlXG4gICAgICAgICAgLy8gdGhpcywgaGVuY2UgcHJvYmFibHkgeW91IGRvbid0IHdhbnQgdG8gZW5hYmxlIHRoaXMgb3B0aW9uLlxuXG4gICAgICAgICAgc3RyaWN0TW9kZSA9ICEhc3RyaWN0TW9kZTtcblxuICAgICAgICAgIGZvciAodmFyIGtleSBpbiByZSkge1xuICAgICAgICAgICAgaWYgKHJlW2tleV0udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgdmFyIG1hdGNoZWRCbG9ja3MgPSBibG9ja3Nba2V5XTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBrZXksXG4gICAgICAgICAgICAgICAgYmxvY2tzOiBzdHJpY3RNb2RlID8gdGhpcy5nZXRTdHJpY3RCbG9ja3MobWF0Y2hlZEJsb2NrcykgOiBtYXRjaGVkQmxvY2tzXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICd1bmtub3duJyxcbiAgICAgICAgICAgIGJsb2Nrczogc3RyaWN0TW9kZSA/IHRoaXMuZ2V0U3RyaWN0QmxvY2tzKGJsb2Nrcy5nZW5lcmFsKSA6IGJsb2Nrcy5nZW5lcmFsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gQ3JlZGl0Q2FyZERldGVjdG9yO1xuICAgICAgLyoqKi9cbiAgICB9LFxuICAgIC8qIDE0ICovXG5cbiAgICAvKioqL1xuICAgIGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgdmFyIFV0aWwgPSB7XG4gICAgICAgIG5vb3A6IGZ1bmN0aW9uIG5vb3AoKSB7fSxcbiAgICAgICAgc3RyaXA6IGZ1bmN0aW9uIHN0cmlwKHZhbHVlLCByZSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKHJlLCAnJyk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFBvc3REZWxpbWl0ZXI6IGZ1bmN0aW9uIGdldFBvc3REZWxpbWl0ZXIodmFsdWUsIGRlbGltaXRlciwgZGVsaW1pdGVycykge1xuICAgICAgICAgIC8vIHNpbmdsZSBkZWxpbWl0ZXJcbiAgICAgICAgICBpZiAoZGVsaW1pdGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zbGljZSgtZGVsaW1pdGVyLmxlbmd0aCkgPT09IGRlbGltaXRlciA/IGRlbGltaXRlciA6ICcnO1xuICAgICAgICAgIH0gLy8gbXVsdGlwbGUgZGVsaW1pdGVyc1xuXG5cbiAgICAgICAgICB2YXIgbWF0Y2hlZERlbGltaXRlciA9ICcnO1xuICAgICAgICAgIGRlbGltaXRlcnMuZm9yRWFjaChmdW5jdGlvbiAoY3VycmVudCkge1xuICAgICAgICAgICAgaWYgKHZhbHVlLnNsaWNlKC1jdXJyZW50Lmxlbmd0aCkgPT09IGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgbWF0Y2hlZERlbGltaXRlciA9IGN1cnJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIG1hdGNoZWREZWxpbWl0ZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGdldERlbGltaXRlclJFQnlEZWxpbWl0ZXI6IGZ1bmN0aW9uIGdldERlbGltaXRlclJFQnlEZWxpbWl0ZXIoZGVsaW1pdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoZGVsaW1pdGVyLnJlcGxhY2UoLyhbLj8qK14kW1xcXVxcXFwoKXt9fC1dKS9nLCAnXFxcXCQxJyksICdnJyk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldE5leHRDdXJzb3JQb3NpdGlvbjogZnVuY3Rpb24gZ2V0TmV4dEN1cnNvclBvc2l0aW9uKHByZXZQb3MsIG9sZFZhbHVlLCBuZXdWYWx1ZSwgZGVsaW1pdGVyLCBkZWxpbWl0ZXJzKSB7XG4gICAgICAgICAgLy8gSWYgY3Vyc29yIHdhcyBhdCB0aGUgZW5kIG9mIHZhbHVlLCBqdXN0IHBsYWNlIGl0IGJhY2suXG4gICAgICAgICAgLy8gQmVjYXVzZSBuZXcgdmFsdWUgY291bGQgY29udGFpbiBhZGRpdGlvbmFsIGNoYXJzLlxuICAgICAgICAgIGlmIChvbGRWYWx1ZS5sZW5ndGggPT09IHByZXZQb3MpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXdWYWx1ZS5sZW5ndGg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHByZXZQb3MgKyB0aGlzLmdldFBvc2l0aW9uT2Zmc2V0KHByZXZQb3MsIG9sZFZhbHVlLCBuZXdWYWx1ZSwgZGVsaW1pdGVyLCBkZWxpbWl0ZXJzKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0UG9zaXRpb25PZmZzZXQ6IGZ1bmN0aW9uIGdldFBvc2l0aW9uT2Zmc2V0KHByZXZQb3MsIG9sZFZhbHVlLCBuZXdWYWx1ZSwgZGVsaW1pdGVyLCBkZWxpbWl0ZXJzKSB7XG4gICAgICAgICAgdmFyIG9sZFJhd1ZhbHVlLCBuZXdSYXdWYWx1ZSwgbGVuZ3RoT2Zmc2V0O1xuICAgICAgICAgIG9sZFJhd1ZhbHVlID0gdGhpcy5zdHJpcERlbGltaXRlcnMob2xkVmFsdWUuc2xpY2UoMCwgcHJldlBvcyksIGRlbGltaXRlciwgZGVsaW1pdGVycyk7XG4gICAgICAgICAgbmV3UmF3VmFsdWUgPSB0aGlzLnN0cmlwRGVsaW1pdGVycyhuZXdWYWx1ZS5zbGljZSgwLCBwcmV2UG9zKSwgZGVsaW1pdGVyLCBkZWxpbWl0ZXJzKTtcbiAgICAgICAgICBsZW5ndGhPZmZzZXQgPSBvbGRSYXdWYWx1ZS5sZW5ndGggLSBuZXdSYXdWYWx1ZS5sZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIGxlbmd0aE9mZnNldCAhPT0gMCA/IGxlbmd0aE9mZnNldCAvIE1hdGguYWJzKGxlbmd0aE9mZnNldCkgOiAwO1xuICAgICAgICB9LFxuICAgICAgICBzdHJpcERlbGltaXRlcnM6IGZ1bmN0aW9uIHN0cmlwRGVsaW1pdGVycyh2YWx1ZSwgZGVsaW1pdGVyLCBkZWxpbWl0ZXJzKSB7XG4gICAgICAgICAgdmFyIG93bmVyID0gdGhpczsgLy8gc2luZ2xlIGRlbGltaXRlclxuXG4gICAgICAgICAgaWYgKGRlbGltaXRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgZGVsaW1pdGVyUkUgPSBkZWxpbWl0ZXIgPyBvd25lci5nZXREZWxpbWl0ZXJSRUJ5RGVsaW1pdGVyKGRlbGltaXRlcikgOiAnJztcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKGRlbGltaXRlclJFLCAnJyk7XG4gICAgICAgICAgfSAvLyBtdWx0aXBsZSBkZWxpbWl0ZXJzXG5cblxuICAgICAgICAgIGRlbGltaXRlcnMuZm9yRWFjaChmdW5jdGlvbiAoY3VycmVudCkge1xuICAgICAgICAgICAgY3VycmVudC5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShvd25lci5nZXREZWxpbWl0ZXJSRUJ5RGVsaW1pdGVyKGxldHRlciksICcnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgaGVhZFN0cjogZnVuY3Rpb24gaGVhZFN0cihzdHIsIGxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBzdHIuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0TWF4TGVuZ3RoOiBmdW5jdGlvbiBnZXRNYXhMZW5ndGgoYmxvY2tzKSB7XG4gICAgICAgICAgcmV0dXJuIGJsb2Nrcy5yZWR1Y2UoZnVuY3Rpb24gKHByZXZpb3VzLCBjdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gcHJldmlvdXMgKyBjdXJyZW50O1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9LFxuICAgICAgICAvLyBzdHJpcCBwcmVmaXhcbiAgICAgICAgLy8gQmVmb3JlIHR5cGUgIHwgICBBZnRlciB0eXBlICAgIHwgICAgIFJldHVybiB2YWx1ZVxuICAgICAgICAvLyBQRUZJWC0uLi4gICAgfCAgIFBFRklYLS4uLiAgICAgfCAgICAgJydcbiAgICAgICAgLy8gUFJFRklYLTEyMyAgIHwgICBQRUZJWC0xMjMgICAgIHwgICAgIDEyM1xuICAgICAgICAvLyBQUkVGSVgtMTIzICAgfCAgIFBSRUZJWC0yMyAgICAgfCAgICAgMjNcbiAgICAgICAgLy8gUFJFRklYLTEyMyAgIHwgICBQUkVGSVgtMTIzNCAgIHwgICAgIDEyMzRcbiAgICAgICAgZ2V0UHJlZml4U3RyaXBwZWRWYWx1ZTogZnVuY3Rpb24gZ2V0UHJlZml4U3RyaXBwZWRWYWx1ZSh2YWx1ZSwgcHJlZml4LCBwcmVmaXhMZW5ndGgsIHByZXZSZXN1bHQsIGRlbGltaXRlciwgZGVsaW1pdGVycywgbm9JbW1lZGlhdGVQcmVmaXgsIHRhaWxQcmVmaXgsIHNpZ25CZWZvcmVQcmVmaXgpIHtcbiAgICAgICAgICAvLyBObyBwcmVmaXhcbiAgICAgICAgICBpZiAocHJlZml4TGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfSAvLyBWYWx1ZSBpcyBwcmVmaXhcblxuXG4gICAgICAgICAgaWYgKHZhbHVlID09PSBwcmVmaXggJiYgdmFsdWUgIT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNpZ25CZWZvcmVQcmVmaXggJiYgdmFsdWUuc2xpY2UoMCwgMSkgPT0gJy0nKSB7XG4gICAgICAgICAgICB2YXIgcHJldiA9IHByZXZSZXN1bHQuc2xpY2UoMCwgMSkgPT0gJy0nID8gcHJldlJlc3VsdC5zbGljZSgxKSA6IHByZXZSZXN1bHQ7XG4gICAgICAgICAgICByZXR1cm4gJy0nICsgdGhpcy5nZXRQcmVmaXhTdHJpcHBlZFZhbHVlKHZhbHVlLnNsaWNlKDEpLCBwcmVmaXgsIHByZWZpeExlbmd0aCwgcHJldiwgZGVsaW1pdGVyLCBkZWxpbWl0ZXJzLCBub0ltbWVkaWF0ZVByZWZpeCwgdGFpbFByZWZpeCwgc2lnbkJlZm9yZVByZWZpeCk7XG4gICAgICAgICAgfSAvLyBQcmUgcmVzdWx0IHByZWZpeCBzdHJpbmcgZG9lcyBub3QgbWF0Y2ggcHJlLWRlZmluZWQgcHJlZml4XG5cblxuICAgICAgICAgIGlmIChwcmV2UmVzdWx0LnNsaWNlKDAsIHByZWZpeExlbmd0aCkgIT09IHByZWZpeCAmJiAhdGFpbFByZWZpeCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGZpcnN0IHRpbWUgdXNlciBlbnRlcmVkIHNvbWV0aGluZ1xuICAgICAgICAgICAgaWYgKG5vSW1tZWRpYXRlUHJlZml4ICYmICFwcmV2UmVzdWx0ICYmIHZhbHVlKSByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgfSBlbHNlIGlmIChwcmV2UmVzdWx0LnNsaWNlKC1wcmVmaXhMZW5ndGgpICE9PSBwcmVmaXggJiYgdGFpbFByZWZpeCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGZpcnN0IHRpbWUgdXNlciBlbnRlcmVkIHNvbWV0aGluZ1xuICAgICAgICAgICAgaWYgKG5vSW1tZWRpYXRlUHJlZml4ICYmICFwcmV2UmVzdWx0ICYmIHZhbHVlKSByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHByZXZWYWx1ZSA9IHRoaXMuc3RyaXBEZWxpbWl0ZXJzKHByZXZSZXN1bHQsIGRlbGltaXRlciwgZGVsaW1pdGVycyk7IC8vIE5ldyB2YWx1ZSBoYXMgaXNzdWUsIHNvbWVvbmUgdHlwZWQgaW4gYmV0d2VlbiBwcmVmaXggbGV0dGVyc1xuICAgICAgICAgIC8vIFJldmVydCB0byBwcmUgdmFsdWVcblxuICAgICAgICAgIGlmICh2YWx1ZS5zbGljZSgwLCBwcmVmaXhMZW5ndGgpICE9PSBwcmVmaXggJiYgIXRhaWxQcmVmaXgpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmV2VmFsdWUuc2xpY2UocHJlZml4TGVuZ3RoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlLnNsaWNlKC1wcmVmaXhMZW5ndGgpICE9PSBwcmVmaXggJiYgdGFpbFByZWZpeCkge1xuICAgICAgICAgICAgcmV0dXJuIHByZXZWYWx1ZS5zbGljZSgwLCAtcHJlZml4TGVuZ3RoIC0gMSk7XG4gICAgICAgICAgfSAvLyBObyBpc3N1ZSwgc3RyaXAgcHJlZml4IGZvciBuZXcgdmFsdWVcblxuXG4gICAgICAgICAgcmV0dXJuIHRhaWxQcmVmaXggPyB2YWx1ZS5zbGljZSgwLCAtcHJlZml4TGVuZ3RoKSA6IHZhbHVlLnNsaWNlKHByZWZpeExlbmd0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEZpcnN0RGlmZkluZGV4OiBmdW5jdGlvbiBnZXRGaXJzdERpZmZJbmRleChwcmV2LCBjdXJyZW50KSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gMDtcblxuICAgICAgICAgIHdoaWxlIChwcmV2LmNoYXJBdChpbmRleCkgPT09IGN1cnJlbnQuY2hhckF0KGluZGV4KSkge1xuICAgICAgICAgICAgaWYgKHByZXYuY2hhckF0KGluZGV4KyspID09PSAnJykge1xuICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9LFxuICAgICAgICBnZXRGb3JtYXR0ZWRWYWx1ZTogZnVuY3Rpb24gZ2V0Rm9ybWF0dGVkVmFsdWUodmFsdWUsIGJsb2NrcywgYmxvY2tzTGVuZ3RoLCBkZWxpbWl0ZXIsIGRlbGltaXRlcnMsIGRlbGltaXRlckxhenlTaG93KSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9ICcnLFxuICAgICAgICAgICAgICBtdWx0aXBsZURlbGltaXRlcnMgPSBkZWxpbWl0ZXJzLmxlbmd0aCA+IDAsXG4gICAgICAgICAgICAgIGN1cnJlbnREZWxpbWl0ZXIgPSAnJzsgLy8gbm8gb3B0aW9ucywgbm9ybWFsIGlucHV0XG5cbiAgICAgICAgICBpZiAoYmxvY2tzTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYmxvY2tzLmZvckVhY2goZnVuY3Rpb24gKGxlbmd0aCwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHZhciBzdWIgPSB2YWx1ZS5zbGljZSgwLCBsZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgcmVzdCA9IHZhbHVlLnNsaWNlKGxlbmd0aCk7XG5cbiAgICAgICAgICAgICAgaWYgKG11bHRpcGxlRGVsaW1pdGVycykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnREZWxpbWl0ZXIgPSBkZWxpbWl0ZXJzW2RlbGltaXRlckxhenlTaG93ID8gaW5kZXggLSAxIDogaW5kZXhdIHx8IGN1cnJlbnREZWxpbWl0ZXI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VycmVudERlbGltaXRlciA9IGRlbGltaXRlcjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChkZWxpbWl0ZXJMYXp5U2hvdykge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBjdXJyZW50RGVsaW1pdGVyO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzdWI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHN1YjtcblxuICAgICAgICAgICAgICAgIGlmIChzdWIubGVuZ3RoID09PSBsZW5ndGggJiYgaW5kZXggPCBibG9ja3NMZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgKz0gY3VycmVudERlbGltaXRlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gLy8gdXBkYXRlIHJlbWFpbmluZyBzdHJpbmdcblxuXG4gICAgICAgICAgICAgIHZhbHVlID0gcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuICAgICAgICAvLyBtb3ZlIGN1cnNvciB0byB0aGUgZW5kXG4gICAgICAgIC8vIHRoZSBmaXJzdCB0aW1lIHVzZXIgZm9jdXNlcyBvbiBhbiBpbnB1dCB3aXRoIHByZWZpeFxuICAgICAgICBmaXhQcmVmaXhDdXJzb3I6IGZ1bmN0aW9uIGZpeFByZWZpeEN1cnNvcihlbCwgcHJlZml4LCBkZWxpbWl0ZXIsIGRlbGltaXRlcnMpIHtcbiAgICAgICAgICBpZiAoIWVsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHZhbCA9IGVsLnZhbHVlLFxuICAgICAgICAgICAgICBhcHBlbmRpeCA9IGRlbGltaXRlciB8fCBkZWxpbWl0ZXJzWzBdIHx8ICcgJztcblxuICAgICAgICAgIGlmICghZWwuc2V0U2VsZWN0aW9uUmFuZ2UgfHwgIXByZWZpeCB8fCBwcmVmaXgubGVuZ3RoICsgYXBwZW5kaXgubGVuZ3RoIDw9IHZhbC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbGVuID0gdmFsLmxlbmd0aCAqIDI7IC8vIHNldCB0aW1lb3V0IHRvIGF2b2lkIGJsaW5rXG5cbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGVsLnNldFNlbGVjdGlvblJhbmdlKGxlbiwgbGVuKTtcbiAgICAgICAgICB9LCAxKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gQ2hlY2sgaWYgaW5wdXQgZmllbGQgaXMgZnVsbHkgc2VsZWN0ZWRcbiAgICAgICAgY2hlY2tGdWxsU2VsZWN0aW9uOiBmdW5jdGlvbiBjaGVja0Z1bGxTZWxlY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKSB8fCBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKSB8fCB7fTtcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3Rpb24udG9TdHJpbmcoKS5sZW5ndGggPT09IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICB9IGNhdGNoIChleCkgey8vIElnbm9yZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0U2VsZWN0aW9uOiBmdW5jdGlvbiBzZXRTZWxlY3Rpb24oZWxlbWVudCwgcG9zaXRpb24sIGRvYykge1xuICAgICAgICAgIGlmIChlbGVtZW50ICE9PSB0aGlzLmdldEFjdGl2ZUVsZW1lbnQoZG9jKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gLy8gY3Vyc29yIGlzIGFscmVhZHkgaW4gdGhlIGVuZFxuXG5cbiAgICAgICAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50LnZhbHVlLmxlbmd0aCA8PSBwb3NpdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChlbGVtZW50LmNyZWF0ZVRleHRSYW5nZSkge1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gZWxlbWVudC5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICAgICAgICAgIHJhbmdlLm1vdmUoJ2NoYXJhY3RlcicsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgIHJhbmdlLnNlbGVjdCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBlbGVtZW50LnNldFNlbGVjdGlvblJhbmdlKHBvc2l0aW9uLCBwb3NpdGlvbik7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RoZSBpbnB1dCBlbGVtZW50IHR5cGUgZG9lcyBub3Qgc3VwcG9ydCBzZWxlY3Rpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldEFjdGl2ZUVsZW1lbnQ6IGZ1bmN0aW9uIGdldEFjdGl2ZUVsZW1lbnQocGFyZW50KSB7XG4gICAgICAgICAgdmFyIGFjdGl2ZUVsZW1lbnQgPSBwYXJlbnQuYWN0aXZlRWxlbWVudDtcblxuICAgICAgICAgIGlmIChhY3RpdmVFbGVtZW50ICYmIGFjdGl2ZUVsZW1lbnQuc2hhZG93Um9vdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWN0aXZlRWxlbWVudChhY3RpdmVFbGVtZW50LnNoYWRvd1Jvb3QpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBhY3RpdmVFbGVtZW50O1xuICAgICAgICB9LFxuICAgICAgICBpc0FuZHJvaWQ6IGZ1bmN0aW9uIGlzQW5kcm9pZCgpIHtcbiAgICAgICAgICByZXR1cm4gbmF2aWdhdG9yICYmIC9hbmRyb2lkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gT24gQW5kcm9pZCBjaHJvbWUsIHRoZSBrZXl1cCBhbmQga2V5ZG93biBldmVudHNcbiAgICAgICAgLy8gYWx3YXlzIHJldHVybiBrZXkgY29kZSAyMjkgYXMgYSBjb21wb3NpdGlvbiB0aGF0XG4gICAgICAgIC8vIGJ1ZmZlcnMgdGhlIHVzZXLigJlzIGtleXN0cm9rZXNcbiAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub3Npci9jbGVhdmUuanMvaXNzdWVzLzE0N1xuICAgICAgICBpc0FuZHJvaWRCYWNrc3BhY2VLZXlkb3duOiBmdW5jdGlvbiBpc0FuZHJvaWRCYWNrc3BhY2VLZXlkb3duKGxhc3RJbnB1dFZhbHVlLCBjdXJyZW50SW5wdXRWYWx1ZSkge1xuICAgICAgICAgIGlmICghdGhpcy5pc0FuZHJvaWQoKSB8fCAhbGFzdElucHV0VmFsdWUgfHwgIWN1cnJlbnRJbnB1dFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRJbnB1dFZhbHVlID09PSBsYXN0SW5wdXRWYWx1ZS5zbGljZSgwLCAtMSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IFV0aWw7XG4gICAgICAvKioqL1xuICAgIH0sXG4gICAgLyogMTUgKi9cblxuICAgIC8qKiovXG4gICAgZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgJ3VzZSBzdHJpY3QnO1xuICAgICAgLyoqXG4gICAgICAgKiBQcm9wcyBBc3NpZ25tZW50XG4gICAgICAgKlxuICAgICAgICogU2VwYXJhdGUgdGhpcywgc28gcmVhY3QgbW9kdWxlIGNhbiBzaGFyZSB0aGUgdXNhZ2VcbiAgICAgICAqL1xuXG4gICAgICB2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICAgIH0gOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgICAgfTtcblxuICAgICAgdmFyIERlZmF1bHRQcm9wZXJ0aWVzID0ge1xuICAgICAgICAvLyBNYXliZSBjaGFuZ2UgdG8gb2JqZWN0LWFzc2lnblxuICAgICAgICAvLyBmb3Igbm93IGp1c3Qga2VlcCBpdCBhcyBzaW1wbGVcbiAgICAgICAgYXNzaWduOiBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBvcHRzKSB7XG4gICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IHt9O1xuICAgICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9OyAvLyBjcmVkaXQgY2FyZFxuXG4gICAgICAgICAgdGFyZ2V0LmNyZWRpdENhcmQgPSAhIW9wdHMuY3JlZGl0Q2FyZDtcbiAgICAgICAgICB0YXJnZXQuY3JlZGl0Q2FyZFN0cmljdE1vZGUgPSAhIW9wdHMuY3JlZGl0Q2FyZFN0cmljdE1vZGU7XG4gICAgICAgICAgdGFyZ2V0LmNyZWRpdENhcmRUeXBlID0gJyc7XG5cbiAgICAgICAgICB0YXJnZXQub25DcmVkaXRDYXJkVHlwZUNoYW5nZWQgPSBvcHRzLm9uQ3JlZGl0Q2FyZFR5cGVDaGFuZ2VkIHx8IGZ1bmN0aW9uICgpIHt9OyAvLyBwaG9uZVxuXG5cbiAgICAgICAgICB0YXJnZXQucGhvbmUgPSAhIW9wdHMucGhvbmU7XG4gICAgICAgICAgdGFyZ2V0LnBob25lUmVnaW9uQ29kZSA9IG9wdHMucGhvbmVSZWdpb25Db2RlIHx8ICdBVSc7XG4gICAgICAgICAgdGFyZ2V0LnBob25lRm9ybWF0dGVyID0ge307IC8vIHRpbWVcblxuICAgICAgICAgIHRhcmdldC50aW1lID0gISFvcHRzLnRpbWU7XG4gICAgICAgICAgdGFyZ2V0LnRpbWVQYXR0ZXJuID0gb3B0cy50aW1lUGF0dGVybiB8fCBbJ2gnLCAnbScsICdzJ107XG4gICAgICAgICAgdGFyZ2V0LnRpbWVGb3JtYXQgPSBvcHRzLnRpbWVGb3JtYXQgfHwgJzI0JztcbiAgICAgICAgICB0YXJnZXQudGltZUZvcm1hdHRlciA9IHt9OyAvLyBkYXRlXG5cbiAgICAgICAgICB0YXJnZXQuZGF0ZSA9ICEhb3B0cy5kYXRlO1xuICAgICAgICAgIHRhcmdldC5kYXRlUGF0dGVybiA9IG9wdHMuZGF0ZVBhdHRlcm4gfHwgWydkJywgJ20nLCAnWSddO1xuICAgICAgICAgIHRhcmdldC5kYXRlTWluID0gb3B0cy5kYXRlTWluIHx8ICcnO1xuICAgICAgICAgIHRhcmdldC5kYXRlTWF4ID0gb3B0cy5kYXRlTWF4IHx8ICcnO1xuICAgICAgICAgIHRhcmdldC5kYXRlRm9ybWF0dGVyID0ge307IC8vIG51bWVyYWxcblxuICAgICAgICAgIHRhcmdldC5udW1lcmFsID0gISFvcHRzLm51bWVyYWw7XG4gICAgICAgICAgdGFyZ2V0Lm51bWVyYWxJbnRlZ2VyU2NhbGUgPSBvcHRzLm51bWVyYWxJbnRlZ2VyU2NhbGUgPiAwID8gb3B0cy5udW1lcmFsSW50ZWdlclNjYWxlIDogMDtcbiAgICAgICAgICB0YXJnZXQubnVtZXJhbERlY2ltYWxTY2FsZSA9IG9wdHMubnVtZXJhbERlY2ltYWxTY2FsZSA+PSAwID8gb3B0cy5udW1lcmFsRGVjaW1hbFNjYWxlIDogMjtcbiAgICAgICAgICB0YXJnZXQubnVtZXJhbERlY2ltYWxNYXJrID0gb3B0cy5udW1lcmFsRGVjaW1hbE1hcmsgfHwgJy4nO1xuICAgICAgICAgIHRhcmdldC5udW1lcmFsVGhvdXNhbmRzR3JvdXBTdHlsZSA9IG9wdHMubnVtZXJhbFRob3VzYW5kc0dyb3VwU3R5bGUgfHwgJ3Rob3VzYW5kJztcbiAgICAgICAgICB0YXJnZXQubnVtZXJhbFBvc2l0aXZlT25seSA9ICEhb3B0cy5udW1lcmFsUG9zaXRpdmVPbmx5O1xuICAgICAgICAgIHRhcmdldC5zdHJpcExlYWRpbmdaZXJvZXMgPSBvcHRzLnN0cmlwTGVhZGluZ1plcm9lcyAhPT0gZmFsc2U7XG4gICAgICAgICAgdGFyZ2V0LnNpZ25CZWZvcmVQcmVmaXggPSAhIW9wdHMuc2lnbkJlZm9yZVByZWZpeDtcbiAgICAgICAgICB0YXJnZXQudGFpbFByZWZpeCA9ICEhb3B0cy50YWlsUHJlZml4OyAvLyBvdGhlcnNcblxuICAgICAgICAgIHRhcmdldC5zd2FwSGlkZGVuSW5wdXQgPSAhIW9wdHMuc3dhcEhpZGRlbklucHV0O1xuICAgICAgICAgIHRhcmdldC5udW1lcmljT25seSA9IHRhcmdldC5jcmVkaXRDYXJkIHx8IHRhcmdldC5kYXRlIHx8ICEhb3B0cy5udW1lcmljT25seTtcbiAgICAgICAgICB0YXJnZXQudXBwZXJjYXNlID0gISFvcHRzLnVwcGVyY2FzZTtcbiAgICAgICAgICB0YXJnZXQubG93ZXJjYXNlID0gISFvcHRzLmxvd2VyY2FzZTtcbiAgICAgICAgICB0YXJnZXQucHJlZml4ID0gdGFyZ2V0LmNyZWRpdENhcmQgfHwgdGFyZ2V0LmRhdGUgPyAnJyA6IG9wdHMucHJlZml4IHx8ICcnO1xuICAgICAgICAgIHRhcmdldC5ub0ltbWVkaWF0ZVByZWZpeCA9ICEhb3B0cy5ub0ltbWVkaWF0ZVByZWZpeDtcbiAgICAgICAgICB0YXJnZXQucHJlZml4TGVuZ3RoID0gdGFyZ2V0LnByZWZpeC5sZW5ndGg7XG4gICAgICAgICAgdGFyZ2V0LnJhd1ZhbHVlVHJpbVByZWZpeCA9ICEhb3B0cy5yYXdWYWx1ZVRyaW1QcmVmaXg7XG4gICAgICAgICAgdGFyZ2V0LmNvcHlEZWxpbWl0ZXIgPSAhIW9wdHMuY29weURlbGltaXRlcjtcbiAgICAgICAgICB0YXJnZXQuaW5pdFZhbHVlID0gb3B0cy5pbml0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiBvcHRzLmluaXRWYWx1ZSAhPT0gbnVsbCA/IG9wdHMuaW5pdFZhbHVlLnRvU3RyaW5nKCkgOiAnJztcbiAgICAgICAgICB0YXJnZXQuZGVsaW1pdGVyID0gb3B0cy5kZWxpbWl0ZXIgfHwgb3B0cy5kZWxpbWl0ZXIgPT09ICcnID8gb3B0cy5kZWxpbWl0ZXIgOiBvcHRzLmRhdGUgPyAnLycgOiBvcHRzLnRpbWUgPyAnOicgOiBvcHRzLm51bWVyYWwgPyAnLCcgOiBvcHRzLnBob25lID8gJyAnIDogJyAnO1xuICAgICAgICAgIHRhcmdldC5kZWxpbWl0ZXJMZW5ndGggPSB0YXJnZXQuZGVsaW1pdGVyLmxlbmd0aDtcbiAgICAgICAgICB0YXJnZXQuZGVsaW1pdGVyTGF6eVNob3cgPSAhIW9wdHMuZGVsaW1pdGVyTGF6eVNob3c7XG4gICAgICAgICAgdGFyZ2V0LmRlbGltaXRlcnMgPSBvcHRzLmRlbGltaXRlcnMgfHwgW107XG4gICAgICAgICAgdGFyZ2V0LmJsb2NrcyA9IG9wdHMuYmxvY2tzIHx8IFtdO1xuICAgICAgICAgIHRhcmdldC5ibG9ja3NMZW5ndGggPSB0YXJnZXQuYmxvY2tzLmxlbmd0aDtcbiAgICAgICAgICB0YXJnZXQucm9vdCA9ICh0eXBlb2YgZ2xvYmFsID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihnbG9iYWwpKSA9PT0gJ29iamVjdCcgJiYgZ2xvYmFsID8gZ2xvYmFsIDogd2luZG93O1xuICAgICAgICAgIHRhcmdldC5kb2N1bWVudCA9IG9wdHMuZG9jdW1lbnQgfHwgdGFyZ2V0LnJvb3QuZG9jdW1lbnQ7XG4gICAgICAgICAgdGFyZ2V0Lm1heExlbmd0aCA9IDA7XG4gICAgICAgICAgdGFyZ2V0LmJhY2tzcGFjZSA9IGZhbHNlO1xuICAgICAgICAgIHRhcmdldC5yZXN1bHQgPSAnJztcblxuICAgICAgICAgIHRhcmdldC5vblZhbHVlQ2hhbmdlZCA9IG9wdHMub25WYWx1ZUNoYW5nZWQgfHwgZnVuY3Rpb24gKCkge307XG5cbiAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBEZWZhdWx0UHJvcGVydGllcztcbiAgICAgIC8qKiovXG4gICAgfVxuICAgIC8qKioqKiovXG4gICAgXSlcbiAgKTtcbn0pO1xuXG47Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///M/dN\n")},cttA:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.reduce.js\nvar es_array_reduce = __webpack_require__("E9XD");\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js\nvar defineProperty = __webpack_require__("rePB");\n\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__("q1tI");\nvar react_default = /*#__PURE__*/__webpack_require__.n(react);\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/regenerator/index.js\nvar regenerator = __webpack_require__("o0o1");\nvar regenerator_default = /*#__PURE__*/__webpack_require__.n(regenerator);\n\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i["return"] != null) _i["return"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js\nvar unsupportedIterableToArray = __webpack_require__("BsWD");\n\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js\nfunction _nonIterableRest() {\n  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");\n}\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js\n\n\n\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || Object(unsupportedIterableToArray["a" /* default */])(arr, i) || _nonIterableRest();\n}\n// EXTERNAL MODULE: ./node_modules/regenerator-runtime/runtime.js\nvar runtime = __webpack_require__("ls82");\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\nvar asyncToGenerator = __webpack_require__("HaE+");\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js + 3 modules\nvar toConsumableArray = __webpack_require__("KQm4");\n\n// CONCATENATED MODULE: ./node_modules/react-hook-form/dist/index.esm.js\n\n\n\n\n\n\n\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n\n\nvar isHTMLElement = function isHTMLElement(value) {\n  return value instanceof HTMLElement;\n};\n\nvar EVENTS = {\n  BLUR: \'blur\',\n  CHANGE: \'change\',\n  INPUT: \'input\'\n};\nvar VALIDATION_MODE = {\n  onBlur: \'onBlur\',\n  onChange: \'onChange\',\n  onSubmit: \'onSubmit\',\n  onTouched: \'onTouched\',\n  all: \'all\'\n};\nvar SELECT = \'select\';\nvar UNDEFINED = \'undefined\';\nvar INPUT_VALIDATION_RULES = {\n  max: \'max\',\n  min: \'min\',\n  maxLength: \'maxLength\',\n  minLength: \'minLength\',\n  pattern: \'pattern\',\n  required: \'required\',\n  validate: \'validate\'\n};\n\nfunction attachEventListeners(_ref, shouldAttachChangeEvent, handleChange) {\n  var ref = _ref.ref;\n\n  if (isHTMLElement(ref) && handleChange) {\n    ref.addEventListener(shouldAttachChangeEvent ? EVENTS.CHANGE : EVENTS.INPUT, handleChange);\n    ref.addEventListener(EVENTS.BLUR, handleChange);\n  }\n}\n\nvar isNullOrUndefined = function isNullOrUndefined(value) {\n  return value == null;\n};\n\nvar isObjectType = function isObjectType(value) {\n  return typeof value === \'object\';\n};\n\nvar isObject = function isObject(value) {\n  return !isNullOrUndefined(value) && !Array.isArray(value) && isObjectType(value) && !(value instanceof Date);\n};\n\nvar isKey = function isKey(value) {\n  return /^\\w*$/.test(value);\n};\n\nvar compact = function compact(value) {\n  return value.filter(Boolean);\n};\n\nvar stringToPath = function stringToPath(input) {\n  return compact(input.replace(/["|\']/g, \'\').replace(/\\[/g, \'.\').replace(/\\]/g, \'\').split(\'.\'));\n};\n\nfunction set(object, path, value) {\n  var index = -1;\n  var tempPath = isKey(path) ? [path] : stringToPath(path);\n  var length = tempPath.length;\n  var lastIndex = length - 1;\n\n  while (++index < length) {\n    var key = tempPath[index];\n    var newValue = value;\n\n    if (index !== lastIndex) {\n      var objValue = object[key];\n      newValue = isObject(objValue) || Array.isArray(objValue) ? objValue : !isNaN(+tempPath[index + 1]) ? [] : {};\n    }\n\n    object[key] = newValue;\n    object = object[key];\n  }\n\n  return object;\n}\n\nvar transformToNestObject = function transformToNestObject(data) {\n  var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  for (var key in data) {\n    !isKey(key) ? set(value, key, data[key]) : value[key] = data[key];\n  }\n\n  return value;\n};\n\nvar isUndefined = function isUndefined(val) {\n  return val === undefined;\n};\n\nvar get = function get() {\n  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var path = arguments.length > 1 ? arguments[1] : undefined;\n  var defaultValue = arguments.length > 2 ? arguments[2] : undefined;\n  var result = compact(path.split(/[,[\\].]+?/)).reduce(function (result, key) {\n    return isNullOrUndefined(result) ? result : result[key];\n  }, obj);\n  return isUndefined(result) || result === obj ? isUndefined(obj[path]) ? defaultValue : obj[path] : result;\n};\n\nvar focusOnErrorField = function focusOnErrorField(fields, fieldErrors) {\n  for (var key in fields) {\n    if (get(fieldErrors, key)) {\n      var field = fields[key];\n\n      if (field) {\n        if (field.ref.focus && isUndefined(field.ref.focus())) {\n          break;\n        } else if (field.options) {\n          field.options[0].ref.focus();\n          break;\n        }\n      }\n    }\n  }\n};\n\nvar removeAllEventListeners = function removeAllEventListeners(ref, validateWithStateUpdate) {\n  if (isHTMLElement(ref) && ref.removeEventListener) {\n    ref.removeEventListener(EVENTS.INPUT, validateWithStateUpdate);\n    ref.removeEventListener(EVENTS.CHANGE, validateWithStateUpdate);\n    ref.removeEventListener(EVENTS.BLUR, validateWithStateUpdate);\n  }\n};\n\nvar defaultReturn = {\n  isValid: false,\n  value: \'\'\n};\n\nvar getRadioValue = function getRadioValue(options) {\n  return Array.isArray(options) ? options.reduce(function (previous, option) {\n    return option && option.ref.checked ? {\n      isValid: true,\n      value: option.ref.value\n    } : previous;\n  }, defaultReturn) : defaultReturn;\n};\n\nvar index_esm_getMultipleSelectValue = function getMultipleSelectValue(options) {\n  return Object(toConsumableArray["a" /* default */])(options).filter(function (_ref2) {\n    var selected = _ref2.selected;\n    return selected;\n  }).map(function (_ref3) {\n    var value = _ref3.value;\n    return value;\n  });\n};\n\nvar isRadioInput = function isRadioInput(element) {\n  return element.type === \'radio\';\n};\n\nvar isFileInput = function isFileInput(element) {\n  return element.type === \'file\';\n};\n\nvar isCheckBoxInput = function isCheckBoxInput(element) {\n  return element.type === \'checkbox\';\n};\n\nvar isMultipleSelect = function isMultipleSelect(element) {\n  return element.type === "".concat(SELECT, "-multiple");\n};\n\nvar defaultResult = {\n  value: false,\n  isValid: false\n};\nvar validResult = {\n  value: true,\n  isValid: true\n};\n\nvar getCheckboxValue = function getCheckboxValue(options) {\n  if (Array.isArray(options)) {\n    if (options.length > 1) {\n      var values = options.filter(function (option) {\n        return option && option.ref.checked;\n      }).map(function (_ref4) {\n        var value = _ref4.ref.value;\n        return value;\n      });\n      return {\n        value: values,\n        isValid: !!values.length\n      };\n    }\n\n    var _options$0$ref = options[0].ref,\n        checked = _options$0$ref.checked,\n        value = _options$0$ref.value,\n        attributes = _options$0$ref.attributes;\n    return checked ? attributes && !isUndefined(attributes.value) ? isUndefined(value) || value === \'\' ? validResult : {\n      value: value,\n      isValid: true\n    } : validResult : defaultResult;\n  }\n\n  return defaultResult;\n};\n\nfunction getFieldValue(fieldsRef, name, shallowFieldsStateRef, excludeDisabled) {\n  var field = fieldsRef.current[name];\n\n  if (field) {\n    var _field$ref = field.ref,\n        value = _field$ref.value,\n        disabled = _field$ref.disabled,\n        ref = field.ref,\n        valueAsNumber = field.valueAsNumber,\n        valueAsDate = field.valueAsDate,\n        setValueAs = field.setValueAs;\n\n    if (disabled && excludeDisabled) {\n      return;\n    }\n\n    if (isFileInput(ref)) {\n      return ref.files;\n    }\n\n    if (isRadioInput(ref)) {\n      return getRadioValue(field.options).value;\n    }\n\n    if (isMultipleSelect(ref)) {\n      return index_esm_getMultipleSelectValue(ref.options);\n    }\n\n    if (isCheckBoxInput(ref)) {\n      return getCheckboxValue(field.options).value;\n    }\n\n    return valueAsNumber ? +value : valueAsDate ? ref.valueAsDate : setValueAs ? setValueAs(value) : value;\n  }\n\n  if (shallowFieldsStateRef) {\n    return get(shallowFieldsStateRef.current, name);\n  }\n}\n\nfunction isDetached(element) {\n  if (!element) {\n    return true;\n  }\n\n  if (!(element instanceof HTMLElement) || element.nodeType === Node.DOCUMENT_NODE) {\n    return false;\n  }\n\n  return isDetached(element.parentNode);\n}\n\nvar isEmptyObject = function isEmptyObject(value) {\n  return isObject(value) && !Object.keys(value).length;\n};\n\nvar isBoolean = function isBoolean(value) {\n  return typeof value === \'boolean\';\n};\n\nfunction baseGet(object, updatePath) {\n  var path = updatePath.slice(0, -1);\n  var length = path.length;\n  var index = 0;\n\n  while (index < length) {\n    object = isUndefined(object) ? index++ : object[updatePath[index++]];\n  }\n\n  return object;\n}\n\nfunction unset(object, path) {\n  var updatePath = isKey(path) ? [path] : stringToPath(path);\n  var childObject = updatePath.length == 1 ? object : baseGet(object, updatePath);\n  var key = updatePath[updatePath.length - 1];\n  var previousObjRef = undefined;\n\n  if (childObject) {\n    delete childObject[key];\n  }\n\n  for (var k = 0; k < updatePath.slice(0, -1).length; k++) {\n    var index = -1;\n    var objectRef = undefined;\n    var currentPaths = updatePath.slice(0, -(k + 1));\n    var currentPathsLength = currentPaths.length - 1;\n\n    if (k > 0) {\n      previousObjRef = object;\n    }\n\n    while (++index < currentPaths.length) {\n      var item = currentPaths[index];\n      objectRef = objectRef ? objectRef[item] : object[item];\n\n      if (currentPathsLength === index && (isObject(objectRef) && isEmptyObject(objectRef) || Array.isArray(objectRef) && !objectRef.filter(function (data) {\n        return isObject(data) && !isEmptyObject(data) || isBoolean(data);\n      }).length)) {\n        previousObjRef ? delete previousObjRef[item] : delete object[item];\n      }\n\n      previousObjRef = objectRef;\n    }\n  }\n\n  return object;\n}\n\nvar isSameRef = function isSameRef(fieldValue, ref) {\n  return fieldValue && fieldValue.ref === ref;\n};\n\nfunction findRemovedFieldAndRemoveListener(fieldsRef, handleChange, field, shallowFieldsStateRef, shouldUnregister, forceDelete) {\n  var ref = field.ref,\n      name = field.ref.name;\n  var fieldRef = fieldsRef.current[name];\n\n  if (!shouldUnregister) {\n    var value = getFieldValue(fieldsRef, name, shallowFieldsStateRef);\n    !isUndefined(value) && set(shallowFieldsStateRef.current, name, value);\n  }\n\n  if (!ref.type || !fieldRef) {\n    delete fieldsRef.current[name];\n    return;\n  }\n\n  if (isRadioInput(ref) || isCheckBoxInput(ref)) {\n    if (Array.isArray(fieldRef.options) && fieldRef.options.length) {\n      compact(fieldRef.options).forEach(function () {\n        var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var index = arguments.length > 1 ? arguments[1] : undefined;\n\n        if (isDetached(option.ref) && isSameRef(option, option.ref) || forceDelete) {\n          removeAllEventListeners(option.ref, handleChange);\n          unset(fieldRef.options, "[".concat(index, "]"));\n        }\n      });\n\n      if (fieldRef.options && !compact(fieldRef.options).length) {\n        delete fieldsRef.current[name];\n      }\n    } else {\n      delete fieldsRef.current[name];\n    }\n  } else if (isDetached(ref) && isSameRef(fieldRef, ref) || forceDelete) {\n    removeAllEventListeners(ref, handleChange);\n    delete fieldsRef.current[name];\n  }\n}\n\nvar isPrimitive = function isPrimitive(value) {\n  return isNullOrUndefined(value) || !isObjectType(value);\n};\n\nfunction deepMerge(target, source) {\n  if (isPrimitive(target) || isPrimitive(source)) {\n    return source;\n  }\n\n  for (var key in source) {\n    var targetValue = target[key];\n    var sourceValue = source[key];\n\n    try {\n      target[key] = isObject(targetValue) && isObject(sourceValue) || Array.isArray(targetValue) && Array.isArray(sourceValue) ? deepMerge(targetValue, sourceValue) : sourceValue;\n    } catch (_a) {}\n  }\n\n  return target;\n}\n\nfunction setDirtyFields(values, defaultValues, dirtyFields, parentNode, parentName) {\n  var index = -1;\n\n  while (++index < values.length) {\n    for (var key in values[index]) {\n      if (Array.isArray(values[index][key])) {\n        !dirtyFields[index] && (dirtyFields[index] = {});\n        dirtyFields[index][key] = [];\n        setDirtyFields(values[index][key], get(defaultValues[index] || {}, key, []), dirtyFields[index][key], dirtyFields[index], key);\n      } else {\n        get(defaultValues[index] || {}, key) === values[index][key] ? set(dirtyFields[index] || {}, key) : dirtyFields[index] = Object.assign(Object.assign({}, dirtyFields[index]), Object(defineProperty["a" /* default */])({}, key, true));\n      }\n    }\n\n    parentNode && !dirtyFields.length && delete parentNode[parentName];\n  }\n\n  return dirtyFields;\n}\n\nvar setFieldArrayDirtyFields = function setFieldArrayDirtyFields(values, defaultValues, dirtyFields) {\n  return deepMerge(setDirtyFields(values, defaultValues, dirtyFields), setDirtyFields(defaultValues, values, dirtyFields));\n};\n\nvar isString = function isString(value) {\n  return typeof value === \'string\';\n};\n\nvar getFieldsValues = function getFieldsValues(fieldsRef, shallowFieldsState, shouldUnregister, excludeDisabled, search) {\n  var output = {};\n\n  var _loop = function _loop(name) {\n    if (isUndefined(search) || (isString(search) ? name.startsWith(search) : Array.isArray(search) && search.find(function (data) {\n      return name.startsWith(data);\n    }))) {\n      output[name] = getFieldValue(fieldsRef, name, undefined, excludeDisabled);\n    }\n  };\n\n  for (var name in fieldsRef.current) {\n    _loop(name);\n  }\n\n  return shouldUnregister ? transformToNestObject(output) : deepMerge(shallowFieldsState, transformToNestObject(output));\n};\n\nfunction deepEqual(object1, object2, isErrorObject) {\n  if (isPrimitive(object1) || isPrimitive(object2) || object1 instanceof Date || object2 instanceof Date) {\n    return object1 === object2;\n  }\n\n  if (!Object(react["isValidElement"])(object1)) {\n    var keys1 = Object.keys(object1);\n    var keys2 = Object.keys(object2);\n\n    if (keys1.length !== keys2.length) {\n      return false;\n    }\n\n    for (var _i = 0, _keys = keys1; _i < _keys.length; _i++) {\n      var key = _keys[_i];\n      var val1 = object1[key];\n\n      if (!(isErrorObject && key === \'ref\')) {\n        var val2 = object2[key];\n\n        if ((isObject(val1) || Array.isArray(val1)) && (isObject(val2) || Array.isArray(val2)) ? !deepEqual(val1, val2, isErrorObject) : val1 !== val2) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n\nvar isErrorStateChanged = function isErrorStateChanged(_ref5) {\n  var errors = _ref5.errors,\n      name = _ref5.name,\n      error = _ref5.error,\n      validFields = _ref5.validFields,\n      fieldsWithValidation = _ref5.fieldsWithValidation;\n  var isValid = isUndefined(error);\n  var previousError = get(errors, name);\n  return isValid && !!previousError || !isValid && !deepEqual(previousError, error, true) || isValid && get(fieldsWithValidation, name) && !get(validFields, name);\n};\n\nvar isRegex = function isRegex(value) {\n  return value instanceof RegExp;\n};\n\nvar getValueAndMessage = function getValueAndMessage(validationData) {\n  return isObject(validationData) && !isRegex(validationData) ? validationData : {\n    value: validationData,\n    message: \'\'\n  };\n};\n\nvar isFunction = function isFunction(value) {\n  return typeof value === \'function\';\n};\n\nvar index_esm_isMessage = function isMessage(value) {\n  return isString(value) || Object(react["isValidElement"])(value);\n};\n\nfunction getValidateError(result, ref) {\n  var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \'validate\';\n\n  if (index_esm_isMessage(result) || isBoolean(result) && !result) {\n    return {\n      type: type,\n      message: index_esm_isMessage(result) ? result : \'\',\n      ref: ref\n    };\n  }\n}\n\nvar index_esm_appendErrors = function appendErrors(name, validateAllFieldCriteria, errors, type, message) {\n  return validateAllFieldCriteria ? Object.assign(Object.assign({}, errors[name]), {\n    types: Object.assign(Object.assign({}, errors[name] && errors[name].types ? errors[name].types : {}), Object(defineProperty["a" /* default */])({}, type, message || true))\n  }) : {};\n};\n\nvar validateField = /*#__PURE__*/function () {\n  var _ref7 = Object(asyncToGenerator["a" /* default */])( /*#__PURE__*/regenerator_default.a.mark(function _callee(fieldsRef, validateAllFieldCriteria, _ref6, shallowFieldsStateRef) {\n    var ref, value, options, required, maxLength, minLength, min, max, pattern, validate, name, error, isRadio, isCheckBox, isRadioOrCheckbox, isEmpty, appendErrorsCurry, getMinMaxMessage, _ref8, _value, message, exceedMax, exceedMin, maxOutput, minOutput, valueNumber, valueDate, maxLengthOutput, minLengthOutput, _exceedMax, _exceedMin, _getValueAndMessage, patternValue, _message, fieldValue, validateRef, result, validateError, validationResult, _i2, _Object$entries, _Object$entries$_i, key, validateFunction, validateResult, _validateError;\n\n    return regenerator_default.a.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            ref = _ref6.ref, value = _ref6.ref.value, options = _ref6.options, required = _ref6.required, maxLength = _ref6.maxLength, minLength = _ref6.minLength, min = _ref6.min, max = _ref6.max, pattern = _ref6.pattern, validate = _ref6.validate;\n            name = ref.name;\n            error = {};\n            isRadio = isRadioInput(ref);\n            isCheckBox = isCheckBoxInput(ref);\n            isRadioOrCheckbox = isRadio || isCheckBox;\n            isEmpty = value === \'\';\n            appendErrorsCurry = index_esm_appendErrors.bind(null, name, validateAllFieldCriteria, error);\n\n            getMinMaxMessage = function getMinMaxMessage(exceedMax, maxLengthMessage, minLengthMessage) {\n              var maxType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : INPUT_VALIDATION_RULES.maxLength;\n              var minType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : INPUT_VALIDATION_RULES.minLength;\n              var message = exceedMax ? maxLengthMessage : minLengthMessage;\n              error[name] = Object.assign({\n                type: exceedMax ? maxType : minType,\n                message: message,\n                ref: ref\n              }, exceedMax ? appendErrorsCurry(maxType, message) : appendErrorsCurry(minType, message));\n            };\n\n            if (!(required && (!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(value)) || isBoolean(value) && !value || isCheckBox && !getCheckboxValue(options).isValid || isRadio && !getRadioValue(options).isValid))) {\n              _context.next = 15;\n              break;\n            }\n\n            _ref8 = index_esm_isMessage(required) ? {\n              value: !!required,\n              message: required\n            } : getValueAndMessage(required), _value = _ref8.value, message = _ref8.message;\n\n            if (!_value) {\n              _context.next = 15;\n              break;\n            }\n\n            error[name] = Object.assign({\n              type: INPUT_VALIDATION_RULES.required,\n              message: message,\n              ref: isRadioOrCheckbox ? ((fieldsRef.current[name].options || [])[0] || {}).ref : ref\n            }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, message));\n\n            if (validateAllFieldCriteria) {\n              _context.next = 15;\n              break;\n            }\n\n            return _context.abrupt("return", error);\n\n          case 15:\n            if (!((!isNullOrUndefined(min) || !isNullOrUndefined(max)) && value !== \'\')) {\n              _context.next = 23;\n              break;\n            }\n\n            maxOutput = getValueAndMessage(max);\n            minOutput = getValueAndMessage(min);\n\n            if (!isNaN(value)) {\n              valueNumber = ref.valueAsNumber || parseFloat(value);\n\n              if (!isNullOrUndefined(maxOutput.value)) {\n                exceedMax = valueNumber > maxOutput.value;\n              }\n\n              if (!isNullOrUndefined(minOutput.value)) {\n                exceedMin = valueNumber < minOutput.value;\n              }\n            } else {\n              valueDate = ref.valueAsDate || new Date(value);\n\n              if (isString(maxOutput.value)) {\n                exceedMax = valueDate > new Date(maxOutput.value);\n              }\n\n              if (isString(minOutput.value)) {\n                exceedMin = valueDate < new Date(minOutput.value);\n              }\n            }\n\n            if (!(exceedMax || exceedMin)) {\n              _context.next = 23;\n              break;\n            }\n\n            getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\n\n            if (validateAllFieldCriteria) {\n              _context.next = 23;\n              break;\n            }\n\n            return _context.abrupt("return", error);\n\n          case 23:\n            if (!(isString(value) && !isEmpty && (maxLength || minLength))) {\n              _context.next = 32;\n              break;\n            }\n\n            maxLengthOutput = getValueAndMessage(maxLength);\n            minLengthOutput = getValueAndMessage(minLength);\n            _exceedMax = !isNullOrUndefined(maxLengthOutput.value) && value.length > maxLengthOutput.value;\n            _exceedMin = !isNullOrUndefined(minLengthOutput.value) && value.length < minLengthOutput.value;\n\n            if (!(_exceedMax || _exceedMin)) {\n              _context.next = 32;\n              break;\n            }\n\n            getMinMaxMessage(_exceedMax, maxLengthOutput.message, minLengthOutput.message);\n\n            if (validateAllFieldCriteria) {\n              _context.next = 32;\n              break;\n            }\n\n            return _context.abrupt("return", error);\n\n          case 32:\n            if (!(pattern && !isEmpty)) {\n              _context.next = 38;\n              break;\n            }\n\n            _getValueAndMessage = getValueAndMessage(pattern), patternValue = _getValueAndMessage.value, _message = _getValueAndMessage.message;\n\n            if (!(isRegex(patternValue) && !patternValue.test(value))) {\n              _context.next = 38;\n              break;\n            }\n\n            error[name] = Object.assign({\n              type: INPUT_VALIDATION_RULES.pattern,\n              message: _message,\n              ref: ref\n            }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, _message));\n\n            if (validateAllFieldCriteria) {\n              _context.next = 38;\n              break;\n            }\n\n            return _context.abrupt("return", error);\n\n          case 38:\n            if (!validate) {\n              _context.next = 71;\n              break;\n            }\n\n            fieldValue = getFieldValue(fieldsRef, name, shallowFieldsStateRef);\n            validateRef = isRadioOrCheckbox && options ? options[0].ref : ref;\n\n            if (!isFunction(validate)) {\n              _context.next = 52;\n              break;\n            }\n\n            _context.next = 44;\n            return validate(fieldValue);\n\n          case 44:\n            result = _context.sent;\n            validateError = getValidateError(result, validateRef);\n\n            if (!validateError) {\n              _context.next = 50;\n              break;\n            }\n\n            error[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));\n\n            if (validateAllFieldCriteria) {\n              _context.next = 50;\n              break;\n            }\n\n            return _context.abrupt("return", error);\n\n          case 50:\n            _context.next = 71;\n            break;\n\n          case 52:\n            if (!isObject(validate)) {\n              _context.next = 71;\n              break;\n            }\n\n            validationResult = {};\n            _i2 = 0, _Object$entries = Object.entries(validate);\n\n          case 55:\n            if (!(_i2 < _Object$entries.length)) {\n              _context.next = 67;\n              break;\n            }\n\n            _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2), key = _Object$entries$_i[0], validateFunction = _Object$entries$_i[1];\n\n            if (!(!isEmptyObject(validationResult) && !validateAllFieldCriteria)) {\n              _context.next = 59;\n              break;\n            }\n\n            return _context.abrupt("break", 67);\n\n          case 59:\n            _context.next = 61;\n            return validateFunction(fieldValue);\n\n          case 61:\n            validateResult = _context.sent;\n            _validateError = getValidateError(validateResult, validateRef, key);\n\n            if (_validateError) {\n              validationResult = Object.assign(Object.assign({}, _validateError), appendErrorsCurry(key, _validateError.message));\n\n              if (validateAllFieldCriteria) {\n                error[name] = validationResult;\n              }\n            }\n\n          case 64:\n            _i2++;\n            _context.next = 55;\n            break;\n\n          case 67:\n            if (isEmptyObject(validationResult)) {\n              _context.next = 71;\n              break;\n            }\n\n            error[name] = Object.assign({\n              ref: validateRef\n            }, validationResult);\n\n            if (validateAllFieldCriteria) {\n              _context.next = 71;\n              break;\n            }\n\n            return _context.abrupt("return", error);\n\n          case 71:\n            return _context.abrupt("return", error);\n\n          case 72:\n          case "end":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function validateField(_x, _x2, _x3, _x4) {\n    return _ref7.apply(this, arguments);\n  };\n}();\n\nvar getPath = function getPath(rootPath, values) {\n  var paths = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n  for (var property in values) {\n    var rootName = rootPath + (isObject(values) ? ".".concat(property) : "[".concat(property, "]"));\n    isPrimitive(values[property]) ? paths.push(rootName) : getPath(rootName, values[property], paths);\n  }\n\n  return paths;\n};\n\nvar assignWatchFields = function assignWatchFields(fieldValues, fieldName, watchFields, inputValue, isSingleField) {\n  var value = undefined;\n  watchFields.add(fieldName);\n\n  if (!isEmptyObject(fieldValues)) {\n    value = get(fieldValues, fieldName);\n\n    if (isObject(value) || Array.isArray(value)) {\n      getPath(fieldName, value).forEach(function (name) {\n        return watchFields.add(name);\n      });\n    }\n  }\n\n  return isUndefined(value) ? isSingleField ? inputValue : get(inputValue, fieldName) : value;\n};\n\nvar skipValidation = function skipValidation(_ref9) {\n  var isOnBlur = _ref9.isOnBlur,\n      isOnChange = _ref9.isOnChange,\n      isOnTouch = _ref9.isOnTouch,\n      isTouched = _ref9.isTouched,\n      isReValidateOnBlur = _ref9.isReValidateOnBlur,\n      isReValidateOnChange = _ref9.isReValidateOnChange,\n      isBlurEvent = _ref9.isBlurEvent,\n      isSubmitted = _ref9.isSubmitted,\n      isOnAll = _ref9.isOnAll;\n\n  if (isOnAll) {\n    return false;\n  } else if (!isSubmitted && isOnTouch) {\n    return !(isTouched || isBlurEvent);\n  } else if (isSubmitted ? isReValidateOnBlur : isOnBlur) {\n    return !isBlurEvent;\n  } else if (isSubmitted ? isReValidateOnChange : isOnChange) {\n    return isBlurEvent;\n  }\n\n  return true;\n};\n\nvar getFieldArrayParentName = function getFieldArrayParentName(name) {\n  return name.substring(0, name.indexOf(\'[\'));\n};\n\nvar isMatchFieldArrayName = function isMatchFieldArrayName(name, searchName) {\n  return RegExp("^".concat(searchName, "([|.)\\\\d+").replace(/\\[/g, \'\\\\[\').replace(/\\]/g, \'\\\\]\')).test(name);\n};\n\nvar index_esm_isNameInFieldArray = function isNameInFieldArray(names, name) {\n  return Object(toConsumableArray["a" /* default */])(names).some(function (current) {\n    return isMatchFieldArrayName(name, current);\n  });\n};\n\nvar isSelectInput = function isSelectInput(element) {\n  return element.type === "".concat(SELECT, "-one");\n};\n\nfunction onDomRemove(fieldsRef, removeFieldEventListenerAndRef) {\n  var observer = new MutationObserver(function () {\n    for (var _i3 = 0, _Object$values = Object.values(fieldsRef.current); _i3 < _Object$values.length; _i3++) {\n      var field = _Object$values[_i3];\n\n      if (field && field.options) {\n        var _iterator = _createForOfIteratorHelper(field.options),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var option = _step.value;\n\n            if (option && option.ref && isDetached(option.ref)) {\n              removeFieldEventListenerAndRef(field);\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      } else if (field && isDetached(field.ref)) {\n        removeFieldEventListenerAndRef(field);\n      }\n    }\n  });\n  observer.observe(window.document, {\n    childList: true,\n    subtree: true\n  });\n  return observer;\n}\n\nvar isWeb = typeof window !== UNDEFINED && typeof document !== UNDEFINED;\n\nfunction cloneObject(data) {\n  var copy;\n\n  if (isPrimitive(data) || isWeb && data instanceof File) {\n    return data;\n  }\n\n  if (data instanceof Date) {\n    copy = new Date(data.getTime());\n    return copy;\n  }\n\n  if (data instanceof Set) {\n    copy = new Set();\n\n    var _iterator2 = _createForOfIteratorHelper(data),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var item = _step2.value;\n        copy.add(item);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    return copy;\n  }\n\n  if (data instanceof Map) {\n    copy = new Map();\n\n    var _iterator3 = _createForOfIteratorHelper(data.keys()),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var key = _step3.value;\n        copy.set(key, cloneObject(data.get(key)));\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    return copy;\n  }\n\n  copy = Array.isArray(data) ? [] : {};\n\n  for (var _key in data) {\n    copy[_key] = cloneObject(data[_key]);\n  }\n\n  return copy;\n}\n\nvar modeChecker = function modeChecker(mode) {\n  return {\n    isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\n    isOnBlur: mode === VALIDATION_MODE.onBlur,\n    isOnChange: mode === VALIDATION_MODE.onChange,\n    isOnAll: mode === VALIDATION_MODE.all,\n    isOnTouch: mode === VALIDATION_MODE.onTouched\n  };\n};\n\nvar isRadioOrCheckboxFunction = function isRadioOrCheckboxFunction(ref) {\n  return isRadioInput(ref) || isCheckBoxInput(ref);\n};\n\nvar isWindowUndefined = typeof window === UNDEFINED;\nvar isProxyEnabled = isWeb ? \'Proxy\' in window : typeof Proxy !== UNDEFINED;\n\nfunction useForm() {\n  var _ref10 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref10$mode = _ref10.mode,\n      mode = _ref10$mode === void 0 ? VALIDATION_MODE.onSubmit : _ref10$mode,\n      _ref10$reValidateMode = _ref10.reValidateMode,\n      reValidateMode = _ref10$reValidateMode === void 0 ? VALIDATION_MODE.onChange : _ref10$reValidateMode,\n      resolver = _ref10.resolver,\n      context = _ref10.context,\n      _ref10$defaultValues = _ref10.defaultValues,\n      defaultValues = _ref10$defaultValues === void 0 ? {} : _ref10$defaultValues,\n      _ref10$shouldFocusErr = _ref10.shouldFocusError,\n      shouldFocusError = _ref10$shouldFocusErr === void 0 ? true : _ref10$shouldFocusErr,\n      _ref10$shouldUnregist = _ref10.shouldUnregister,\n      shouldUnregister = _ref10$shouldUnregist === void 0 ? true : _ref10$shouldUnregist,\n      criteriaMode = _ref10.criteriaMode;\n\n  var fieldsRef = Object(react["useRef"])({});\n  var fieldArrayDefaultValuesRef = Object(react["useRef"])({});\n  var fieldArrayValuesRef = Object(react["useRef"])({});\n  var watchFieldsRef = Object(react["useRef"])(new Set());\n  var useWatchFieldsRef = Object(react["useRef"])({});\n  var useWatchRenderFunctionsRef = Object(react["useRef"])({});\n  var fieldsWithValidationRef = Object(react["useRef"])({});\n  var validFieldsRef = Object(react["useRef"])({});\n  var defaultValuesRef = Object(react["useRef"])(defaultValues);\n  var defaultValuesAtRenderRef = Object(react["useRef"])({});\n  var isUnMount = Object(react["useRef"])(false);\n  var isWatchAllRef = Object(react["useRef"])(false);\n  var handleChangeRef = Object(react["useRef"])();\n  var shallowFieldsStateRef = Object(react["useRef"])({});\n  var resetFieldArrayFunctionRef = Object(react["useRef"])({});\n  var contextRef = Object(react["useRef"])(context);\n  var resolverRef = Object(react["useRef"])(resolver);\n  var fieldArrayNamesRef = Object(react["useRef"])(new Set());\n  var modeRef = Object(react["useRef"])(modeChecker(mode));\n  var _modeRef$current = modeRef.current,\n      isOnSubmit = _modeRef$current.isOnSubmit,\n      isOnTouch = _modeRef$current.isOnTouch;\n  var isValidateAllFieldCriteria = criteriaMode === VALIDATION_MODE.all;\n\n  var _useState = Object(react["useState"])({\n    isDirty: false,\n    dirtyFields: {},\n    isSubmitted: false,\n    submitCount: 0,\n    touched: {},\n    isSubmitting: false,\n    isSubmitSuccessful: false,\n    isValid: !isOnSubmit,\n    errors: {}\n  }),\n      _useState2 = _slicedToArray(_useState, 2),\n      formState = _useState2[0],\n      setFormState = _useState2[1];\n\n  var readFormStateRef = Object(react["useRef"])({\n    isDirty: !isProxyEnabled,\n    dirtyFields: !isProxyEnabled,\n    touched: !isProxyEnabled || isOnTouch,\n    isSubmitting: !isProxyEnabled,\n    isValid: !isProxyEnabled\n  });\n  var formStateRef = Object(react["useRef"])(formState);\n  var observerRef = Object(react["useRef"])();\n  var _useRef$current = Object(react["useRef"])(modeChecker(reValidateMode)).current,\n      isReValidateOnBlur = _useRef$current.isOnBlur,\n      isReValidateOnChange = _useRef$current.isOnChange;\n  contextRef.current = context;\n  resolverRef.current = resolver;\n  formStateRef.current = formState;\n  shallowFieldsStateRef.current = shouldUnregister ? {} : isEmptyObject(shallowFieldsStateRef.current) ? cloneObject(defaultValues) : shallowFieldsStateRef.current;\n  var updateFormState = Object(react["useCallback"])(function () {\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!isUnMount.current) {\n      formStateRef.current = Object.assign(Object.assign({}, formStateRef.current), state);\n      setFormState(formStateRef.current);\n    }\n  }, []);\n  var shouldRenderBaseOnError = Object(react["useCallback"])(function (name, error) {\n    var shouldRender = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    var isValid = arguments.length > 4 ? arguments[4] : undefined;\n    var shouldReRender = shouldRender || isErrorStateChanged({\n      errors: formStateRef.current.errors,\n      error: error,\n      name: name,\n      validFields: validFieldsRef.current,\n      fieldsWithValidation: fieldsWithValidationRef.current\n    });\n    var previousError = get(formStateRef.current.errors, name);\n\n    if (error) {\n      unset(validFieldsRef.current, name);\n      shouldReRender = shouldReRender || !previousError || !deepEqual(previousError, error, true);\n      set(formStateRef.current.errors, name, error);\n    } else {\n      if (get(fieldsWithValidationRef.current, name) || resolverRef.current) {\n        set(validFieldsRef.current, name, true);\n        shouldReRender = shouldReRender || previousError;\n      }\n\n      unset(formStateRef.current.errors, name);\n    }\n\n    if (shouldReRender && !isNullOrUndefined(shouldRender) || !isEmptyObject(state)) {\n      updateFormState(Object.assign(Object.assign({}, state), resolverRef.current ? {\n        isValid: !!isValid\n      } : {}));\n    }\n  }, []);\n  var setFieldValue = Object(react["useCallback"])(function (name, rawValue) {\n    var _fieldsRef$current$na = fieldsRef.current[name],\n        ref = _fieldsRef$current$na.ref,\n        options = _fieldsRef$current$na.options;\n    var value = isWeb && isHTMLElement(ref) && isNullOrUndefined(rawValue) ? \'\' : rawValue;\n\n    if (isRadioInput(ref)) {\n      (options || []).forEach(function (_ref11) {\n        var radioRef = _ref11.ref;\n        return radioRef.checked = radioRef.value === value;\n      });\n    } else if (isFileInput(ref) && !isString(value)) {\n      ref.files = value;\n    } else if (isMultipleSelect(ref)) {\n      Object(toConsumableArray["a" /* default */])(ref.options).forEach(function (selectRef) {\n        return selectRef.selected = value.includes(selectRef.value);\n      });\n    } else if (isCheckBoxInput(ref) && options) {\n      options.length > 1 ? options.forEach(function (_ref12) {\n        var checkboxRef = _ref12.ref;\n        return checkboxRef.checked = Array.isArray(value) ? !!value.find(function (data) {\n          return data === checkboxRef.value;\n        }) : value === checkboxRef.value;\n      }) : options[0].ref.checked = !!value;\n    } else {\n      ref.value = value;\n    }\n  }, []);\n  var isFormDirty = Object(react["useCallback"])(function (name, data) {\n    if (readFormStateRef.current.isDirty) {\n      var formValues = getValues();\n      name && data && set(formValues, name, data);\n      return !deepEqual(formValues, isEmptyObject(defaultValuesRef.current) ? defaultValuesAtRenderRef.current : defaultValuesRef.current);\n    }\n\n    return false;\n  }, []);\n  var updateAndGetDirtyState = Object(react["useCallback"])(function (name) {\n    var shouldRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    if (readFormStateRef.current.isDirty || readFormStateRef.current.dirtyFields) {\n      var isFieldDirty = !deepEqual(get(defaultValuesAtRenderRef.current, name), getFieldValue(fieldsRef, name, shallowFieldsStateRef));\n      var isDirtyFieldExist = get(formStateRef.current.dirtyFields, name);\n      var previousIsDirty = formStateRef.current.isDirty;\n      isFieldDirty ? set(formStateRef.current.dirtyFields, name, true) : unset(formStateRef.current.dirtyFields, name);\n      var state = {\n        isDirty: isFormDirty(),\n        dirtyFields: formStateRef.current.dirtyFields\n      };\n      var isChanged = readFormStateRef.current.isDirty && previousIsDirty !== state.isDirty || readFormStateRef.current.dirtyFields && isDirtyFieldExist !== get(formStateRef.current.dirtyFields, name);\n      isChanged && shouldRender && updateFormState(state);\n      return isChanged ? state : {};\n    }\n\n    return {};\n  }, []);\n  var executeValidation = Object(react["useCallback"])( /*#__PURE__*/function () {\n    var _ref13 = Object(asyncToGenerator["a" /* default */])( /*#__PURE__*/regenerator_default.a.mark(function _callee2(name, skipReRender) {\n      var error;\n      return regenerator_default.a.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              if (true) {\n                _context2.next = 4;\n                break;\n              }\n\n              if (fieldsRef.current[name]) {\n                _context2.next = 4;\n                break;\n              }\n\n              console.warn(\' Field is missing with `name` attribute: \', name);\n              return _context2.abrupt("return", false);\n\n            case 4:\n              _context2.next = 6;\n              return validateField(fieldsRef, isValidateAllFieldCriteria, fieldsRef.current[name], shallowFieldsStateRef);\n\n            case 6:\n              _context2.t0 = name;\n              error = _context2.sent[_context2.t0];\n              shouldRenderBaseOnError(name, error, skipReRender);\n              return _context2.abrupt("return", isUndefined(error));\n\n            case 10:\n            case "end":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    return function (_x5, _x6) {\n      return _ref13.apply(this, arguments);\n    };\n  }(), [shouldRenderBaseOnError, isValidateAllFieldCriteria]);\n  var executeSchemaOrResolverValidation = Object(react["useCallback"])( /*#__PURE__*/function () {\n    var _ref14 = Object(asyncToGenerator["a" /* default */])( /*#__PURE__*/regenerator_default.a.mark(function _callee3(names) {\n      var _yield$resolverRef$cu, errors, previousFormIsValid, isInputsValid, _error;\n\n      return regenerator_default.a.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return resolverRef.current(getValues(), contextRef.current, isValidateAllFieldCriteria);\n\n            case 2:\n              _yield$resolverRef$cu = _context3.sent;\n              errors = _yield$resolverRef$cu.errors;\n              previousFormIsValid = formStateRef.current.isValid;\n\n              if (!Array.isArray(names)) {\n                _context3.next = 11;\n                break;\n              }\n\n              isInputsValid = names.map(function (name) {\n                var error = get(errors, name);\n                error ? set(formStateRef.current.errors, name, error) : unset(formStateRef.current.errors, name);\n                return !error;\n              }).every(Boolean);\n              updateFormState({\n                isValid: isEmptyObject(errors)\n              });\n              return _context3.abrupt("return", isInputsValid);\n\n            case 11:\n              _error = get(errors, names);\n              shouldRenderBaseOnError(names, _error, previousFormIsValid !== isEmptyObject(errors), {}, isEmptyObject(errors));\n              return _context3.abrupt("return", !_error);\n\n            case 14:\n            case "end":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }));\n\n    return function (_x7) {\n      return _ref14.apply(this, arguments);\n    };\n  }(), [shouldRenderBaseOnError, isValidateAllFieldCriteria]);\n  var trigger = Object(react["useCallback"])( /*#__PURE__*/function () {\n    var _ref15 = Object(asyncToGenerator["a" /* default */])( /*#__PURE__*/regenerator_default.a.mark(function _callee5(name) {\n      var fields, result;\n      return regenerator_default.a.wrap(function _callee5$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              fields = name || Object.keys(fieldsRef.current);\n\n              if (!resolverRef.current) {\n                _context5.next = 3;\n                break;\n              }\n\n              return _context5.abrupt("return", executeSchemaOrResolverValidation(fields));\n\n            case 3:\n              if (!Array.isArray(fields)) {\n                _context5.next = 10;\n                break;\n              }\n\n              !name && (formStateRef.current.errors = {});\n              _context5.next = 7;\n              return Promise.all(fields.map( /*#__PURE__*/function () {\n                var _ref16 = Object(asyncToGenerator["a" /* default */])( /*#__PURE__*/regenerator_default.a.mark(function _callee4(data) {\n                  return regenerator_default.a.wrap(function _callee4$(_context4) {\n                    while (1) {\n                      switch (_context4.prev = _context4.next) {\n                        case 0:\n                          _context4.next = 2;\n                          return executeValidation(data, null);\n\n                        case 2:\n                          return _context4.abrupt("return", _context4.sent);\n\n                        case 3:\n                        case "end":\n                          return _context4.stop();\n                      }\n                    }\n                  }, _callee4);\n                }));\n\n                return function (_x9) {\n                  return _ref16.apply(this, arguments);\n                };\n              }()));\n\n            case 7:\n              result = _context5.sent;\n              updateFormState();\n              return _context5.abrupt("return", result.every(Boolean));\n\n            case 10:\n              _context5.next = 12;\n              return executeValidation(fields);\n\n            case 12:\n              return _context5.abrupt("return", _context5.sent);\n\n            case 13:\n            case "end":\n              return _context5.stop();\n          }\n        }\n      }, _callee5);\n    }));\n\n    return function (_x8) {\n      return _ref15.apply(this, arguments);\n    };\n  }(), [executeSchemaOrResolverValidation, executeValidation]);\n  var setInternalValues = Object(react["useCallback"])(function (name, value, _ref17) {\n    var shouldDirty = _ref17.shouldDirty,\n        shouldValidate = _ref17.shouldValidate;\n    var data = {};\n    set(data, name, value);\n\n    var _iterator4 = _createForOfIteratorHelper(getPath(name, value)),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var fieldName = _step4.value;\n\n        if (fieldsRef.current[fieldName]) {\n          setFieldValue(fieldName, get(data, fieldName));\n          shouldDirty && updateAndGetDirtyState(fieldName);\n          shouldValidate && trigger(fieldName);\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n  }, [trigger, setFieldValue, updateAndGetDirtyState]);\n  var setInternalValue = Object(react["useCallback"])(function (name, value, config) {\n    !isPrimitive(value) && set(shallowFieldsStateRef.current, name, value);\n\n    if (fieldsRef.current[name]) {\n      setFieldValue(name, value);\n      config.shouldDirty && updateAndGetDirtyState(name);\n      config.shouldValidate && trigger(name);\n    } else if (!isPrimitive(value)) {\n      setInternalValues(name, value, config);\n\n      if (fieldArrayNamesRef.current.has(name)) {\n        fieldArrayDefaultValuesRef.current[name] = value;\n        resetFieldArrayFunctionRef.current[name](Object(defineProperty["a" /* default */])({}, name, value));\n\n        if ((readFormStateRef.current.isDirty || readFormStateRef.current.dirtyFields) && config.shouldDirty) {\n          set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(value, get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\n          updateFormState({\n            isDirty: !deepEqual(Object.assign(Object.assign({}, getValues()), Object(defineProperty["a" /* default */])({}, name, value)), defaultValuesRef.current)\n          });\n        }\n      }\n    }\n\n    !shouldUnregister && set(shallowFieldsStateRef.current, name, value);\n  }, [updateAndGetDirtyState, setFieldValue, setInternalValues]);\n\n  var isFieldWatched = function isFieldWatched(name) {\n    return isWatchAllRef.current || watchFieldsRef.current.has(name) || watchFieldsRef.current.has((name.match(/\\w+/) || [])[0]);\n  };\n\n  var renderWatchedInputs = function renderWatchedInputs(name) {\n    var found = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    if (!isEmptyObject(useWatchFieldsRef.current)) {\n      for (var key in useWatchFieldsRef.current) {\n        if (!name || !useWatchFieldsRef.current[key].size || useWatchFieldsRef.current[key].has(name) || useWatchFieldsRef.current[key].has(getFieldArrayParentName(name))) {\n          useWatchRenderFunctionsRef.current[key]();\n          found = false;\n        }\n      }\n    }\n\n    return found;\n  };\n\n  function setValue(name, value, config) {\n    setInternalValue(name, value, config || {});\n    isFieldWatched(name) && updateFormState();\n    renderWatchedInputs(name);\n  }\n\n  handleChangeRef.current = handleChangeRef.current ? handleChangeRef.current : /*#__PURE__*/function () {\n    var _ref19 = Object(asyncToGenerator["a" /* default */])( /*#__PURE__*/regenerator_default.a.mark(function _callee6(_ref18) {\n      var type, target, name, field, error, isValid, isBlurEvent, shouldSkipValidation, state, shouldRender, _yield$resolverRef$cu2, errors, previousFormIsValid, parentNodeName, currentError;\n\n      return regenerator_default.a.wrap(function _callee6$(_context6) {\n        while (1) {\n          switch (_context6.prev = _context6.next) {\n            case 0:\n              type = _ref18.type, target = _ref18.target;\n              name = target.name;\n              field = fieldsRef.current[name];\n\n              if (!field) {\n                _context6.next = 31;\n                break;\n              }\n\n              isBlurEvent = type === EVENTS.BLUR;\n              shouldSkipValidation = skipValidation(Object.assign({\n                isBlurEvent: isBlurEvent,\n                isReValidateOnChange: isReValidateOnChange,\n                isReValidateOnBlur: isReValidateOnBlur,\n                isTouched: !!get(formStateRef.current.touched, name),\n                isSubmitted: formStateRef.current.isSubmitted\n              }, modeRef.current));\n              state = updateAndGetDirtyState(name, false);\n              shouldRender = !isEmptyObject(state) || isFieldWatched(name);\n\n              if (isBlurEvent && !get(formStateRef.current.touched, name) && readFormStateRef.current.touched) {\n                set(formStateRef.current.touched, name, true);\n                state = Object.assign(Object.assign({}, state), {\n                  touched: formStateRef.current.touched\n                });\n              }\n\n              if (!shouldUnregister && isCheckBoxInput(target)) {\n                set(shallowFieldsStateRef.current, name, getFieldValue(fieldsRef, name));\n              }\n\n              if (!shouldSkipValidation) {\n                _context6.next = 13;\n                break;\n              }\n\n              renderWatchedInputs(name);\n              return _context6.abrupt("return", (!isEmptyObject(state) || shouldRender && isEmptyObject(state)) && updateFormState(state));\n\n            case 13:\n              if (!resolverRef.current) {\n                _context6.next = 25;\n                break;\n              }\n\n              _context6.next = 16;\n              return resolverRef.current(getValues(), contextRef.current, isValidateAllFieldCriteria);\n\n            case 16:\n              _yield$resolverRef$cu2 = _context6.sent;\n              errors = _yield$resolverRef$cu2.errors;\n              previousFormIsValid = formStateRef.current.isValid;\n              error = get(errors, name);\n\n              if (isCheckBoxInput(target) && !error && resolverRef.current) {\n                parentNodeName = getFieldArrayParentName(name);\n                currentError = get(errors, parentNodeName, {});\n                currentError.type && currentError.message && (error = currentError);\n\n                if (parentNodeName && (currentError || get(formStateRef.current.errors, parentNodeName))) {\n                  name = parentNodeName;\n                }\n              }\n\n              isValid = isEmptyObject(errors);\n              previousFormIsValid !== isValid && (shouldRender = true);\n              _context6.next = 29;\n              break;\n\n            case 25:\n              _context6.next = 27;\n              return validateField(fieldsRef, isValidateAllFieldCriteria, field, shallowFieldsStateRef);\n\n            case 27:\n              _context6.t0 = name;\n              error = _context6.sent[_context6.t0];\n\n            case 29:\n              renderWatchedInputs(name);\n              shouldRenderBaseOnError(name, error, shouldRender, state, isValid);\n\n            case 31:\n            case "end":\n              return _context6.stop();\n          }\n        }\n      }, _callee6);\n    }));\n\n    return function (_x10) {\n      return _ref19.apply(this, arguments);\n    };\n  }();\n\n  function setFieldArrayDefaultValues(data) {\n    if (!shouldUnregister) {\n      var copy = cloneObject(data);\n\n      var _iterator5 = _createForOfIteratorHelper(fieldArrayNamesRef.current),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var value = _step5.value;\n\n          if (isKey(value) && !copy[value]) {\n            copy = Object.assign(Object.assign({}, copy), Object(defineProperty["a" /* default */])({}, value, []));\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      return copy;\n    }\n\n    return data;\n  }\n\n  function getValues(payload) {\n    if (isString(payload)) {\n      return getFieldValue(fieldsRef, payload, shallowFieldsStateRef);\n    }\n\n    if (Array.isArray(payload)) {\n      var data = {};\n\n      var _iterator6 = _createForOfIteratorHelper(payload),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var _name = _step6.value;\n          set(data, _name, getFieldValue(fieldsRef, _name, shallowFieldsStateRef));\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      return data;\n    }\n\n    return setFieldArrayDefaultValues(getFieldsValues(fieldsRef, cloneObject(shallowFieldsStateRef.current), shouldUnregister));\n  }\n\n  var validateResolver = Object(react["useCallback"])( /*#__PURE__*/Object(asyncToGenerator["a" /* default */])( /*#__PURE__*/regenerator_default.a.mark(function _callee7() {\n    var values,\n        _yield$resolverRef$cu3,\n        errors,\n        isValid,\n        _args7 = arguments;\n\n    return regenerator_default.a.wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            values = _args7.length > 0 && _args7[0] !== undefined ? _args7[0] : {};\n            _context7.next = 3;\n            return resolverRef.current(Object.assign(Object.assign({}, getValues()), values), contextRef.current, isValidateAllFieldCriteria);\n\n          case 3:\n            _yield$resolverRef$cu3 = _context7.sent;\n            errors = _yield$resolverRef$cu3.errors;\n            isValid = isEmptyObject(errors);\n            formStateRef.current.isValid !== isValid && updateFormState({\n              isValid: isValid\n            });\n\n          case 7:\n          case "end":\n            return _context7.stop();\n        }\n      }\n    }, _callee7);\n  })), [isValidateAllFieldCriteria]);\n  var removeFieldEventListener = Object(react["useCallback"])(function (field, forceDelete) {\n    return findRemovedFieldAndRemoveListener(fieldsRef, handleChangeRef.current, field, shallowFieldsStateRef, shouldUnregister, forceDelete);\n  }, [shouldUnregister]);\n  var updateWatchedValue = Object(react["useCallback"])(function (name) {\n    if (isWatchAllRef.current) {\n      updateFormState();\n    } else {\n      var _iterator7 = _createForOfIteratorHelper(watchFieldsRef.current),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var watchField = _step7.value;\n\n          if (watchField.startsWith(name)) {\n            updateFormState();\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      renderWatchedInputs(name);\n    }\n  }, []);\n  var removeFieldEventListenerAndRef = Object(react["useCallback"])(function (field, forceDelete) {\n    if (field) {\n      removeFieldEventListener(field, forceDelete);\n\n      if (shouldUnregister && !compact(field.options || []).length) {\n        unset(defaultValuesAtRenderRef.current, field.ref.name);\n        unset(validFieldsRef.current, field.ref.name);\n        unset(fieldsWithValidationRef.current, field.ref.name);\n        unset(formStateRef.current.errors, field.ref.name);\n        set(formStateRef.current.dirtyFields, field.ref.name, true);\n        updateFormState({\n          isDirty: isFormDirty()\n        });\n        readFormStateRef.current.isValid && resolverRef.current && validateResolver();\n        updateWatchedValue(field.ref.name);\n      }\n    }\n  }, [validateResolver, removeFieldEventListener]);\n\n  function clearErrors(name) {\n    name && (Array.isArray(name) ? name : [name]).forEach(function (inputName) {\n      return fieldsRef.current[inputName] && isKey(inputName) ? delete formStateRef.current.errors[inputName] : unset(formStateRef.current.errors, inputName);\n    });\n    updateFormState({\n      errors: name ? formStateRef.current.errors : {}\n    });\n  }\n\n  function setError(name, error) {\n    var ref = (fieldsRef.current[name] || {}).ref;\n    set(formStateRef.current.errors, name, Object.assign(Object.assign({}, error), {\n      ref: ref\n    }));\n    updateFormState({\n      isValid: false\n    });\n    error.shouldFocus && ref && ref.focus && ref.focus();\n  }\n\n  var watchInternal = Object(react["useCallback"])(function (fieldNames, defaultValue, watchId) {\n    var watchFields = watchId ? useWatchFieldsRef.current[watchId] : watchFieldsRef.current;\n    var fieldValues = getFieldsValues(fieldsRef, cloneObject(shallowFieldsStateRef.current), shouldUnregister, false, fieldNames);\n\n    if (isString(fieldNames)) {\n      if (fieldArrayNamesRef.current.has(fieldNames)) {\n        var fieldArrayValue = get(fieldArrayValuesRef.current, fieldNames, []);\n        fieldValues = !fieldArrayValue.length || fieldArrayValue.length !== compact(get(fieldValues, fieldNames, [])).length ? fieldArrayValuesRef.current : fieldValues;\n      }\n\n      return assignWatchFields(fieldValues, fieldNames, watchFields, isUndefined(get(defaultValuesRef.current, fieldNames)) ? defaultValue : get(defaultValuesRef.current, fieldNames), true);\n    }\n\n    var combinedDefaultValues = isUndefined(defaultValue) ? defaultValuesRef.current : defaultValue;\n\n    if (Array.isArray(fieldNames)) {\n      return fieldNames.reduce(function (previous, name) {\n        return Object.assign(Object.assign({}, previous), Object(defineProperty["a" /* default */])({}, name, assignWatchFields(fieldValues, name, watchFields, combinedDefaultValues)));\n      }, {});\n    }\n\n    isWatchAllRef.current = isUndefined(watchId);\n    return transformToNestObject(!isEmptyObject(fieldValues) && fieldValues || combinedDefaultValues);\n  }, []);\n\n  function watch(fieldNames, defaultValue) {\n    return watchInternal(fieldNames, defaultValue);\n  }\n\n  function unregister(name) {\n    var _iterator8 = _createForOfIteratorHelper(Array.isArray(name) ? name : [name]),\n        _step8;\n\n    try {\n      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n        var fieldName = _step8.value;\n        removeFieldEventListenerAndRef(fieldsRef.current[fieldName], true);\n      }\n    } catch (err) {\n      _iterator8.e(err);\n    } finally {\n      _iterator8.f();\n    }\n  }\n\n  function registerFieldRef(ref) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (false) {}\n\n    var name = ref.name,\n        type = ref.type,\n        value = ref.value;\n    var fieldRefAndValidationOptions = Object.assign({\n      ref: ref\n    }, options);\n    var fields = fieldsRef.current;\n    var isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\n    var isFieldArray = index_esm_isNameInFieldArray(fieldArrayNamesRef.current, name);\n\n    var compareRef = function compareRef(currentRef) {\n      return isWeb && (!isHTMLElement(ref) || currentRef === ref);\n    };\n\n    var field = fields[name];\n    var isEmptyDefaultValue = true;\n    var defaultValue;\n\n    if (field && (isRadioOrCheckbox ? Array.isArray(field.options) && compact(field.options).find(function (option) {\n      return value === option.ref.value && compareRef(option.ref);\n    }) : compareRef(field.ref))) {\n      fields[name] = Object.assign(Object.assign({}, field), options);\n      return;\n    }\n\n    if (type) {\n      field = isRadioOrCheckbox ? Object.assign({\n        options: [].concat(Object(toConsumableArray["a" /* default */])(compact(field && field.options || [])), [{\n          ref: ref\n        }]),\n        ref: {\n          type: type,\n          name: name\n        }\n      }, options) : Object.assign({}, fieldRefAndValidationOptions);\n    } else {\n      field = fieldRefAndValidationOptions;\n    }\n\n    fields[name] = field;\n    var isEmptyUnmountFields = isUndefined(get(shallowFieldsStateRef.current, name));\n\n    if (!isEmptyObject(defaultValuesRef.current) || !isEmptyUnmountFields) {\n      defaultValue = get(isEmptyUnmountFields ? defaultValuesRef.current : shallowFieldsStateRef.current, name);\n      isEmptyDefaultValue = isUndefined(defaultValue);\n\n      if (!isEmptyDefaultValue && !isFieldArray) {\n        setFieldValue(name, defaultValue);\n      }\n    }\n\n    if (!isEmptyObject(options)) {\n      set(fieldsWithValidationRef.current, name, true);\n\n      if (!isOnSubmit && readFormStateRef.current.isValid) {\n        validateField(fieldsRef, isValidateAllFieldCriteria, field, shallowFieldsStateRef).then(function (error) {\n          var previousFormIsValid = formStateRef.current.isValid;\n          isEmptyObject(error) ? set(validFieldsRef.current, name, true) : unset(validFieldsRef.current, name);\n          previousFormIsValid !== isEmptyObject(error) && updateFormState();\n        });\n      }\n    }\n\n    if (!defaultValuesAtRenderRef.current[name] && !(isFieldArray && isEmptyDefaultValue)) {\n      var fieldValue = getFieldValue(fieldsRef, name, shallowFieldsStateRef);\n      set(defaultValuesAtRenderRef.current, name, isEmptyDefaultValue ? isObject(fieldValue) ? Object.assign({}, fieldValue) : fieldValue : defaultValue);\n      !isFieldArray && unset(formStateRef.current.dirtyFields, name);\n    }\n\n    if (type) {\n      attachEventListeners(isRadioOrCheckbox && field.options ? field.options[field.options.length - 1] : field, isRadioOrCheckbox || isSelectInput(ref), handleChangeRef.current);\n    }\n  }\n\n  function register(refOrRegisterOptions, options) {\n    if (!isWindowUndefined) {\n      if (isString(refOrRegisterOptions)) {\n        registerFieldRef({\n          name: refOrRegisterOptions\n        }, options);\n      } else if (isObject(refOrRegisterOptions) && \'name\' in refOrRegisterOptions) {\n        registerFieldRef(refOrRegisterOptions, options);\n      } else {\n        return function (ref) {\n          return ref && registerFieldRef(ref, refOrRegisterOptions);\n        };\n      }\n    }\n  }\n\n  var handleSubmit = Object(react["useCallback"])(function (onValid, onInvalid) {\n    return /*#__PURE__*/function () {\n      var _ref21 = Object(asyncToGenerator["a" /* default */])( /*#__PURE__*/regenerator_default.a.mark(function _callee8(e) {\n        var fieldErrors, fieldValues, _yield$resolverRef$cu4, errors, values, _i4, _Object$values2, field, _name2, fieldError;\n\n        return regenerator_default.a.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                if (e && e.preventDefault) {\n                  e.preventDefault();\n                  e.persist();\n                }\n\n                fieldErrors = {};\n                fieldValues = setFieldArrayDefaultValues(getFieldsValues(fieldsRef, cloneObject(shallowFieldsStateRef.current), shouldUnregister, true));\n                readFormStateRef.current.isSubmitting && updateFormState({\n                  isSubmitting: true\n                });\n                _context8.prev = 4;\n\n                if (!resolverRef.current) {\n                  _context8.next = 15;\n                  break;\n                }\n\n                _context8.next = 8;\n                return resolverRef.current(fieldValues, contextRef.current, isValidateAllFieldCriteria);\n\n              case 8:\n                _yield$resolverRef$cu4 = _context8.sent;\n                errors = _yield$resolverRef$cu4.errors;\n                values = _yield$resolverRef$cu4.values;\n                formStateRef.current.errors = fieldErrors = errors;\n                fieldValues = values;\n                _context8.next = 27;\n                break;\n\n              case 15:\n                _i4 = 0, _Object$values2 = Object.values(fieldsRef.current);\n\n              case 16:\n                if (!(_i4 < _Object$values2.length)) {\n                  _context8.next = 27;\n                  break;\n                }\n\n                field = _Object$values2[_i4];\n\n                if (!field) {\n                  _context8.next = 24;\n                  break;\n                }\n\n                _name2 = field.ref.name;\n                _context8.next = 22;\n                return validateField(fieldsRef, isValidateAllFieldCriteria, field, shallowFieldsStateRef);\n\n              case 22:\n                fieldError = _context8.sent;\n\n                if (fieldError[_name2]) {\n                  set(fieldErrors, _name2, fieldError[_name2]);\n                  unset(validFieldsRef.current, _name2);\n                } else if (get(fieldsWithValidationRef.current, _name2)) {\n                  unset(formStateRef.current.errors, _name2);\n                  set(validFieldsRef.current, _name2, true);\n                }\n\n              case 24:\n                _i4++;\n                _context8.next = 16;\n                break;\n\n              case 27:\n                if (!(isEmptyObject(fieldErrors) && Object.keys(formStateRef.current.errors).every(function (name) {\n                  return name in fieldsRef.current;\n                }))) {\n                  _context8.next = 33;\n                  break;\n                }\n\n                updateFormState({\n                  errors: {},\n                  isSubmitting: true\n                });\n                _context8.next = 31;\n                return onValid(fieldValues, e);\n\n              case 31:\n                _context8.next = 39;\n                break;\n\n              case 33:\n                formStateRef.current.errors = Object.assign(Object.assign({}, formStateRef.current.errors), fieldErrors);\n                _context8.t0 = onInvalid;\n\n                if (!_context8.t0) {\n                  _context8.next = 38;\n                  break;\n                }\n\n                _context8.next = 38;\n                return onInvalid(formStateRef.current.errors, e);\n\n              case 38:\n                shouldFocusError && focusOnErrorField(fieldsRef.current, formStateRef.current.errors);\n\n              case 39:\n                _context8.prev = 39;\n                formStateRef.current.isSubmitting = false;\n                updateFormState({\n                  isSubmitted: true,\n                  isSubmitting: false,\n                  isSubmitSuccessful: isEmptyObject(formStateRef.current.errors),\n                  submitCount: formStateRef.current.submitCount + 1\n                });\n                return _context8.finish(39);\n\n              case 43:\n              case "end":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, null, [[4,, 39, 43]]);\n      }));\n\n      return function (_x11) {\n        return _ref21.apply(this, arguments);\n      };\n    }();\n  }, [shouldFocusError, isValidateAllFieldCriteria]);\n\n  var resetRefs = function resetRefs(_ref22) {\n    var errors = _ref22.errors,\n        isDirty = _ref22.isDirty,\n        isSubmitted = _ref22.isSubmitted,\n        touched = _ref22.touched,\n        isValid = _ref22.isValid,\n        submitCount = _ref22.submitCount,\n        dirtyFields = _ref22.dirtyFields;\n\n    if (!isValid) {\n      validFieldsRef.current = {};\n      fieldsWithValidationRef.current = {};\n    }\n\n    defaultValuesAtRenderRef.current = {};\n    fieldArrayDefaultValuesRef.current = {};\n    watchFieldsRef.current = new Set();\n    isWatchAllRef.current = false;\n    updateFormState({\n      submitCount: submitCount ? formStateRef.current.submitCount : 0,\n      isDirty: isDirty ? formStateRef.current.isDirty : false,\n      isSubmitted: isSubmitted ? formStateRef.current.isSubmitted : false,\n      isValid: isValid ? formStateRef.current.isValid : false,\n      dirtyFields: dirtyFields ? formStateRef.current.dirtyFields : {},\n      touched: touched ? formStateRef.current.touched : {},\n      errors: errors ? formStateRef.current.errors : {},\n      isSubmitting: false,\n      isSubmitSuccessful: false\n    });\n  };\n\n  var reset = function reset(values) {\n    var omitResetState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (isWeb) {\n      for (var _i5 = 0, _Object$values3 = Object.values(fieldsRef.current); _i5 < _Object$values3.length; _i5++) {\n        var field = _Object$values3[_i5];\n\n        if (field) {\n          var _ref23 = field.ref,\n              options = field.options;\n          var inputRef = isRadioOrCheckboxFunction(_ref23) && Array.isArray(options) ? options[0].ref : _ref23;\n\n          if (isHTMLElement(inputRef)) {\n            try {\n              inputRef.closest(\'form\').reset();\n              break;\n            } catch (_a) {}\n          }\n        }\n      }\n    }\n\n    fieldsRef.current = {};\n    defaultValuesRef.current = cloneObject(values || defaultValuesRef.current);\n    values && renderWatchedInputs(\'\');\n    Object.values(resetFieldArrayFunctionRef.current).forEach(function (resetFieldArray) {\n      return isFunction(resetFieldArray) && resetFieldArray();\n    });\n    shallowFieldsStateRef.current = shouldUnregister ? {} : cloneObject(values) || {};\n    resetRefs(omitResetState);\n  };\n\n  Object(react["useEffect"])(function () {\n    resolver && readFormStateRef.current.isValid && validateResolver();\n    observerRef.current = observerRef.current || !isWeb ? observerRef.current : onDomRemove(fieldsRef, removeFieldEventListenerAndRef);\n  }, [removeFieldEventListenerAndRef, defaultValuesRef.current]);\n  Object(react["useEffect"])(function () {\n    return function () {\n      observerRef.current && observerRef.current.disconnect();\n\n      if (false) {}\n\n      isUnMount.current = true;\n      Object.values(fieldsRef.current).forEach(function (field) {\n        return removeFieldEventListenerAndRef(field, true);\n      });\n    };\n  }, []);\n\n  if (!resolver && readFormStateRef.current.isValid) {\n    formState.isValid = deepEqual(validFieldsRef.current, fieldsWithValidationRef.current) && isEmptyObject(formStateRef.current.errors);\n  }\n\n  var commonProps = {\n    trigger: trigger,\n    setValue: Object(react["useCallback"])(setValue, [setInternalValue, trigger]),\n    getValues: Object(react["useCallback"])(getValues, []),\n    register: Object(react["useCallback"])(register, [defaultValuesRef.current]),\n    unregister: Object(react["useCallback"])(unregister, [])\n  };\n  var control = Object(react["useMemo"])(function () {\n    return Object.assign({\n      isFormDirty: isFormDirty,\n      updateWatchedValue: updateWatchedValue,\n      shouldUnregister: shouldUnregister,\n      updateFormState: updateFormState,\n      removeFieldEventListener: removeFieldEventListener,\n      watchInternal: watchInternal,\n      mode: modeRef.current,\n      reValidateMode: {\n        isReValidateOnBlur: isReValidateOnBlur,\n        isReValidateOnChange: isReValidateOnChange\n      },\n      validateResolver: resolver ? validateResolver : undefined,\n      fieldsRef: fieldsRef,\n      resetFieldArrayFunctionRef: resetFieldArrayFunctionRef,\n      useWatchFieldsRef: useWatchFieldsRef,\n      useWatchRenderFunctionsRef: useWatchRenderFunctionsRef,\n      fieldArrayDefaultValuesRef: fieldArrayDefaultValuesRef,\n      validFieldsRef: validFieldsRef,\n      fieldsWithValidationRef: fieldsWithValidationRef,\n      fieldArrayNamesRef: fieldArrayNamesRef,\n      readFormStateRef: readFormStateRef,\n      formStateRef: formStateRef,\n      defaultValuesRef: defaultValuesRef,\n      shallowFieldsStateRef: shallowFieldsStateRef,\n      fieldArrayValuesRef: fieldArrayValuesRef\n    }, commonProps);\n  }, [defaultValuesRef.current, updateWatchedValue, shouldUnregister, removeFieldEventListener, watchInternal]);\n  return Object.assign({\n    watch: watch,\n    control: control,\n    formState: isProxyEnabled ? new Proxy(formState, {\n      get: function get(obj, prop) {\n        if (false) {}\n\n        if (prop in obj) {\n          readFormStateRef.current[prop] = true;\n          return obj[prop];\n        }\n\n        return undefined;\n      }\n    }) : formState,\n    handleSubmit: handleSubmit,\n    reset: Object(react["useCallback"])(reset, []),\n    clearErrors: Object(react["useCallback"])(clearErrors, []),\n    setError: Object(react["useCallback"])(setError, []),\n    errors: formState.errors\n  }, commonProps);\n}\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\n\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\n\nvar FormContext = Object(react["createContext"])(null);\nFormContext.displayName = \'RHFContext\';\n\nvar index_esm_useFormContext = function useFormContext() {\n  return Object(react["useContext"])(FormContext);\n};\n\nvar index_esm_FormProvider = function FormProvider(_a) {\n  var children = _a.children,\n      props = __rest(_a, ["children"]);\n\n  return Object(react["createElement"])(FormContext.Provider, {\n    value: Object.assign({}, props)\n  }, children);\n};\n\nvar generateId = function generateId() {\n  var d = typeof performance === UNDEFINED ? Date.now() : performance.now() * 1000;\n  return \'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\'.replace(/[xy]/g, function (c) {\n    var r = (Math.random() * 16 + d) % 16 | 0;\n    return (c == \'x\' ? r : r & 0x3 | 0x8).toString(16);\n  });\n};\n\nfunction removeAtIndexes(data, indexes) {\n  var i = 0;\n\n  var temp = Object(toConsumableArray["a" /* default */])(data);\n\n  var _iterator9 = _createForOfIteratorHelper(indexes),\n      _step9;\n\n  try {\n    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n      var index = _step9.value;\n      temp.splice(index - i, 1);\n      i++;\n    }\n  } catch (err) {\n    _iterator9.e(err);\n  } finally {\n    _iterator9.f();\n  }\n\n  return compact(temp).length ? temp : [];\n}\n\nvar removeArrayAt = function removeArrayAt(data, index) {\n  return isUndefined(index) ? [] : removeAtIndexes(data, (Array.isArray(index) ? index : [index]).sort());\n};\n\nvar moveArrayAt = function moveArrayAt(data, from, to) {\n  if (Array.isArray(data)) {\n    if (isUndefined(data[to])) {\n      data[to] = undefined;\n    }\n\n    data.splice(to, 0, data.splice(from, 1)[0]);\n    return data;\n  }\n\n  return [];\n};\n\nvar swapArrayAt = function swapArrayAt(data, indexA, indexB) {\n  var temp = [data[indexB], data[indexA]];\n  data[indexA] = temp[0];\n  data[indexB] = temp[1];\n};\n\nfunction prepend(data, value) {\n  return [].concat(Object(toConsumableArray["a" /* default */])(Array.isArray(value) ? value : [value || undefined]), Object(toConsumableArray["a" /* default */])(data));\n}\n\nfunction insert(data, index, value) {\n  return [].concat(Object(toConsumableArray["a" /* default */])(data.slice(0, index)), Object(toConsumableArray["a" /* default */])(Array.isArray(value) ? value : [value || undefined]), Object(toConsumableArray["a" /* default */])(data.slice(index)));\n}\n\nvar fillEmptyArray = function fillEmptyArray(value) {\n  return Array.isArray(value) ? Array(value.length).fill(undefined) : undefined;\n};\n\nvar fillBooleanArray = function fillBooleanArray(value) {\n  return (Array.isArray(value) ? value : [value]).map(function (data) {\n    if (isObject(data)) {\n      var object = {};\n\n      for (var key in data) {\n        object[key] = true;\n      }\n\n      return object;\n    }\n\n    return true;\n  });\n};\n\nvar index_esm_mapIds = function mapIds() {\n  var values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var keyName = arguments.length > 1 ? arguments[1] : undefined;\n\n  if (false) { var value, _iterator10, _step10; }\n\n  return values.map(function (value) {\n    return Object.assign(Object(defineProperty["a" /* default */])({}, keyName, generateId()), value);\n  });\n};\n\nvar index_esm_useFieldArray = function useFieldArray(_ref24) {\n  var control = _ref24.control,\n      name = _ref24.name,\n      _ref24$keyName = _ref24.keyName,\n      keyName = _ref24$keyName === void 0 ? \'id\' : _ref24$keyName;\n  var methods = index_esm_useFormContext();\n\n  if (false) {}\n\n  var focusIndexRef = Object(react["useRef"])(-1);\n\n  var _ref25 = control || methods.control,\n      isFormDirty = _ref25.isFormDirty,\n      updateWatchedValue = _ref25.updateWatchedValue,\n      resetFieldArrayFunctionRef = _ref25.resetFieldArrayFunctionRef,\n      fieldArrayNamesRef = _ref25.fieldArrayNamesRef,\n      fieldsRef = _ref25.fieldsRef,\n      defaultValuesRef = _ref25.defaultValuesRef,\n      removeFieldEventListener = _ref25.removeFieldEventListener,\n      formStateRef = _ref25.formStateRef,\n      shallowFieldsStateRef = _ref25.shallowFieldsStateRef,\n      updateFormState = _ref25.updateFormState,\n      readFormStateRef = _ref25.readFormStateRef,\n      validFieldsRef = _ref25.validFieldsRef,\n      fieldsWithValidationRef = _ref25.fieldsWithValidationRef,\n      fieldArrayDefaultValuesRef = _ref25.fieldArrayDefaultValuesRef,\n      validateResolver = _ref25.validateResolver,\n      getValues = _ref25.getValues,\n      shouldUnregister = _ref25.shouldUnregister,\n      fieldArrayValuesRef = _ref25.fieldArrayValuesRef;\n\n  var fieldArrayParentName = getFieldArrayParentName(name);\n  var memoizedDefaultValues = Object(react["useRef"])(Object(toConsumableArray["a" /* default */])(get(fieldArrayDefaultValuesRef.current, fieldArrayParentName) ? get(fieldArrayDefaultValuesRef.current, name, []) : get(shouldUnregister ? defaultValuesRef.current : shallowFieldsStateRef.current, name, [])));\n\n  var _useState3 = Object(react["useState"])(index_esm_mapIds(memoizedDefaultValues.current, keyName)),\n      _useState4 = _slicedToArray(_useState3, 2),\n      fields = _useState4[0],\n      setFields = _useState4[1];\n\n  set(fieldArrayValuesRef.current, name, fields);\n\n  var omitKey = function omitKey(fields) {\n    return fields.map(function () {\n      var _a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var _b = keyName,\n          omitted = _a[_b],\n          rest = __rest(_a, [typeof _b === "symbol" ? _b : _b + ""]);\n\n      return rest;\n    });\n  };\n\n  fieldArrayNamesRef.current.add(name);\n  var getFieldArrayValue = Object(react["useCallback"])(function () {\n    return get(fieldArrayValuesRef.current, name, []);\n  }, []);\n\n  var getCurrentFieldsValues = function getCurrentFieldsValues() {\n    return get(getValues(), name, getFieldArrayValue()).map(function (item, index) {\n      return Object.assign(Object.assign({}, getFieldArrayValue()[index]), item);\n    });\n  };\n\n  fieldArrayNamesRef.current.add(name);\n\n  if (fieldArrayParentName && !get(fieldArrayDefaultValuesRef.current, fieldArrayParentName)) {\n    set(fieldArrayDefaultValuesRef.current, fieldArrayParentName, cloneObject(get(defaultValuesRef.current, fieldArrayParentName)));\n  }\n\n  var setFieldAndValidState = function setFieldAndValidState(fieldsValues) {\n    setFields(fieldsValues);\n    set(fieldArrayValuesRef.current, name, fieldsValues);\n\n    if (readFormStateRef.current.isValid && validateResolver) {\n      var values = getValues();\n      set(values, name, fieldsValues);\n      validateResolver(values);\n    }\n  };\n\n  var resetFields = function resetFields() {\n    for (var key in fieldsRef.current) {\n      isMatchFieldArrayName(key, name) && removeFieldEventListener(fieldsRef.current[key], true);\n    }\n  };\n\n  var cleanup = function cleanup(ref) {\n    return !compact(get(ref, name, [])).length && unset(ref, name);\n  };\n\n  var updateDirtyFieldsWithDefaultValues = function updateDirtyFieldsWithDefaultValues(updatedFieldArrayValues) {\n    if (updatedFieldArrayValues) {\n      set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(omitKey(updatedFieldArrayValues), get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\n    }\n  };\n\n  var batchStateUpdate = function batchStateUpdate(method, args, updatedFieldValues) {\n    var updatedFormValues = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n    var shouldSet = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    var shouldUpdateValid = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n\n    if (get(shallowFieldsStateRef.current, name)) {\n      var output = method(get(shallowFieldsStateRef.current, name), args.argA, args.argB);\n      shouldSet && set(shallowFieldsStateRef.current, name, output);\n    }\n\n    if (get(fieldArrayDefaultValuesRef.current, name)) {\n      var _output = method(get(fieldArrayDefaultValuesRef.current, name), args.argA, args.argB);\n\n      shouldSet && set(fieldArrayDefaultValuesRef.current, name, _output);\n      cleanup(fieldArrayDefaultValuesRef.current);\n    }\n\n    if (Array.isArray(get(formStateRef.current.errors, name))) {\n      var _output2 = method(get(formStateRef.current.errors, name), args.argA, args.argB);\n\n      shouldSet && set(formStateRef.current.errors, name, _output2);\n      cleanup(formStateRef.current.errors);\n    }\n\n    if (readFormStateRef.current.touched && get(formStateRef.current.touched, name)) {\n      var _output3 = method(get(formStateRef.current.touched, name), args.argA, args.argB);\n\n      shouldSet && set(formStateRef.current.touched, name, _output3);\n      cleanup(formStateRef.current.touched);\n    }\n\n    if (readFormStateRef.current.dirtyFields || readFormStateRef.current.isDirty) {\n      var _output4 = method(get(formStateRef.current.dirtyFields, name, []), args.argC, args.argD);\n\n      shouldSet && set(formStateRef.current.dirtyFields, name, _output4);\n      updateDirtyFieldsWithDefaultValues(updatedFieldValues);\n      cleanup(formStateRef.current.dirtyFields);\n    }\n\n    if (shouldUpdateValid && readFormStateRef.current.isValid && !validateResolver) {\n      set(validFieldsRef.current, name, method(get(validFieldsRef.current, name, []), args.argA));\n      cleanup(validFieldsRef.current);\n      set(fieldsWithValidationRef.current, name, method(get(fieldsWithValidationRef.current, name, []), args.argA));\n      cleanup(fieldsWithValidationRef.current);\n    }\n\n    updateFormState({\n      isDirty: isFormDirty(name, omitKey(updatedFormValues))\n    });\n  };\n\n  var append = function append(value) {\n    var shouldFocus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var updateFormValues = [].concat(Object(toConsumableArray["a" /* default */])(getCurrentFieldsValues()), Object(toConsumableArray["a" /* default */])(index_esm_mapIds(Array.isArray(value) ? value : [value], keyName)));\n    setFieldAndValidState(updateFormValues);\n\n    if (readFormStateRef.current.dirtyFields || readFormStateRef.current.isDirty) {\n      updateDirtyFieldsWithDefaultValues(updateFormValues);\n      updateFormState({\n        isDirty: true,\n        dirtyFields: formStateRef.current.dirtyFields\n      });\n    }\n\n    !shouldUnregister && set(shallowFieldsStateRef.current, name, [].concat(Object(toConsumableArray["a" /* default */])(get(shallowFieldsStateRef.current, name) || []), [value]));\n    focusIndexRef.current = shouldFocus ? fields.length : -1;\n  };\n\n  var prepend$1 = function prepend$1(value) {\n    var shouldFocus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var emptyArray = fillEmptyArray(value);\n    var updatedFieldArrayValues = prepend(getCurrentFieldsValues(), index_esm_mapIds(Array.isArray(value) ? value : [value], keyName));\n    setFieldAndValidState(updatedFieldArrayValues);\n    resetFields();\n    batchStateUpdate(prepend, {\n      argA: emptyArray,\n      argC: fillBooleanArray(value)\n    }, updatedFieldArrayValues);\n    focusIndexRef.current = shouldFocus ? 0 : -1;\n  };\n\n  var remove = function remove(index) {\n    var fieldValues = getCurrentFieldsValues();\n    var updatedFieldValues = removeArrayAt(fieldValues, index);\n    setFieldAndValidState(updatedFieldValues);\n    resetFields();\n    batchStateUpdate(removeArrayAt, {\n      argA: index,\n      argC: index\n    }, updatedFieldValues, removeArrayAt(fieldValues, index), true, true);\n  };\n\n  var insert$1 = function insert$1(index, value) {\n    var shouldFocus = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    var emptyArray = fillEmptyArray(value);\n    var fieldValues = getCurrentFieldsValues();\n    var updatedFieldArrayValues = insert(fieldValues, index, index_esm_mapIds(Array.isArray(value) ? value : [value], keyName));\n    setFieldAndValidState(updatedFieldArrayValues);\n    resetFields();\n    batchStateUpdate(insert, {\n      argA: index,\n      argB: emptyArray,\n      argC: index,\n      argD: fillBooleanArray(value)\n    }, updatedFieldArrayValues, insert(fieldValues, index));\n    focusIndexRef.current = shouldFocus ? index : -1;\n  };\n\n  var swap = function swap(indexA, indexB) {\n    var fieldValues = getCurrentFieldsValues();\n    swapArrayAt(fieldValues, indexA, indexB);\n    resetFields();\n    setFieldAndValidState(Object(toConsumableArray["a" /* default */])(fieldValues));\n    batchStateUpdate(swapArrayAt, {\n      argA: indexA,\n      argB: indexB,\n      argC: indexA,\n      argD: indexB\n    }, undefined, fieldValues, false);\n  };\n\n  var move = function move(from, to) {\n    var fieldValues = getCurrentFieldsValues();\n    moveArrayAt(fieldValues, from, to);\n    resetFields();\n    setFieldAndValidState(Object(toConsumableArray["a" /* default */])(fieldValues));\n    batchStateUpdate(moveArrayAt, {\n      argA: from,\n      argB: to,\n      argC: from,\n      argD: to\n    }, undefined, fieldValues, false);\n  };\n\n  Object(react["useEffect"])(function () {\n    if (false) {}\n\n    var defaultValues = get(fieldArrayDefaultValuesRef.current, name);\n\n    if (defaultValues && fields.length < defaultValues.length) {\n      defaultValues.pop();\n      set(fieldArrayDefaultValuesRef.current, name, defaultValues);\n    }\n\n    updateWatchedValue(name);\n\n    if (focusIndexRef.current > -1) {\n      for (var key in fieldsRef.current) {\n        var field = fieldsRef.current[key];\n\n        if (key.startsWith("".concat(name, "[").concat(focusIndexRef.current, "]")) && field.ref.focus) {\n          field.ref.focus();\n          break;\n        }\n      }\n    }\n\n    focusIndexRef.current = -1;\n  }, [fields, name]);\n  Object(react["useEffect"])(function () {\n    var resetFunctions = resetFieldArrayFunctionRef.current;\n    var fieldArrayNames = fieldArrayNamesRef.current;\n\n    if (!getFieldArrayParentName(name)) {\n      resetFunctions[name] = function (data) {\n        resetFields();\n        !data && unset(fieldArrayDefaultValuesRef.current, name);\n        unset(shallowFieldsStateRef.current, name);\n        memoizedDefaultValues.current = get(data || defaultValuesRef.current, name);\n        setFields(index_esm_mapIds(memoizedDefaultValues.current, keyName));\n      };\n    }\n\n    return function () {\n      if (false) {}\n\n      resetFields();\n      delete resetFunctions[name];\n      unset(fieldArrayValuesRef, name);\n      fieldArrayNames.delete(name);\n    };\n  }, []);\n  return {\n    swap: Object(react["useCallback"])(swap, [name]),\n    move: Object(react["useCallback"])(move, [name]),\n    prepend: Object(react["useCallback"])(prepend$1, [name]),\n    append: Object(react["useCallback"])(append, [name, fields]),\n    remove: Object(react["useCallback"])(remove, [name]),\n    insert: Object(react["useCallback"])(insert$1, [name]),\n    fields: fields\n  };\n};\n\nfunction useWatch(_ref26) {\n  var control = _ref26.control,\n      name = _ref26.name,\n      defaultValue = _ref26.defaultValue;\n  var methods = index_esm_useFormContext();\n\n  if (false) {}\n\n  var _ref27 = control || methods.control,\n      useWatchFieldsRef = _ref27.useWatchFieldsRef,\n      useWatchRenderFunctionsRef = _ref27.useWatchRenderFunctionsRef,\n      watchInternal = _ref27.watchInternal,\n      defaultValuesRef = _ref27.defaultValuesRef;\n\n  var updateValue = Object(react["useState"])()[1];\n  var idRef = Object(react["useRef"])();\n  var defaultValueRef = Object(react["useRef"])(defaultValue);\n  Object(react["useEffect"])(function () {\n    if (false) {}\n\n    var id = idRef.current = generateId();\n    var watchFieldsHookRender = useWatchRenderFunctionsRef.current;\n    var watchFieldsHook = useWatchFieldsRef.current;\n    watchFieldsHook[id] = new Set();\n\n    watchFieldsHookRender[id] = function () {\n      return updateValue({});\n    };\n\n    watchInternal(name, defaultValueRef.current, id);\n    return function () {\n      delete watchFieldsHook[id];\n      delete watchFieldsHookRender[id];\n    };\n  }, [name, useWatchRenderFunctionsRef, useWatchFieldsRef, watchInternal, defaultValueRef]);\n  return idRef.current ? watchInternal(name, defaultValueRef.current, idRef.current) : isUndefined(defaultValue) ? isString(name) ? get(defaultValuesRef.current, name) : Array.isArray(name) ? name.reduce(function (previous, inputName) {\n    return Object.assign(Object.assign({}, previous), Object(defineProperty["a" /* default */])({}, inputName, get(defaultValuesRef.current, inputName)));\n  }, {}) : defaultValuesRef.current : defaultValue;\n}\n\nvar getInputValue = function getInputValue(event) {\n  return isPrimitive(event) || !isObject(event.target) || isObject(event.target) && !event.type ? event : isUndefined(event.target.value) ? event.target.checked : event.target.value;\n};\n\nfunction useField(_ref28) {\n  var name = _ref28.name,\n      rules = _ref28.rules,\n      defaultValue = _ref28.defaultValue,\n      control = _ref28.control,\n      onFocus = _ref28.onFocus;\n  var methods = index_esm_useFormContext();\n\n  if (false) {}\n\n  var _ref29 = control || methods.control,\n      defaultValuesRef = _ref29.defaultValuesRef,\n      setValue = _ref29.setValue,\n      register = _ref29.register,\n      unregister = _ref29.unregister,\n      trigger = _ref29.trigger,\n      mode = _ref29.mode,\n      _ref29$reValidateMode = _ref29.reValidateMode,\n      isReValidateOnBlur = _ref29$reValidateMode.isReValidateOnBlur,\n      isReValidateOnChange = _ref29$reValidateMode.isReValidateOnChange,\n      _ref29$formStateRef$c = _ref29.formStateRef.current,\n      isSubmitted = _ref29$formStateRef$c.isSubmitted,\n      touched = _ref29$formStateRef$c.touched,\n      errors = _ref29$formStateRef$c.errors,\n      dirtyFields = _ref29$formStateRef$c.dirtyFields,\n      updateFormState = _ref29.updateFormState,\n      readFormStateRef = _ref29.readFormStateRef,\n      fieldsRef = _ref29.fieldsRef,\n      fieldArrayNamesRef = _ref29.fieldArrayNamesRef,\n      shallowFieldsStateRef = _ref29.shallowFieldsStateRef;\n\n  var isNotFieldArray = !index_esm_isNameInFieldArray(fieldArrayNamesRef.current, name);\n\n  var getInitialValue = function getInitialValue() {\n    return !isUndefined(get(shallowFieldsStateRef.current, name)) && isNotFieldArray ? get(shallowFieldsStateRef.current, name) : isUndefined(defaultValue) ? get(defaultValuesRef.current, name) : defaultValue;\n  };\n\n  var _useState5 = Object(react["useState"])(getInitialValue()),\n      _useState6 = _slicedToArray(_useState5, 2),\n      value = _useState6[0],\n      setInputStateValue = _useState6[1];\n\n  var valueRef = Object(react["useRef"])(value);\n  var ref = Object(react["useRef"])({\n    focus: function focus() {\n      return null;\n    }\n  });\n  var onFocusRef = Object(react["useRef"])(onFocus || function () {\n    if (isFunction(ref.current.focus)) {\n      ref.current.focus();\n    }\n\n    if (false) {}\n  });\n  var shouldValidate = Object(react["useCallback"])(function (isBlurEvent) {\n    return !skipValidation(Object.assign({\n      isBlurEvent: isBlurEvent,\n      isReValidateOnBlur: isReValidateOnBlur,\n      isReValidateOnChange: isReValidateOnChange,\n      isSubmitted: isSubmitted,\n      isTouched: !!get(touched, name)\n    }, mode));\n  }, [isReValidateOnBlur, isReValidateOnChange, isSubmitted, touched, name, mode]);\n  var commonTask = Object(react["useCallback"])(function (_ref30) {\n    var _ref31 = _slicedToArray(_ref30, 1),\n        event = _ref31[0];\n\n    var data = getInputValue(event);\n    setInputStateValue(data);\n    valueRef.current = data;\n    return data;\n  }, []);\n  var registerField = Object(react["useCallback"])(function (shouldUpdateValue) {\n    if (false) {}\n\n    if (fieldsRef.current[name]) {\n      fieldsRef.current[name] = Object.assign({\n        ref: fieldsRef.current[name].ref\n      }, rules);\n    } else {\n      register(Object.defineProperty({\n        name: name,\n        focus: onFocusRef.current\n      }, \'value\', {\n        set: function set(data) {\n          setInputStateValue(data);\n          valueRef.current = data;\n        },\n        get: function get() {\n          return valueRef.current;\n        }\n      }), rules);\n      shouldUpdateValue = isUndefined(get(defaultValuesRef.current, name));\n    }\n\n    shouldUpdateValue && isNotFieldArray && setInputStateValue(getInitialValue());\n  }, [rules, name, register]);\n  Object(react["useEffect"])(function () {\n    return function () {\n      return unregister(name);\n    };\n  }, [name]);\n  Object(react["useEffect"])(function () {\n    if (false) {}\n\n    registerField();\n  }, [registerField]);\n  Object(react["useEffect"])(function () {\n    !fieldsRef.current[name] && registerField(true);\n  });\n  var onBlur = Object(react["useCallback"])(function () {\n    if (readFormStateRef.current.touched && !get(touched, name)) {\n      set(touched, name, true);\n      updateFormState({\n        touched: touched\n      });\n    }\n\n    shouldValidate(true) && trigger(name);\n  }, [name, updateFormState, shouldValidate, trigger, readFormStateRef]);\n  var onChange = Object(react["useCallback"])(function () {\n    for (var _len = arguments.length, event = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {\n      event[_key2] = arguments[_key2];\n    }\n\n    return setValue(name, commonTask(event), {\n      shouldValidate: shouldValidate(),\n      shouldDirty: true\n    });\n  }, [setValue, name, shouldValidate]);\n  return {\n    field: {\n      onChange: onChange,\n      onBlur: onBlur,\n      name: name,\n      value: value,\n      ref: ref\n    },\n    state: {\n      inValid: !get(errors, name),\n      isDirty: !!get(dirtyFields, name),\n      isTouched: !!get(touched, name)\n    }\n  };\n}\n\nvar index_esm_Controller = function Controller(props) {\n  var rules = props.rules,\n      as = props.as,\n      render = props.render,\n      defaultValue = props.defaultValue,\n      control = props.control,\n      onFocus = props.onFocus,\n      rest = __rest(props, ["rules", "as", "render", "defaultValue", "control", "onFocus"]);\n\n  var _useField = useField(props),\n      field = _useField.field;\n\n  var componentProps = Object.assign(Object.assign({}, rest), field);\n  return as ? Object(react["isValidElement"])(as) ? Object(react["cloneElement"])(as, componentProps) : Object(react["createElement"])(as, componentProps) : render ? render(field) : null;\n};\n\n\n// EXTERNAL MODULE: ./.cache/gatsby-browser-entry.js\nvar gatsby_browser_entry = __webpack_require__("Wbzz");\n\n// EXTERNAL MODULE: ./node_modules/cleave.js/react.js\nvar cleave_js_react = __webpack_require__("5VHT");\nvar cleave_js_react_default = /*#__PURE__*/__webpack_require__.n(cleave_js_react);\n\n// EXTERNAL MODULE: ./src/components/Layout/index.js + 3 modules\nvar Layout = __webpack_require__("Zttt");\n\n// EXTERNAL MODULE: ./src/components/Alert.js\nvar Alert = __webpack_require__("/9v8");\n\n// EXTERNAL MODULE: ./src/components/PrivateRoute.js\nvar PrivateRoute = __webpack_require__("nxaZ");\n\n// EXTERNAL MODULE: ./src/app/hooks/index.js + 11 modules\nvar hooks = __webpack_require__("NqsT");\n\n// CONCATENATED MODULE: ./src/pages/signup/index.js\nfunction ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly)symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){Object(defineProperty["a" /* default */])(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}var signup_Signup=function Signup(_ref){var _tourneyQuery$data,_userSignupQuery$data2,_tourneyQuery$data2,_tourneyQuery$data3,_tourneyQuery$data4;var location=_ref.location;var form=useForm({mode:"onTouched"});var tourneyQuery=Object(hooks["d" /* useTourney */])();var userSignupMut=Object(hooks["c" /* useMutUserSignup */])();var userDataMut=Object(hooks["b" /* useMutUserData */])();var userJoinedQuery=Object(hooks["g" /* useUserJoined */])();// Prepopulate data\nvar userDataQuery=Object(hooks["e" /* useUserData */])();var userSignupQuery=Object(hooks["h" /* useUserSignup */])();Object(react["useEffect"])(function(){var _userDataQuery$data,_userSignupQuery$data,_profile$stylepoints,_profile$stylepoints2,_profile$stylepoints3,_profile$stylepoints4;var profile=(_userDataQuery$data=userDataQuery.data)===null||_userDataQuery$data===void 0?void 0:_userDataQuery$data.profile;var signup=(_userSignupQuery$data=userSignupQuery.data)===null||_userSignupQuery$data===void 0?void 0:_userSignupQuery$data.data;form.reset(_objectSpread(_objectSpread({},profile),{},{stylepoints:{"sup-agg":profile===null||profile===void 0?void 0:(_profile$stylepoints=profile.stylepoints)===null||_profile$stylepoints===void 0?void 0:_profile$stylepoints.aggressive,"obj-sla":profile===null||profile===void 0?void 0:(_profile$stylepoints2=profile.stylepoints)===null||_profile$stylepoints2===void 0?void 0:_profile$stylepoints2.slayer,"anc-mob":profile===null||profile===void 0?void 0:(_profile$stylepoints3=profile.stylepoints)===null||_profile$stylepoints3===void 0?void 0:_profile$stylepoints3.mobile,"fle-foc":profile===null||profile===void 0?void 0:(_profile$stylepoints4=profile.stylepoints)===null||_profile$stylepoints4===void 0?void 0:_profile$stylepoints4.focused},smashgg:{link:profile!==null&&profile!==void 0&&profile.smashgg?"smash.gg/user/"+(profile===null||profile===void 0?void 0:profile.smashgg):undefined,code:signup===null||signup===void 0?void 0:signup.confirmationCode},recruiting:signup===null||signup===void 0?void 0:signup.recruiting,legal:signup===null||signup===void 0?void 0:signup.legal}));},[userDataQuery.data,userSignupQuery.data]);// Handle form submit\nvar handleSignup=function handleSignup(reg){var _reg$smashgg;var div=function div(n){return[Math.abs(n),Number(n)];};var _div=div(reg.stylepoints["sup-agg"]),support=_div[0],aggressive=_div[1];var _div2=div(reg.stylepoints["obj-sla"]),objective=_div2[0],slayer=_div2[1];var _div3=div(reg.stylepoints["anc-mob"]),anchor=_div3[0],mobile=_div3[1];var _div4=div(reg.stylepoints["fle-foc"]),flex=_div4[0],focused=_div4[1];var profile={ign:reg.ign,sw:reg.sw,ranks:{sz:reg.ranks.sz,tc:reg.ranks.tc,rm:reg.ranks.rm,cb:reg.ranks.cb},stylepoints:{support:support,aggressive:aggressive,objective:objective,slayer:slayer,anchor:anchor,mobile:mobile,flex:flex,focused:focused},cxp:{amount:reg.cxp.amount,placement:Number(reg.cxp.placement)},smashgg:reg.smashgg.link.split("/").slice(-1)[0]};var signup={tzOffset:new Date().getTimezoneOffset(),recruiting:Boolean(reg.recruiting),confirmationCode:((_reg$smashgg=reg.smashgg)===null||_reg$smashgg===void 0?void 0:_reg$smashgg.code)||"[sub]",legal:Boolean(reg.legal)};userDataMut.mutate(profile);userSignupMut.mutate(signup);Object(gatsby_browser_entry["c" /* navigate */])("complete",{state:{complete:true}});};return/*#__PURE__*/react_default.a.createElement(signup_FormContainer,{location:location},/*#__PURE__*/react_default.a.createElement(signup_FromStatusAlerts,{tourneyQuery:tourneyQuery,userSignupQuery:userSignupQuery,userJoinedQuery:userJoinedQuery}),/*#__PURE__*/react_default.a.createElement("form",{class:"form"},/*#__PURE__*/react_default.a.createElement("div",{class:"section px-0"},/*#__PURE__*/react_default.a.createElement("div",{class:"title"},"Enter your in-game info"),/*#__PURE__*/react_default.a.createElement("div",{class:"columns is-2 is-variable"},/*#__PURE__*/react_default.a.createElement("div",{class:"column"},/*#__PURE__*/react_default.a.createElement(signup_Field,{label:"In-game name",expanded:true},/*#__PURE__*/react_default.a.createElement(signup_Input,{name:"ign",control:form.control,errors:form.errors,options:{blocks:[10]},rules:{required:"This field is required"}}),/*#__PURE__*/react_default.a.createElement(signup_ErrorMessage,{options:[form.errors,"ign"]}))),/*#__PURE__*/react_default.a.createElement("div",{class:"column is-7"},/*#__PURE__*/react_default.a.createElement(signup_Field,{label:"Friend-code",expanded:true},/*#__PURE__*/react_default.a.createElement(signup_Input,{name:"sw",control:form.control,errors:form.errors,defaultValue:"SW-",options:{prefix:"SW",blocks:[2,4,4,4],delimiter:"-",numericOnly:true},rules:{minLength:{value:17,message:"This field is required"}}}),/*#__PURE__*/react_default.a.createElement(signup_ErrorMessage,{options:[form.errors,"sw"]})))),/*#__PURE__*/react_default.a.createElement("div",{class:"field"},/*#__PURE__*/react_default.a.createElement(signup_Field,{label:"Ranks"},/*#__PURE__*/react_default.a.createElement("div",{class:"columns is-2 is-variable"},/*#__PURE__*/react_default.a.createElement("div",{class:"column"},/*#__PURE__*/react_default.a.createElement("div",{class:"columns is-2 is-variable is-mobile"},/*#__PURE__*/react_default.a.createElement(signup_RankField,{label:"Splat Zones"},/*#__PURE__*/react_default.a.createElement(signup_Input,signup_rankProps("ranks.sz",form.control,form.errors)),/*#__PURE__*/react_default.a.createElement(signup_ErrorMessage,{options:[form.errors,"ranks.sz",/*#__PURE__*/react_default.a.createElement(signup_InvalidRank,null)]})),/*#__PURE__*/react_default.a.createElement(signup_RankField,{label:"Tower Control"},/*#__PURE__*/react_default.a.createElement(signup_Input,signup_rankProps("ranks.tc",form.control,form.errors)),/*#__PURE__*/react_default.a.createElement(signup_ErrorMessage,{options:[form.errors,"ranks.tc",/*#__PURE__*/react_default.a.createElement(signup_InvalidRank,null)]})))),/*#__PURE__*/react_default.a.createElement("div",{class:"column"},/*#__PURE__*/react_default.a.createElement("div",{class:"columns is-2 is-variable is-mobile"},/*#__PURE__*/react_default.a.createElement(signup_RankField,{label:"Rainmaker"},/*#__PURE__*/react_default.a.createElement(signup_Input,signup_rankProps("ranks.rm",form.control,form.errors)),/*#__PURE__*/react_default.a.createElement(signup_ErrorMessage,{options:[form.errors,"ranks.rm",/*#__PURE__*/react_default.a.createElement(signup_InvalidRank,null)]})),/*#__PURE__*/react_default.a.createElement(signup_RankField,{label:"Clam Blitz"},/*#__PURE__*/react_default.a.createElement(signup_Input,signup_rankProps("ranks.cb",form.control,form.errors)),/*#__PURE__*/react_default.a.createElement(signup_ErrorMessage,{options:[form.errors,"ranks.cb",/*#__PURE__*/react_default.a.createElement(signup_InvalidRank,null)]})))))))),/*#__PURE__*/react_default.a.createElement("div",{class:"section px-0 pt-5"},/*#__PURE__*/react_default.a.createElement("div",{class:"title"},"Set your stylepoints (playstyle)"),[["Supportive","Aggressive","How would you characterize your play?"],["Objective","Slayer","What do you focus on when playing?"],["Anchor","Mobile","What does your position look like?"],["Flexible","Focused","How would you describe your weapon pool?"]].map(function(field,index){return/*#__PURE__*/react_default.a.createElement("div",{key:index,class:"section px-0 py-4"},/*#__PURE__*/react_default.a.createElement(signup_Field,{label:field[2]},/*#__PURE__*/react_default.a.createElement("div",{class:"is-size-5 is-pulled-right"},field[1]),/*#__PURE__*/react_default.a.createElement("div",{class:"is-size-5"},field[0]),/*#__PURE__*/react_default.a.createElement("div",{class:"field"},/*#__PURE__*/react_default.a.createElement(index_esm_Controller,{control:form.control,as:/*#__PURE__*/react_default.a.createElement("input",null),defaultValue:5,class:"slider is-fullwidth is-large is-circle mt-0",type:"range",name:stylepointsName(field),id:field[0],min:"1",max:"9",step:"1"}))));})),/*#__PURE__*/react_default.a.createElement("div",{class:"section px-0"},/*#__PURE__*/react_default.a.createElement("div",{class:"title"},"Enter your competitive experience"),/*#__PURE__*/react_default.a.createElement("div",{class:"section px-0 py-4"},/*#__PURE__*/react_default.a.createElement(signup_Field,{label:"How many tournaments have you competed in?"},/*#__PURE__*/react_default.a.createElement("div",{class:"py-3"},["This is my first tournament :0","I\'ve played in one or two tournaments.","I\'ve played in some tournaments.","I\'ve played in a lot of tournaments."].map(function(field,index){return/*#__PURE__*/react_default.a.createElement("div",{key:index,class:"field"},/*#__PURE__*/react_default.a.createElement("input",{ref:form.register({required:"This field is required"}),value:field,class:"is-checkradio is-medium",name:"cxp.amount",type:"radio",id:field}),/*#__PURE__*/react_default.a.createElement("label",{htmlFor:field},field));})),/*#__PURE__*/react_default.a.createElement(signup_ErrorMessage,{options:[form.errors,"cxp.amount"]}))),/*#__PURE__*/react_default.a.createElement("div",{class:"section px-0 py-4"},/*#__PURE__*/react_default.a.createElement(signup_Field,{label:"What is the highest number of teams you\'ve placed above?"},/*#__PURE__*/react_default.a.createElement("div",{style:{maxWidth:"15rem"}},/*#__PURE__*/react_default.a.createElement(signup_Input,{name:"cxp.placement",control:form.control,errors:form.errors,options:{numericOnly:true,blocks:[4]}}),/*#__PURE__*/react_default.a.createElement("div",{class:"help"},"You can skip this if it\'s not applicable"))))),/*#__PURE__*/react_default.a.createElement("div",{class:"section px-0"},/*#__PURE__*/react_default.a.createElement("div",{class:"title"},"Set up smash.gg"),(!((_tourneyQuery$data=tourneyQuery.data)!==null&&_tourneyQuery$data!==void 0&&_tourneyQuery$data.hasClosed())||((_userSignupQuery$data2=userSignupQuery.data)===null||_userSignupQuery$data2===void 0?void 0:_userSignupQuery$data2.type)==="signup")&&/*#__PURE__*/react_default.a.createElement(react_default.a.Fragment,null,/*#__PURE__*/react_default.a.createElement(signup_Field,{label:"Register on smash.gg, copy the confirmation code when it pops up."},/*#__PURE__*/react_default.a.createElement("div",{class:"input is-normal p-1",style:{height:"600px"}},/*#__PURE__*/react_default.a.createElement("div",{style:{borderRadius:"4px",width:"100%",height:"100%",overflow:"hidden"}},/*#__PURE__*/react_default.a.createElement("iframe",{style:{borderWidth:"10px"},title:"smashgg",src:"https://smash.gg/"+((_tourneyQuery$data2=tourneyQuery.data)===null||_tourneyQuery$data2===void 0?void 0:_tourneyQuery$data2.slug)+"/register/embed",height:"100%",width:"100%"})))),/*#__PURE__*/react_default.a.createElement("div",{class:"field"},/*#__PURE__*/react_default.a.createElement("div",{class:"section px-0 py-4"},/*#__PURE__*/react_default.a.createElement(signup_Field,{label:"Enter your smash.gg confirmation code."},/*#__PURE__*/react_default.a.createElement("div",{style:{maxWidth:"20em"}},/*#__PURE__*/react_default.a.createElement("div",{class:"field has-addons"},/*#__PURE__*/react_default.a.createElement("div",{class:"control is-expanded"},/*#__PURE__*/react_default.a.createElement(signup_Input,{name:"smashgg.code",control:form.control,errors:form.errors,defaultValue:"#",options:{lowercase:true,blocks:[7],prefix:"#"},rules:{pattern:{value:/^#[0-9A-Fa-f]{6}$/,message:"Invalid confirmation code"},minLength:{value:2,message:"This field is required"}}})),/*#__PURE__*/react_default.a.createElement("div",{class:"control"},/*#__PURE__*/react_default.a.createElement("span",{class:"input ease is-medium px-5 is-static",style:{backgroundColor:form.watch("smashgg.code","#dbdbdb")}})))),/*#__PURE__*/react_default.a.createElement(signup_ErrorMessage,{options:[form.errors,"smashgg.code"]}))))),/*#__PURE__*/react_default.a.createElement(signup_Field,{label:/*#__PURE__*/react_default.a.createElement("div",{class:"is-size-4"},"Paste the url of your"," ",/*#__PURE__*/react_default.a.createElement("a",{href:"https://smash.gg/profile",target:"_blank",rel:"noreferrer"}," ","smash.gg profile"),".")},/*#__PURE__*/react_default.a.createElement("div",{style:{maxWidth:"20em"}},/*#__PURE__*/react_default.a.createElement("div",{class:"control is-medium has-icons-right"},/*#__PURE__*/react_default.a.createElement(signup_Input,{name:"smashgg.link",control:form.control,errors:form.errors,defaultValue:"smash.gg/user/",options:{lowercase:true,prefix:"smash.gg/user/",blocks:[22]},rules:{pattern:{value:/^smash\\.gg\\/user\\/[0-9A-Fa-f]{8}$/,message:"Invalid user slug"},minLength:{value:15,message:"This field is required"}}}))),/*#__PURE__*/react_default.a.createElement(signup_ErrorMessage,{options:[form.errors,"smashgg.link"]}))),/*#__PURE__*/react_default.a.createElement("div",{class:"section px-0 pt-5"},/*#__PURE__*/react_default.a.createElement("div",{class:"title"},"Final steps"),/*#__PURE__*/react_default.a.createElement("blockquote",{class:"subtitle"},"Misc stuff, are donuts considered bagels."),/*#__PURE__*/react_default.a.createElement("div",{class:"section px-0 py-4"},/*#__PURE__*/react_default.a.createElement(signup_Field,null,/*#__PURE__*/react_default.a.createElement("input",{ref:form.register,value:true,class:"is-checkradio is-medium",name:"recruiting",type:"checkbox",id:"cx-1"}),/*#__PURE__*/react_default.a.createElement("label",{htmlFor:"cx-1"},"Are you currently recruiting?")),/*#__PURE__*/react_default.a.createElement(signup_Field,null,/*#__PURE__*/react_default.a.createElement("input",{ref:form.register({required:"Please accept the terms and conditions"}),value:true,class:"is-checkradio is-medium",name:"legal",type:"checkbox",id:"cx-2"}),/*#__PURE__*/react_default.a.createElement("label",{htmlFor:"cx-2"},"I agree to the ",/*#__PURE__*/react_default.a.createElement(gatsby_browser_entry["a" /* Link */],{to:"/legal"},"terms and conditions"),"."),/*#__PURE__*/react_default.a.createElement(signup_ErrorMessage,{options:[form.errors,"legal"]})))),/*#__PURE__*/react_default.a.createElement(signup_Field,null,/*#__PURE__*/react_default.a.createElement("button",{type:"button",onClick:form.handleSubmit(handleSignup),class:"button is-centered is-primary is-large",disabled:!userJoinedQuery.data||((_tourneyQuery$data3=tourneyQuery.data)===null||_tourneyQuery$data3===void 0?void 0:_tourneyQuery$data3.hasEnded())},"Submit"),!userJoinedQuery.data&&/*#__PURE__*/react_default.a.createElement(signup_ErrorMessage,{options:[{submit:{message:"You must be in the Off the Dial discord server to participate"}},"submit"]}),((_tourneyQuery$data4=tourneyQuery.data)===null||_tourneyQuery$data4===void 0?void 0:_tourneyQuery$data4.hasEnded())&&/*#__PURE__*/react_default.a.createElement(signup_ErrorMessage,{options:[{submit:{message:"Registration is closed"}},"submit"]}))));};var signup_FormContainer=function FormContainer(_ref2){var location=_ref2.location,children=_ref2.children;return/*#__PURE__*/react_default.a.createElement(PrivateRoute["a" /* default */],{location:location},/*#__PURE__*/react_default.a.createElement(Layout["a" /* default */],{pageTitle:"Signup"},/*#__PURE__*/react_default.a.createElement("div",{class:"section"},/*#__PURE__*/react_default.a.createElement("div",{class:"container is-fullhd"},/*#__PURE__*/react_default.a.createElement("div",{class:"columns is-centered"},/*#__PURE__*/react_default.a.createElement("div",{class:"column is-9"},children))))));};var signup_FromStatusAlerts=function FromStatusAlerts(_ref3){var _tourneyQuery$data5;var tourneyQuery=_ref3.tourneyQuery,userSignupQuery=_ref3.userSignupQuery,userJoinedQuery=_ref3.userJoinedQuery;var alerts=[];if((_tourneyQuery$data5=tourneyQuery.data)!==null&&_tourneyQuery$data5!==void 0&&_tourneyQuery$data5.hasEnded()){alerts.push({type:"info",message:/*#__PURE__*/react_default.a.createElement(react_default.a.Fragment,null,/*#__PURE__*/react_default.a.createElement("b",null,"Registration is closed"),". Be on the look out for tournaments in the future!")});}else if(!tourneyQuery.isLoading){var _userSignupQuery$data3;if((_userSignupQuery$data3=userSignupQuery.data)!==null&&_userSignupQuery$data3!==void 0&&_userSignupQuery$data3.data){alerts.push({type:"info",message:/*#__PURE__*/react_default.a.createElement(react_default.a.Fragment,null,/*#__PURE__*/react_default.a.createElement("b",null,"You have already signed up"),". To update your signup information, re-submit this form.")});}else if(!userSignupQuery.isLoading){var _tourneyQuery$data6;if((_tourneyQuery$data6=tourneyQuery.data)!==null&&_tourneyQuery$data6!==void 0&&_tourneyQuery$data6.hasClosed()){alerts.push({type:"warning",message:/*#__PURE__*/react_default.a.createElement(react_default.a.Fragment,null,/*#__PURE__*/react_default.a.createElement("b",null,"Signups have closed"),". You can still submit this form and sign up as a sub.")});}}if(userJoinedQuery.data===false){alerts.push({type:"danger",message:/*#__PURE__*/react_default.a.createElement(react_default.a.Fragment,null,"You must be in the Off the Dial discord server to participate.")});}}return/*#__PURE__*/react_default.a.createElement(react_default.a.Fragment,null,alerts.map(function(alert,i){return/*#__PURE__*/react_default.a.createElement(Alert["a" /* default */],{type:alert.type,key:i},/*#__PURE__*/react_default.a.createElement("span",null,alert.message));}));};var signup_Field=function Field(_ref4){var label=_ref4.label,expanded=_ref4.expanded,children=_ref4.children;return/*#__PURE__*/react_default.a.createElement("div",{class:"field"},/*#__PURE__*/react_default.a.createElement("div",{class:"control "+(expanded&&"is-expanded")},label&&/*#__PURE__*/react_default.a.createElement("div",{class:"is-size-4"},label),children));};var signup_RankField=function RankField(_ref5){var label=_ref5.label,children=_ref5.children;return/*#__PURE__*/react_default.a.createElement("div",{class:"column"},/*#__PURE__*/react_default.a.createElement("div",{class:"control is-expanded"},/*#__PURE__*/react_default.a.createElement("div",{class:"is-size-5"},label),children));};var signup_Input=function Input(input){return/*#__PURE__*/react_default.a.createElement(index_esm_Controller,Object.assign({defaultValue:""},input,{className:"input is-medium "+(signup_get(input.errors,input.name)&&"is-danger"),as:/*#__PURE__*/react_default.a.createElement(cleave_js_react_default.a,null)}));};var signup_ErrorMessage=function ErrorMessage(_ref6){var _ref6$options=_ref6.options,errors=_ref6$options[0],name=_ref6$options[1],longest=_ref6$options[2];var error=signup_get(errors,name);if(error){return/*#__PURE__*/react_default.a.createElement("p",{class:"help is-danger"},error.message);}else{return/*#__PURE__*/react_default.a.createElement("p",{class:"help is-danger is-invisible"},longest||/*#__PURE__*/react_default.a.createElement("br",null));}};var signup_get=function get(obj,path){return path.split(".").reduce(function(acc,cur){return acc===null||acc===void 0?void 0:acc[cur];},obj);};var stylepointsName=function stylepointsName(_ref7){var left=_ref7[0],right=_ref7[1];var parse=function parse(field){return field.toLowerCase().slice(0,3);};return"stylepoints."+parse(left)+"-"+parse(right);};var signup_rankProps=function rankProps(name,control,errors){return{name:name,control:control,errors:errors,options:{delimiter:".",blocks:[5,1],uppercase:true},rules:{required:/*#__PURE__*/react_default.a.createElement(react_default.a.Fragment,null,"This field is required",/*#__PURE__*/react_default.a.createElement("br",null),/*#__PURE__*/react_default.a.createElement("br",null)),pattern:{value:/(^C-$)|(^C$)|(^C\\+$)|(^B-$)|(^B$)|(^B\\+$)|(^A-$)|(^A$)|(^A\\+$)|(^S$)|(^S\\+\\d$)|(^X[1-9]\\d{3}(\\.\\d)?$)/,message:/*#__PURE__*/react_default.a.createElement(signup_InvalidRank,null)}}};};var signup_InvalidRank=function InvalidRank(){return/*#__PURE__*/react_default.a.createElement(react_default.a.Fragment,null,"Invalid Rank",/*#__PURE__*/react_default.a.createElement("br",null),"ex:"," ",["C","A-","S+0","X2350.1"].map(function(field,index){return/*#__PURE__*/react_default.a.createElement("span",{key:index},/*#__PURE__*/react_default.a.createElement("code",{class:"has-text-danger",key:index},field),index!==3&&", ");}));};// const Signup = ({ location }) => (\n//   <PrivateRoute location={location} redirect="/signup" component={Form} />\n// )\n/* harmony default export */ var pages_signup = __webpack_exports__["default"] = (signup_Signup);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXJyYXlXaXRoSG9sZXMuanM/MGQyMSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaXRlcmFibGVUb0FycmF5TGltaXQuanM/MDlmMCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vbm9uSXRlcmFibGVSZXN0LmpzPzNkOGMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXkuanM/MzgzNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtaG9vay1mb3JtL2Rpc3QvaW5kZXguZXNtLmpzPzdhYmYiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BhZ2VzL3NpZ251cC9pbmRleC5qcz83MmRiIl0sIm5hbWVzIjpbIlNpZ251cCIsImxvY2F0aW9uIiwiZm9ybSIsInVzZUZvcm0iLCJtb2RlIiwidG91cm5leVF1ZXJ5IiwidXNlVG91cm5leSIsInVzZXJTaWdudXBNdXQiLCJ1c2VNdXRVc2VyU2lnbnVwIiwidXNlckRhdGFNdXQiLCJ1c2VNdXRVc2VyRGF0YSIsInVzZXJKb2luZWRRdWVyeSIsInVzZVVzZXJKb2luZWQiLCJ1c2VyRGF0YVF1ZXJ5IiwidXNlVXNlckRhdGEiLCJ1c2VyU2lnbnVwUXVlcnkiLCJ1c2VVc2VyU2lnbnVwIiwidXNlRWZmZWN0IiwicHJvZmlsZSIsImRhdGEiLCJzaWdudXAiLCJyZXNldCIsInN0eWxlcG9pbnRzIiwiYWdncmVzc2l2ZSIsInNsYXllciIsIm1vYmlsZSIsImZvY3VzZWQiLCJzbWFzaGdnIiwibGluayIsInVuZGVmaW5lZCIsImNvZGUiLCJjb25maXJtYXRpb25Db2RlIiwicmVjcnVpdGluZyIsImxlZ2FsIiwiaGFuZGxlU2lnbnVwIiwicmVnIiwiZGl2IiwibiIsIk1hdGgiLCJhYnMiLCJOdW1iZXIiLCJzdXBwb3J0Iiwib2JqZWN0aXZlIiwiYW5jaG9yIiwiZmxleCIsImlnbiIsInN3IiwicmFua3MiLCJzeiIsInRjIiwicm0iLCJjYiIsImN4cCIsImFtb3VudCIsInBsYWNlbWVudCIsInNwbGl0Iiwic2xpY2UiLCJ0ek9mZnNldCIsIkRhdGUiLCJnZXRUaW1lem9uZU9mZnNldCIsIkJvb2xlYW4iLCJtdXRhdGUiLCJuYXZpZ2F0ZSIsInN0YXRlIiwiY29tcGxldGUiLCJjb250cm9sIiwiZXJyb3JzIiwiYmxvY2tzIiwicmVxdWlyZWQiLCJwcmVmaXgiLCJkZWxpbWl0ZXIiLCJudW1lcmljT25seSIsIm1pbkxlbmd0aCIsInZhbHVlIiwibWVzc2FnZSIsInJhbmtQcm9wcyIsIm1hcCIsImZpZWxkIiwiaW5kZXgiLCJzdHlsZXBvaW50c05hbWUiLCJyZWdpc3RlciIsIm1heFdpZHRoIiwiaGFzQ2xvc2VkIiwidHlwZSIsImhlaWdodCIsImJvcmRlclJhZGl1cyIsIndpZHRoIiwib3ZlcmZsb3ciLCJib3JkZXJXaWR0aCIsInNsdWciLCJsb3dlcmNhc2UiLCJwYXR0ZXJuIiwiYmFja2dyb3VuZENvbG9yIiwid2F0Y2giLCJoYW5kbGVTdWJtaXQiLCJoYXNFbmRlZCIsInN1Ym1pdCIsIkZvcm1Db250YWluZXIiLCJjaGlsZHJlbiIsIkZyb21TdGF0dXNBbGVydHMiLCJhbGVydHMiLCJwdXNoIiwiaXNMb2FkaW5nIiwiYWxlcnQiLCJpIiwiRmllbGQiLCJsYWJlbCIsImV4cGFuZGVkIiwiUmFua0ZpZWxkIiwiSW5wdXQiLCJpbnB1dCIsImdldCIsIm5hbWUiLCJFcnJvck1lc3NhZ2UiLCJvcHRpb25zIiwibG9uZ2VzdCIsImVycm9yIiwib2JqIiwicGF0aCIsInJlZHVjZSIsImFjYyIsImN1ciIsImxlZnQiLCJyaWdodCIsInBhcnNlIiwidG9Mb3dlckNhc2UiLCJ1cHBlcmNhc2UiLCJydWxlcyIsIkludmFsaWRSYW5rIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBZTtBQUNmO0FBQ0EsQzs7QUNGZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkMsK0JBQStCO0FBQzVFOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEM7Ozs7O0FDekJlO0FBQ2Y7QUFDQSxDOztBQ0Z1RTtBQUNZO0FBQ1k7QUFDdEI7QUFDMUQ7QUFDZixTQUFTLGVBQWMsU0FBUyxxQkFBb0IsWUFBWSxxREFBMEIsWUFBWSxnQkFBZTtBQUNySCxDOzs7Ozs7Ozs7OztBQ055QztBQUM2RDtBQUNTO0FBQzFFO0FBQ2dGO0FBQ0o7QUFDTTs7QUFFdkgsd0RBQXdELFFBQVEsbUVBQW1FLHdIQUF3SCxnQkFBZ0IsV0FBVyx5QkFBeUIsU0FBUyx3QkFBd0IsNEJBQTRCLGNBQWMsU0FBUyw4QkFBOEIsRUFBRSxxQkFBcUIsVUFBVSxFQUFFLFNBQVMsRUFBRSw4SkFBOEosRUFBRSxrREFBa0QsU0FBUyxrQkFBa0IsMkJBQTJCLEVBQUUsbUJBQW1CLHNCQUFzQiw4QkFBOEIsYUFBYSxFQUFFLHNCQUFzQixlQUFlLFdBQVcsRUFBRSxtQkFBbUIsTUFBTSx5REFBeUQsRUFBRSxVQUFVLHVCQUF1QixFQUFFLEVBQUUsR0FBRzs7QUFFNzlCLGlEQUFpRCxnQkFBZ0IsZ0VBQWdFLHdEQUF3RCw2REFBNkQsc0RBQXNELGtIQUFrSDs7QUFFOVosc0NBQXNDLHVEQUF1RCx1Q0FBdUMsU0FBUyxPQUFPLGtCQUFrQixFQUFFLGFBQWE7O0FBRW5DOztBQUVsSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBLElBQUksZ0NBQXNCO0FBQzFCLFNBQVMsNENBQWtCO0FBQzNCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FB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Q0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0RBQXdEOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLGNBQWM7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrREFBK0Q7O0FBRS9EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFD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QSxPQUZLLENBR0xDLE1BQU0sQ0FBTkEsTUFISyxDQUlMZ0QsT0FBTyxDQUFFLENBQUU1QyxTQUFTLENBQUUsR0FBYixDQUFrQkgsTUFBTSxDQUFFLENBQUMsQ0FBRCxDQUFJLENBQUosQ0FBMUIsQ0FBa0MyRCxTQUFTLENBQUUsSUFBN0MsQ0FKSixDQUtMQyxLQUFLLENBQUUsQ0FDTDNELFFBQVEsY0FDTixrR0FFRSx3Q0FGRixjQUdFLHdDQUhGLENBRkcsQ0FRTHVCLE9BQU8sQ0FBRSxDQUNQbEIsS0FBSyxDQUFFLHVHQURBLENBRVBDLE9BQU8sY0FBRSw4QkFBQyxrQkFBRCxNQUZGLENBUkosQ0FMRixDQUFQLENBbUJELENBcEJELENBc0JBLEdBQU1zRCxtQkFBVyxDQUFHLFFBQWRBLFlBQWMsc0JBQ2xCLHdGQUVFLHdDQUZGLE9BR00sR0FITixDQUlHLENBQUMsR0FBRCxDQUFNLElBQU4sQ0FBWSxLQUFaLENBQW1CLFNBQW5CLEVBQThCcEQsR0FBOUIsQ0FBa0MsU0FBQ0MsS0FBRCxDQUFRQyxLQUFSLHFCQUNqQyxzQ0FBTSxHQUFHLENBQUVBLEtBQVgsZUFDRSxzQ0FBTSxLQUFLLENBQUMsaUJBQVosQ0FBOEIsR0FBRyxDQUFFQSxLQUFuQyxFQUNHRCxLQURILENBREYsQ0FJR0MsS0FBSyxHQUFLLENBQVYsRUFBZSxJQUpsQixDQURpQyxFQUFsQyxDQUpILENBRGtCLEVBQXBCLENBZ0JBO0FBQ0E7QUFDQTtBQUVlOUUsK0ZBQWYiLCJmaWxlIjoiY3R0QS5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8ICEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSkgcmV0dXJuO1xuICB2YXIgX2FyciA9IFtdO1xuICB2YXIgX24gPSB0cnVlO1xuICB2YXIgX2QgPSBmYWxzZTtcbiAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2QgPSB0cnVlO1xuICAgIF9lID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9hcnI7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn0iLCJpbXBvcnQgYXJyYXlXaXRoSG9sZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FycmF5V2l0aEhvbGVzXCI7XG5pbXBvcnQgaXRlcmFibGVUb0FycmF5TGltaXQgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2l0ZXJhYmxlVG9BcnJheUxpbWl0XCI7XG5pbXBvcnQgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5XCI7XG5pbXBvcnQgbm9uSXRlcmFibGVSZXN0IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9ub25JdGVyYWJsZVJlc3RcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgbm9uSXRlcmFibGVSZXN0KCk7XG59IiwiaW1wb3J0IFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnJlZHVjZVwiO1xuaW1wb3J0IF9yZWdlbmVyYXRvclJ1bnRpbWUgZnJvbSBcIi9ob21lL3J1bm5lci93b3JrL3NpdGUvc2l0ZS9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIjtcbmltcG9ydCBfc2xpY2VkVG9BcnJheSBmcm9tIFwiL2hvbWUvcnVubmVyL3dvcmsvc2l0ZS9zaXRlL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zbGljZWRUb0FycmF5XCI7XG5pbXBvcnQgXCJyZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWVcIjtcbmltcG9ydCBfYXN5bmNUb0dlbmVyYXRvciBmcm9tIFwiL2hvbWUvcnVubmVyL3dvcmsvc2l0ZS9zaXRlL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3luY1RvR2VuZXJhdG9yXCI7XG5pbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCIvaG9tZS9ydW5uZXIvd29yay9zaXRlL3NpdGUvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgX3RvQ29uc3VtYWJsZUFycmF5IGZyb20gXCIvaG9tZS9ydW5uZXIvd29yay9zaXRlL3NpdGUvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3RvQ29uc3VtYWJsZUFycmF5XCI7XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdDsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgb1tTeW1ib2wuaXRlcmF0b3JdID09IG51bGwpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXQucmV0dXJuICE9IG51bGwpIGl0LnJldHVybigpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuaW1wb3J0IHsgaXNWYWxpZEVsZW1lbnQsIHVzZVJlZiwgdXNlU3RhdGUsIHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZU1lbW8sIGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIGNyZWF0ZUVsZW1lbnQsIGNsb25lRWxlbWVudCB9IGZyb20gJ3JlYWN0JztcblxudmFyIGlzSFRNTEVsZW1lbnQgPSBmdW5jdGlvbiBpc0hUTUxFbGVtZW50KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xufTtcblxudmFyIEVWRU5UUyA9IHtcbiAgQkxVUjogJ2JsdXInLFxuICBDSEFOR0U6ICdjaGFuZ2UnLFxuICBJTlBVVDogJ2lucHV0J1xufTtcbnZhciBWQUxJREFUSU9OX01PREUgPSB7XG4gIG9uQmx1cjogJ29uQmx1cicsXG4gIG9uQ2hhbmdlOiAnb25DaGFuZ2UnLFxuICBvblN1Ym1pdDogJ29uU3VibWl0JyxcbiAgb25Ub3VjaGVkOiAnb25Ub3VjaGVkJyxcbiAgYWxsOiAnYWxsJ1xufTtcbnZhciBTRUxFQ1QgPSAnc2VsZWN0JztcbnZhciBVTkRFRklORUQgPSAndW5kZWZpbmVkJztcbnZhciBJTlBVVF9WQUxJREFUSU9OX1JVTEVTID0ge1xuICBtYXg6ICdtYXgnLFxuICBtaW46ICdtaW4nLFxuICBtYXhMZW5ndGg6ICdtYXhMZW5ndGgnLFxuICBtaW5MZW5ndGg6ICdtaW5MZW5ndGgnLFxuICBwYXR0ZXJuOiAncGF0dGVybicsXG4gIHJlcXVpcmVkOiAncmVxdWlyZWQnLFxuICB2YWxpZGF0ZTogJ3ZhbGlkYXRlJ1xufTtcblxuZnVuY3Rpb24gYXR0YWNoRXZlbnRMaXN0ZW5lcnMoX3JlZiwgc2hvdWxkQXR0YWNoQ2hhbmdlRXZlbnQsIGhhbmRsZUNoYW5nZSkge1xuICB2YXIgcmVmID0gX3JlZi5yZWY7XG5cbiAgaWYgKGlzSFRNTEVsZW1lbnQocmVmKSAmJiBoYW5kbGVDaGFuZ2UpIHtcbiAgICByZWYuYWRkRXZlbnRMaXN0ZW5lcihzaG91bGRBdHRhY2hDaGFuZ2VFdmVudCA/IEVWRU5UUy5DSEFOR0UgOiBFVkVOVFMuSU5QVVQsIGhhbmRsZUNoYW5nZSk7XG4gICAgcmVmLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlRTLkJMVVIsIGhhbmRsZUNoYW5nZSk7XG4gIH1cbn1cblxudmFyIGlzTnVsbE9yVW5kZWZpbmVkID0gZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGw7XG59O1xuXG52YXIgaXNPYmplY3RUeXBlID0gZnVuY3Rpb24gaXNPYmplY3RUeXBlKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnO1xufTtcblxudmFyIGlzT2JqZWN0ID0gZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuICFpc051bGxPclVuZGVmaW5lZCh2YWx1ZSkgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpICYmIGlzT2JqZWN0VHlwZSh2YWx1ZSkgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpO1xufTtcblxudmFyIGlzS2V5ID0gZnVuY3Rpb24gaXNLZXkodmFsdWUpIHtcbiAgcmV0dXJuIC9eXFx3KiQvLnRlc3QodmFsdWUpO1xufTtcblxudmFyIGNvbXBhY3QgPSBmdW5jdGlvbiBjb21wYWN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5maWx0ZXIoQm9vbGVhbik7XG59O1xuXG52YXIgc3RyaW5nVG9QYXRoID0gZnVuY3Rpb24gc3RyaW5nVG9QYXRoKGlucHV0KSB7XG4gIHJldHVybiBjb21wYWN0KGlucHV0LnJlcGxhY2UoL1tcInwnXS9nLCAnJykucmVwbGFjZSgvXFxbL2csICcuJykucmVwbGFjZSgvXFxdL2csICcnKS5zcGxpdCgnLicpKTtcbn07XG5cbmZ1bmN0aW9uIHNldChvYmplY3QsIHBhdGgsIHZhbHVlKSB7XG4gIHZhciBpbmRleCA9IC0xO1xuICB2YXIgdGVtcFBhdGggPSBpc0tleShwYXRoKSA/IFtwYXRoXSA6IHN0cmluZ1RvUGF0aChwYXRoKTtcbiAgdmFyIGxlbmd0aCA9IHRlbXBQYXRoLmxlbmd0aDtcbiAgdmFyIGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gdGVtcFBhdGhbaW5kZXhdO1xuICAgIHZhciBuZXdWYWx1ZSA9IHZhbHVlO1xuXG4gICAgaWYgKGluZGV4ICE9PSBsYXN0SW5kZXgpIHtcbiAgICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgbmV3VmFsdWUgPSBpc09iamVjdChvYmpWYWx1ZSkgfHwgQXJyYXkuaXNBcnJheShvYmpWYWx1ZSkgPyBvYmpWYWx1ZSA6ICFpc05hTigrdGVtcFBhdGhbaW5kZXggKyAxXSkgPyBbXSA6IHt9O1xuICAgIH1cblxuICAgIG9iamVjdFtrZXldID0gbmV3VmFsdWU7XG4gICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gIH1cblxuICByZXR1cm4gb2JqZWN0O1xufVxuXG52YXIgdHJhbnNmb3JtVG9OZXN0T2JqZWN0ID0gZnVuY3Rpb24gdHJhbnNmb3JtVG9OZXN0T2JqZWN0KGRhdGEpIHtcbiAgdmFyIHZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICFpc0tleShrZXkpID8gc2V0KHZhbHVlLCBrZXksIGRhdGFba2V5XSkgOiB2YWx1ZVtrZXldID0gZGF0YVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxudmFyIGlzVW5kZWZpbmVkID0gZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsKSB7XG4gIHJldHVybiB2YWwgPT09IHVuZGVmaW5lZDtcbn07XG5cbnZhciBnZXQgPSBmdW5jdGlvbiBnZXQoKSB7XG4gIHZhciBvYmogPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICB2YXIgcGF0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICB2YXIgZGVmYXVsdFZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gIHZhciByZXN1bHQgPSBjb21wYWN0KHBhdGguc3BsaXQoL1ssW1xcXS5dKz8vKSkucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGtleSkge1xuICAgIHJldHVybiBpc051bGxPclVuZGVmaW5lZChyZXN1bHQpID8gcmVzdWx0IDogcmVzdWx0W2tleV07XG4gIH0sIG9iaik7XG4gIHJldHVybiBpc1VuZGVmaW5lZChyZXN1bHQpIHx8IHJlc3VsdCA9PT0gb2JqID8gaXNVbmRlZmluZWQob2JqW3BhdGhdKSA/IGRlZmF1bHRWYWx1ZSA6IG9ialtwYXRoXSA6IHJlc3VsdDtcbn07XG5cbnZhciBmb2N1c09uRXJyb3JGaWVsZCA9IGZ1bmN0aW9uIGZvY3VzT25FcnJvckZpZWxkKGZpZWxkcywgZmllbGRFcnJvcnMpIHtcbiAgZm9yICh2YXIga2V5IGluIGZpZWxkcykge1xuICAgIGlmIChnZXQoZmllbGRFcnJvcnMsIGtleSkpIHtcbiAgICAgIHZhciBmaWVsZCA9IGZpZWxkc1trZXldO1xuXG4gICAgICBpZiAoZmllbGQpIHtcbiAgICAgICAgaWYgKGZpZWxkLnJlZi5mb2N1cyAmJiBpc1VuZGVmaW5lZChmaWVsZC5yZWYuZm9jdXMoKSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmIChmaWVsZC5vcHRpb25zKSB7XG4gICAgICAgICAgZmllbGQub3B0aW9uc1swXS5yZWYuZm9jdXMoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIHJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gcmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMocmVmLCB2YWxpZGF0ZVdpdGhTdGF0ZVVwZGF0ZSkge1xuICBpZiAoaXNIVE1MRWxlbWVudChyZWYpICYmIHJlZi5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgcmVmLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlRTLklOUFVULCB2YWxpZGF0ZVdpdGhTdGF0ZVVwZGF0ZSk7XG4gICAgcmVmLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlRTLkNIQU5HRSwgdmFsaWRhdGVXaXRoU3RhdGVVcGRhdGUpO1xuICAgIHJlZi5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5UUy5CTFVSLCB2YWxpZGF0ZVdpdGhTdGF0ZVVwZGF0ZSk7XG4gIH1cbn07XG5cbnZhciBkZWZhdWx0UmV0dXJuID0ge1xuICBpc1ZhbGlkOiBmYWxzZSxcbiAgdmFsdWU6ICcnXG59O1xuXG52YXIgZ2V0UmFkaW9WYWx1ZSA9IGZ1bmN0aW9uIGdldFJhZGlvVmFsdWUob3B0aW9ucykge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShvcHRpb25zKSA/IG9wdGlvbnMucmVkdWNlKGZ1bmN0aW9uIChwcmV2aW91cywgb3B0aW9uKSB7XG4gICAgcmV0dXJuIG9wdGlvbiAmJiBvcHRpb24ucmVmLmNoZWNrZWQgPyB7XG4gICAgICBpc1ZhbGlkOiB0cnVlLFxuICAgICAgdmFsdWU6IG9wdGlvbi5yZWYudmFsdWVcbiAgICB9IDogcHJldmlvdXM7XG4gIH0sIGRlZmF1bHRSZXR1cm4pIDogZGVmYXVsdFJldHVybjtcbn07XG5cbnZhciBnZXRNdWx0aXBsZVNlbGVjdFZhbHVlID0gZnVuY3Rpb24gZ2V0TXVsdGlwbGVTZWxlY3RWYWx1ZShvcHRpb25zKSB7XG4gIHJldHVybiBfdG9Db25zdW1hYmxlQXJyYXkob3B0aW9ucykuZmlsdGVyKGZ1bmN0aW9uIChfcmVmMikge1xuICAgIHZhciBzZWxlY3RlZCA9IF9yZWYyLnNlbGVjdGVkO1xuICAgIHJldHVybiBzZWxlY3RlZDtcbiAgfSkubWFwKGZ1bmN0aW9uIChfcmVmMykge1xuICAgIHZhciB2YWx1ZSA9IF9yZWYzLnZhbHVlO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSk7XG59O1xuXG52YXIgaXNSYWRpb0lucHV0ID0gZnVuY3Rpb24gaXNSYWRpb0lucHV0KGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQudHlwZSA9PT0gJ3JhZGlvJztcbn07XG5cbnZhciBpc0ZpbGVJbnB1dCA9IGZ1bmN0aW9uIGlzRmlsZUlucHV0KGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQudHlwZSA9PT0gJ2ZpbGUnO1xufTtcblxudmFyIGlzQ2hlY2tCb3hJbnB1dCA9IGZ1bmN0aW9uIGlzQ2hlY2tCb3hJbnB1dChlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50LnR5cGUgPT09ICdjaGVja2JveCc7XG59O1xuXG52YXIgaXNNdWx0aXBsZVNlbGVjdCA9IGZ1bmN0aW9uIGlzTXVsdGlwbGVTZWxlY3QoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudC50eXBlID09PSBcIlwiLmNvbmNhdChTRUxFQ1QsIFwiLW11bHRpcGxlXCIpO1xufTtcblxudmFyIGRlZmF1bHRSZXN1bHQgPSB7XG4gIHZhbHVlOiBmYWxzZSxcbiAgaXNWYWxpZDogZmFsc2Vcbn07XG52YXIgdmFsaWRSZXN1bHQgPSB7XG4gIHZhbHVlOiB0cnVlLFxuICBpc1ZhbGlkOiB0cnVlXG59O1xuXG52YXIgZ2V0Q2hlY2tib3hWYWx1ZSA9IGZ1bmN0aW9uIGdldENoZWNrYm94VmFsdWUob3B0aW9ucykge1xuICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgIGlmIChvcHRpb25zLmxlbmd0aCA+IDEpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSBvcHRpb25zLmZpbHRlcihmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgIHJldHVybiBvcHRpb24gJiYgb3B0aW9uLnJlZi5jaGVja2VkO1xuICAgICAgfSkubWFwKGZ1bmN0aW9uIChfcmVmNCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBfcmVmNC5yZWYudmFsdWU7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlcyxcbiAgICAgICAgaXNWYWxpZDogISF2YWx1ZXMubGVuZ3RoXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBfb3B0aW9ucyQwJHJlZiA9IG9wdGlvbnNbMF0ucmVmLFxuICAgICAgICBjaGVja2VkID0gX29wdGlvbnMkMCRyZWYuY2hlY2tlZCxcbiAgICAgICAgdmFsdWUgPSBfb3B0aW9ucyQwJHJlZi52YWx1ZSxcbiAgICAgICAgYXR0cmlidXRlcyA9IF9vcHRpb25zJDAkcmVmLmF0dHJpYnV0ZXM7XG4gICAgcmV0dXJuIGNoZWNrZWQgPyBhdHRyaWJ1dGVzICYmICFpc1VuZGVmaW5lZChhdHRyaWJ1dGVzLnZhbHVlKSA/IGlzVW5kZWZpbmVkKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJycgPyB2YWxpZFJlc3VsdCA6IHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGlzVmFsaWQ6IHRydWVcbiAgICB9IDogdmFsaWRSZXN1bHQgOiBkZWZhdWx0UmVzdWx0O1xuICB9XG5cbiAgcmV0dXJuIGRlZmF1bHRSZXN1bHQ7XG59O1xuXG5mdW5jdGlvbiBnZXRGaWVsZFZhbHVlKGZpZWxkc1JlZiwgbmFtZSwgc2hhbGxvd0ZpZWxkc1N0YXRlUmVmLCBleGNsdWRlRGlzYWJsZWQpIHtcbiAgdmFyIGZpZWxkID0gZmllbGRzUmVmLmN1cnJlbnRbbmFtZV07XG5cbiAgaWYgKGZpZWxkKSB7XG4gICAgdmFyIF9maWVsZCRyZWYgPSBmaWVsZC5yZWYsXG4gICAgICAgIHZhbHVlID0gX2ZpZWxkJHJlZi52YWx1ZSxcbiAgICAgICAgZGlzYWJsZWQgPSBfZmllbGQkcmVmLmRpc2FibGVkLFxuICAgICAgICByZWYgPSBmaWVsZC5yZWYsXG4gICAgICAgIHZhbHVlQXNOdW1iZXIgPSBmaWVsZC52YWx1ZUFzTnVtYmVyLFxuICAgICAgICB2YWx1ZUFzRGF0ZSA9IGZpZWxkLnZhbHVlQXNEYXRlLFxuICAgICAgICBzZXRWYWx1ZUFzID0gZmllbGQuc2V0VmFsdWVBcztcblxuICAgIGlmIChkaXNhYmxlZCAmJiBleGNsdWRlRGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNGaWxlSW5wdXQocmVmKSkge1xuICAgICAgcmV0dXJuIHJlZi5maWxlcztcbiAgICB9XG5cbiAgICBpZiAoaXNSYWRpb0lucHV0KHJlZikpIHtcbiAgICAgIHJldHVybiBnZXRSYWRpb1ZhbHVlKGZpZWxkLm9wdGlvbnMpLnZhbHVlO1xuICAgIH1cblxuICAgIGlmIChpc011bHRpcGxlU2VsZWN0KHJlZikpIHtcbiAgICAgIHJldHVybiBnZXRNdWx0aXBsZVNlbGVjdFZhbHVlKHJlZi5vcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAoaXNDaGVja0JveElucHV0KHJlZikpIHtcbiAgICAgIHJldHVybiBnZXRDaGVja2JveFZhbHVlKGZpZWxkLm9wdGlvbnMpLnZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZUFzTnVtYmVyID8gK3ZhbHVlIDogdmFsdWVBc0RhdGUgPyByZWYudmFsdWVBc0RhdGUgOiBzZXRWYWx1ZUFzID8gc2V0VmFsdWVBcyh2YWx1ZSkgOiB2YWx1ZTtcbiAgfVxuXG4gIGlmIChzaGFsbG93RmllbGRzU3RhdGVSZWYpIHtcbiAgICByZXR1cm4gZ2V0KHNoYWxsb3dGaWVsZHNTdGF0ZVJlZi5jdXJyZW50LCBuYW1lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0RldGFjaGVkKGVsZW1lbnQpIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoIShlbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHx8IGVsZW1lbnQubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfTk9ERSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc0RldGFjaGVkKGVsZW1lbnQucGFyZW50Tm9kZSk7XG59XG5cbnZhciBpc0VtcHR5T2JqZWN0ID0gZnVuY3Rpb24gaXNFbXB0eU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmICFPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoO1xufTtcblxudmFyIGlzQm9vbGVhbiA9IGZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbic7XG59O1xuXG5mdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgdXBkYXRlUGF0aCkge1xuICB2YXIgcGF0aCA9IHVwZGF0ZVBhdGguc2xpY2UoMCwgLTEpO1xuICB2YXIgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDA7XG5cbiAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgb2JqZWN0ID0gaXNVbmRlZmluZWQob2JqZWN0KSA/IGluZGV4KysgOiBvYmplY3RbdXBkYXRlUGF0aFtpbmRleCsrXV07XG4gIH1cblxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5mdW5jdGlvbiB1bnNldChvYmplY3QsIHBhdGgpIHtcbiAgdmFyIHVwZGF0ZVBhdGggPSBpc0tleShwYXRoKSA/IFtwYXRoXSA6IHN0cmluZ1RvUGF0aChwYXRoKTtcbiAgdmFyIGNoaWxkT2JqZWN0ID0gdXBkYXRlUGF0aC5sZW5ndGggPT0gMSA/IG9iamVjdCA6IGJhc2VHZXQob2JqZWN0LCB1cGRhdGVQYXRoKTtcbiAgdmFyIGtleSA9IHVwZGF0ZVBhdGhbdXBkYXRlUGF0aC5sZW5ndGggLSAxXTtcbiAgdmFyIHByZXZpb3VzT2JqUmVmID0gdW5kZWZpbmVkO1xuXG4gIGlmIChjaGlsZE9iamVjdCkge1xuICAgIGRlbGV0ZSBjaGlsZE9iamVjdFtrZXldO1xuICB9XG5cbiAgZm9yICh2YXIgayA9IDA7IGsgPCB1cGRhdGVQYXRoLnNsaWNlKDAsIC0xKS5sZW5ndGg7IGsrKykge1xuICAgIHZhciBpbmRleCA9IC0xO1xuICAgIHZhciBvYmplY3RSZWYgPSB1bmRlZmluZWQ7XG4gICAgdmFyIGN1cnJlbnRQYXRocyA9IHVwZGF0ZVBhdGguc2xpY2UoMCwgLShrICsgMSkpO1xuICAgIHZhciBjdXJyZW50UGF0aHNMZW5ndGggPSBjdXJyZW50UGF0aHMubGVuZ3RoIC0gMTtcblxuICAgIGlmIChrID4gMCkge1xuICAgICAgcHJldmlvdXNPYmpSZWYgPSBvYmplY3Q7XG4gICAgfVxuXG4gICAgd2hpbGUgKCsraW5kZXggPCBjdXJyZW50UGF0aHMubGVuZ3RoKSB7XG4gICAgICB2YXIgaXRlbSA9IGN1cnJlbnRQYXRoc1tpbmRleF07XG4gICAgICBvYmplY3RSZWYgPSBvYmplY3RSZWYgPyBvYmplY3RSZWZbaXRlbV0gOiBvYmplY3RbaXRlbV07XG5cbiAgICAgIGlmIChjdXJyZW50UGF0aHNMZW5ndGggPT09IGluZGV4ICYmIChpc09iamVjdChvYmplY3RSZWYpICYmIGlzRW1wdHlPYmplY3Qob2JqZWN0UmVmKSB8fCBBcnJheS5pc0FycmF5KG9iamVjdFJlZikgJiYgIW9iamVjdFJlZi5maWx0ZXIoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGlzT2JqZWN0KGRhdGEpICYmICFpc0VtcHR5T2JqZWN0KGRhdGEpIHx8IGlzQm9vbGVhbihkYXRhKTtcbiAgICAgIH0pLmxlbmd0aCkpIHtcbiAgICAgICAgcHJldmlvdXNPYmpSZWYgPyBkZWxldGUgcHJldmlvdXNPYmpSZWZbaXRlbV0gOiBkZWxldGUgb2JqZWN0W2l0ZW1dO1xuICAgICAgfVxuXG4gICAgICBwcmV2aW91c09ialJlZiA9IG9iamVjdFJlZjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqZWN0O1xufVxuXG52YXIgaXNTYW1lUmVmID0gZnVuY3Rpb24gaXNTYW1lUmVmKGZpZWxkVmFsdWUsIHJlZikge1xuICByZXR1cm4gZmllbGRWYWx1ZSAmJiBmaWVsZFZhbHVlLnJlZiA9PT0gcmVmO1xufTtcblxuZnVuY3Rpb24gZmluZFJlbW92ZWRGaWVsZEFuZFJlbW92ZUxpc3RlbmVyKGZpZWxkc1JlZiwgaGFuZGxlQ2hhbmdlLCBmaWVsZCwgc2hhbGxvd0ZpZWxkc1N0YXRlUmVmLCBzaG91bGRVbnJlZ2lzdGVyLCBmb3JjZURlbGV0ZSkge1xuICB2YXIgcmVmID0gZmllbGQucmVmLFxuICAgICAgbmFtZSA9IGZpZWxkLnJlZi5uYW1lO1xuICB2YXIgZmllbGRSZWYgPSBmaWVsZHNSZWYuY3VycmVudFtuYW1lXTtcblxuICBpZiAoIXNob3VsZFVucmVnaXN0ZXIpIHtcbiAgICB2YXIgdmFsdWUgPSBnZXRGaWVsZFZhbHVlKGZpZWxkc1JlZiwgbmFtZSwgc2hhbGxvd0ZpZWxkc1N0YXRlUmVmKTtcbiAgICAhaXNVbmRlZmluZWQodmFsdWUpICYmIHNldChzaGFsbG93RmllbGRzU3RhdGVSZWYuY3VycmVudCwgbmFtZSwgdmFsdWUpO1xuICB9XG5cbiAgaWYgKCFyZWYudHlwZSB8fCAhZmllbGRSZWYpIHtcbiAgICBkZWxldGUgZmllbGRzUmVmLmN1cnJlbnRbbmFtZV07XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGlzUmFkaW9JbnB1dChyZWYpIHx8IGlzQ2hlY2tCb3hJbnB1dChyZWYpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZmllbGRSZWYub3B0aW9ucykgJiYgZmllbGRSZWYub3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgIGNvbXBhY3QoZmllbGRSZWYub3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvcHRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgICB2YXIgaW5kZXggPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAoaXNEZXRhY2hlZChvcHRpb24ucmVmKSAmJiBpc1NhbWVSZWYob3B0aW9uLCBvcHRpb24ucmVmKSB8fCBmb3JjZURlbGV0ZSkge1xuICAgICAgICAgIHJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzKG9wdGlvbi5yZWYsIGhhbmRsZUNoYW5nZSk7XG4gICAgICAgICAgdW5zZXQoZmllbGRSZWYub3B0aW9ucywgXCJbXCIuY29uY2F0KGluZGV4LCBcIl1cIikpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKGZpZWxkUmVmLm9wdGlvbnMgJiYgIWNvbXBhY3QoZmllbGRSZWYub3B0aW9ucykubGVuZ3RoKSB7XG4gICAgICAgIGRlbGV0ZSBmaWVsZHNSZWYuY3VycmVudFtuYW1lXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIGZpZWxkc1JlZi5jdXJyZW50W25hbWVdO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0RldGFjaGVkKHJlZikgJiYgaXNTYW1lUmVmKGZpZWxkUmVmLCByZWYpIHx8IGZvcmNlRGVsZXRlKSB7XG4gICAgcmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMocmVmLCBoYW5kbGVDaGFuZ2UpO1xuICAgIGRlbGV0ZSBmaWVsZHNSZWYuY3VycmVudFtuYW1lXTtcbiAgfVxufVxuXG52YXIgaXNQcmltaXRpdmUgPSBmdW5jdGlvbiBpc1ByaW1pdGl2ZSh2YWx1ZSkge1xuICByZXR1cm4gaXNOdWxsT3JVbmRlZmluZWQodmFsdWUpIHx8ICFpc09iamVjdFR5cGUodmFsdWUpO1xufTtcblxuZnVuY3Rpb24gZGVlcE1lcmdlKHRhcmdldCwgc291cmNlKSB7XG4gIGlmIChpc1ByaW1pdGl2ZSh0YXJnZXQpIHx8IGlzUHJpbWl0aXZlKHNvdXJjZSkpIHtcbiAgICByZXR1cm4gc291cmNlO1xuICB9XG5cbiAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgIHZhciB0YXJnZXRWYWx1ZSA9IHRhcmdldFtrZXldO1xuICAgIHZhciBzb3VyY2VWYWx1ZSA9IHNvdXJjZVtrZXldO1xuXG4gICAgdHJ5IHtcbiAgICAgIHRhcmdldFtrZXldID0gaXNPYmplY3QodGFyZ2V0VmFsdWUpICYmIGlzT2JqZWN0KHNvdXJjZVZhbHVlKSB8fCBBcnJheS5pc0FycmF5KHRhcmdldFZhbHVlKSAmJiBBcnJheS5pc0FycmF5KHNvdXJjZVZhbHVlKSA/IGRlZXBNZXJnZSh0YXJnZXRWYWx1ZSwgc291cmNlVmFsdWUpIDogc291cmNlVmFsdWU7XG4gICAgfSBjYXRjaCAoX2EpIHt9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBzZXREaXJ0eUZpZWxkcyh2YWx1ZXMsIGRlZmF1bHRWYWx1ZXMsIGRpcnR5RmllbGRzLCBwYXJlbnROb2RlLCBwYXJlbnROYW1lKSB7XG4gIHZhciBpbmRleCA9IC0xO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgdmFsdWVzLmxlbmd0aCkge1xuICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZXNbaW5kZXhdKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXNbaW5kZXhdW2tleV0pKSB7XG4gICAgICAgICFkaXJ0eUZpZWxkc1tpbmRleF0gJiYgKGRpcnR5RmllbGRzW2luZGV4XSA9IHt9KTtcbiAgICAgICAgZGlydHlGaWVsZHNbaW5kZXhdW2tleV0gPSBbXTtcbiAgICAgICAgc2V0RGlydHlGaWVsZHModmFsdWVzW2luZGV4XVtrZXldLCBnZXQoZGVmYXVsdFZhbHVlc1tpbmRleF0gfHwge30sIGtleSwgW10pLCBkaXJ0eUZpZWxkc1tpbmRleF1ba2V5XSwgZGlydHlGaWVsZHNbaW5kZXhdLCBrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2V0KGRlZmF1bHRWYWx1ZXNbaW5kZXhdIHx8IHt9LCBrZXkpID09PSB2YWx1ZXNbaW5kZXhdW2tleV0gPyBzZXQoZGlydHlGaWVsZHNbaW5kZXhdIHx8IHt9LCBrZXkpIDogZGlydHlGaWVsZHNbaW5kZXhdID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkaXJ0eUZpZWxkc1tpbmRleF0pLCBfZGVmaW5lUHJvcGVydHkoe30sIGtleSwgdHJ1ZSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBhcmVudE5vZGUgJiYgIWRpcnR5RmllbGRzLmxlbmd0aCAmJiBkZWxldGUgcGFyZW50Tm9kZVtwYXJlbnROYW1lXTtcbiAgfVxuXG4gIHJldHVybiBkaXJ0eUZpZWxkcztcbn1cblxudmFyIHNldEZpZWxkQXJyYXlEaXJ0eUZpZWxkcyA9IGZ1bmN0aW9uIHNldEZpZWxkQXJyYXlEaXJ0eUZpZWxkcyh2YWx1ZXMsIGRlZmF1bHRWYWx1ZXMsIGRpcnR5RmllbGRzKSB7XG4gIHJldHVybiBkZWVwTWVyZ2Uoc2V0RGlydHlGaWVsZHModmFsdWVzLCBkZWZhdWx0VmFsdWVzLCBkaXJ0eUZpZWxkcyksIHNldERpcnR5RmllbGRzKGRlZmF1bHRWYWx1ZXMsIHZhbHVlcywgZGlydHlGaWVsZHMpKTtcbn07XG5cbnZhciBpc1N0cmluZyA9IGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xufTtcblxudmFyIGdldEZpZWxkc1ZhbHVlcyA9IGZ1bmN0aW9uIGdldEZpZWxkc1ZhbHVlcyhmaWVsZHNSZWYsIHNoYWxsb3dGaWVsZHNTdGF0ZSwgc2hvdWxkVW5yZWdpc3RlciwgZXhjbHVkZURpc2FibGVkLCBzZWFyY2gpIHtcbiAgdmFyIG91dHB1dCA9IHt9O1xuXG4gIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKG5hbWUpIHtcbiAgICBpZiAoaXNVbmRlZmluZWQoc2VhcmNoKSB8fCAoaXNTdHJpbmcoc2VhcmNoKSA/IG5hbWUuc3RhcnRzV2l0aChzZWFyY2gpIDogQXJyYXkuaXNBcnJheShzZWFyY2gpICYmIHNlYXJjaC5maW5kKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICByZXR1cm4gbmFtZS5zdGFydHNXaXRoKGRhdGEpO1xuICAgIH0pKSkge1xuICAgICAgb3V0cHV0W25hbWVdID0gZ2V0RmllbGRWYWx1ZShmaWVsZHNSZWYsIG5hbWUsIHVuZGVmaW5lZCwgZXhjbHVkZURpc2FibGVkKTtcbiAgICB9XG4gIH07XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBmaWVsZHNSZWYuY3VycmVudCkge1xuICAgIF9sb29wKG5hbWUpO1xuICB9XG5cbiAgcmV0dXJuIHNob3VsZFVucmVnaXN0ZXIgPyB0cmFuc2Zvcm1Ub05lc3RPYmplY3Qob3V0cHV0KSA6IGRlZXBNZXJnZShzaGFsbG93RmllbGRzU3RhdGUsIHRyYW5zZm9ybVRvTmVzdE9iamVjdChvdXRwdXQpKTtcbn07XG5cbmZ1bmN0aW9uIGRlZXBFcXVhbChvYmplY3QxLCBvYmplY3QyLCBpc0Vycm9yT2JqZWN0KSB7XG4gIGlmIChpc1ByaW1pdGl2ZShvYmplY3QxKSB8fCBpc1ByaW1pdGl2ZShvYmplY3QyKSB8fCBvYmplY3QxIGluc3RhbmNlb2YgRGF0ZSB8fCBvYmplY3QyIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHJldHVybiBvYmplY3QxID09PSBvYmplY3QyO1xuICB9XG5cbiAgaWYgKCFpc1ZhbGlkRWxlbWVudChvYmplY3QxKSkge1xuICAgIHZhciBrZXlzMSA9IE9iamVjdC5rZXlzKG9iamVjdDEpO1xuICAgIHZhciBrZXlzMiA9IE9iamVjdC5rZXlzKG9iamVjdDIpO1xuXG4gICAgaWYgKGtleXMxLmxlbmd0aCAhPT0ga2V5czIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2kgPSAwLCBfa2V5cyA9IGtleXMxOyBfaSA8IF9rZXlzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGtleSA9IF9rZXlzW19pXTtcbiAgICAgIHZhciB2YWwxID0gb2JqZWN0MVtrZXldO1xuXG4gICAgICBpZiAoIShpc0Vycm9yT2JqZWN0ICYmIGtleSA9PT0gJ3JlZicpKSB7XG4gICAgICAgIHZhciB2YWwyID0gb2JqZWN0MltrZXldO1xuXG4gICAgICAgIGlmICgoaXNPYmplY3QodmFsMSkgfHwgQXJyYXkuaXNBcnJheSh2YWwxKSkgJiYgKGlzT2JqZWN0KHZhbDIpIHx8IEFycmF5LmlzQXJyYXkodmFsMikpID8gIWRlZXBFcXVhbCh2YWwxLCB2YWwyLCBpc0Vycm9yT2JqZWN0KSA6IHZhbDEgIT09IHZhbDIpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxudmFyIGlzRXJyb3JTdGF0ZUNoYW5nZWQgPSBmdW5jdGlvbiBpc0Vycm9yU3RhdGVDaGFuZ2VkKF9yZWY1KSB7XG4gIHZhciBlcnJvcnMgPSBfcmVmNS5lcnJvcnMsXG4gICAgICBuYW1lID0gX3JlZjUubmFtZSxcbiAgICAgIGVycm9yID0gX3JlZjUuZXJyb3IsXG4gICAgICB2YWxpZEZpZWxkcyA9IF9yZWY1LnZhbGlkRmllbGRzLFxuICAgICAgZmllbGRzV2l0aFZhbGlkYXRpb24gPSBfcmVmNS5maWVsZHNXaXRoVmFsaWRhdGlvbjtcbiAgdmFyIGlzVmFsaWQgPSBpc1VuZGVmaW5lZChlcnJvcik7XG4gIHZhciBwcmV2aW91c0Vycm9yID0gZ2V0KGVycm9ycywgbmFtZSk7XG4gIHJldHVybiBpc1ZhbGlkICYmICEhcHJldmlvdXNFcnJvciB8fCAhaXNWYWxpZCAmJiAhZGVlcEVxdWFsKHByZXZpb3VzRXJyb3IsIGVycm9yLCB0cnVlKSB8fCBpc1ZhbGlkICYmIGdldChmaWVsZHNXaXRoVmFsaWRhdGlvbiwgbmFtZSkgJiYgIWdldCh2YWxpZEZpZWxkcywgbmFtZSk7XG59O1xuXG52YXIgaXNSZWdleCA9IGZ1bmN0aW9uIGlzUmVnZXgodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwO1xufTtcblxudmFyIGdldFZhbHVlQW5kTWVzc2FnZSA9IGZ1bmN0aW9uIGdldFZhbHVlQW5kTWVzc2FnZSh2YWxpZGF0aW9uRGF0YSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsaWRhdGlvbkRhdGEpICYmICFpc1JlZ2V4KHZhbGlkYXRpb25EYXRhKSA/IHZhbGlkYXRpb25EYXRhIDoge1xuICAgIHZhbHVlOiB2YWxpZGF0aW9uRGF0YSxcbiAgICBtZXNzYWdlOiAnJ1xuICB9O1xufTtcblxudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG59O1xuXG52YXIgaXNNZXNzYWdlID0gZnVuY3Rpb24gaXNNZXNzYWdlKHZhbHVlKSB7XG4gIHJldHVybiBpc1N0cmluZyh2YWx1ZSkgfHwgaXNWYWxpZEVsZW1lbnQodmFsdWUpO1xufTtcblxuZnVuY3Rpb24gZ2V0VmFsaWRhdGVFcnJvcihyZXN1bHQsIHJlZikge1xuICB2YXIgdHlwZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJ3ZhbGlkYXRlJztcblxuICBpZiAoaXNNZXNzYWdlKHJlc3VsdCkgfHwgaXNCb29sZWFuKHJlc3VsdCkgJiYgIXJlc3VsdCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgbWVzc2FnZTogaXNNZXNzYWdlKHJlc3VsdCkgPyByZXN1bHQgOiAnJyxcbiAgICAgIHJlZjogcmVmXG4gICAgfTtcbiAgfVxufVxuXG52YXIgYXBwZW5kRXJyb3JzID0gZnVuY3Rpb24gYXBwZW5kRXJyb3JzKG5hbWUsIHZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSwgZXJyb3JzLCB0eXBlLCBtZXNzYWdlKSB7XG4gIHJldHVybiB2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGVycm9yc1tuYW1lXSksIHtcbiAgICB0eXBlczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBlcnJvcnNbbmFtZV0gJiYgZXJyb3JzW25hbWVdLnR5cGVzID8gZXJyb3JzW25hbWVdLnR5cGVzIDoge30pLCBfZGVmaW5lUHJvcGVydHkoe30sIHR5cGUsIG1lc3NhZ2UgfHwgdHJ1ZSkpXG4gIH0pIDoge307XG59O1xuXG52YXIgdmFsaWRhdGVGaWVsZCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIHZhciBfcmVmNyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoZmllbGRzUmVmLCB2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEsIF9yZWY2LCBzaGFsbG93RmllbGRzU3RhdGVSZWYpIHtcbiAgICB2YXIgcmVmLCB2YWx1ZSwgb3B0aW9ucywgcmVxdWlyZWQsIG1heExlbmd0aCwgbWluTGVuZ3RoLCBtaW4sIG1heCwgcGF0dGVybiwgdmFsaWRhdGUsIG5hbWUsIGVycm9yLCBpc1JhZGlvLCBpc0NoZWNrQm94LCBpc1JhZGlvT3JDaGVja2JveCwgaXNFbXB0eSwgYXBwZW5kRXJyb3JzQ3VycnksIGdldE1pbk1heE1lc3NhZ2UsIF9yZWY4LCBfdmFsdWUsIG1lc3NhZ2UsIGV4Y2VlZE1heCwgZXhjZWVkTWluLCBtYXhPdXRwdXQsIG1pbk91dHB1dCwgdmFsdWVOdW1iZXIsIHZhbHVlRGF0ZSwgbWF4TGVuZ3RoT3V0cHV0LCBtaW5MZW5ndGhPdXRwdXQsIF9leGNlZWRNYXgsIF9leGNlZWRNaW4sIF9nZXRWYWx1ZUFuZE1lc3NhZ2UsIHBhdHRlcm5WYWx1ZSwgX21lc3NhZ2UsIGZpZWxkVmFsdWUsIHZhbGlkYXRlUmVmLCByZXN1bHQsIHZhbGlkYXRlRXJyb3IsIHZhbGlkYXRpb25SZXN1bHQsIF9pMiwgX09iamVjdCRlbnRyaWVzLCBfT2JqZWN0JGVudHJpZXMkX2ksIGtleSwgdmFsaWRhdGVGdW5jdGlvbiwgdmFsaWRhdGVSZXN1bHQsIF92YWxpZGF0ZUVycm9yO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHJlZiA9IF9yZWY2LnJlZiwgdmFsdWUgPSBfcmVmNi5yZWYudmFsdWUsIG9wdGlvbnMgPSBfcmVmNi5vcHRpb25zLCByZXF1aXJlZCA9IF9yZWY2LnJlcXVpcmVkLCBtYXhMZW5ndGggPSBfcmVmNi5tYXhMZW5ndGgsIG1pbkxlbmd0aCA9IF9yZWY2Lm1pbkxlbmd0aCwgbWluID0gX3JlZjYubWluLCBtYXggPSBfcmVmNi5tYXgsIHBhdHRlcm4gPSBfcmVmNi5wYXR0ZXJuLCB2YWxpZGF0ZSA9IF9yZWY2LnZhbGlkYXRlO1xuICAgICAgICAgICAgbmFtZSA9IHJlZi5uYW1lO1xuICAgICAgICAgICAgZXJyb3IgPSB7fTtcbiAgICAgICAgICAgIGlzUmFkaW8gPSBpc1JhZGlvSW5wdXQocmVmKTtcbiAgICAgICAgICAgIGlzQ2hlY2tCb3ggPSBpc0NoZWNrQm94SW5wdXQocmVmKTtcbiAgICAgICAgICAgIGlzUmFkaW9PckNoZWNrYm94ID0gaXNSYWRpbyB8fCBpc0NoZWNrQm94O1xuICAgICAgICAgICAgaXNFbXB0eSA9IHZhbHVlID09PSAnJztcbiAgICAgICAgICAgIGFwcGVuZEVycm9yc0N1cnJ5ID0gYXBwZW5kRXJyb3JzLmJpbmQobnVsbCwgbmFtZSwgdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhLCBlcnJvcik7XG5cbiAgICAgICAgICAgIGdldE1pbk1heE1lc3NhZ2UgPSBmdW5jdGlvbiBnZXRNaW5NYXhNZXNzYWdlKGV4Y2VlZE1heCwgbWF4TGVuZ3RoTWVzc2FnZSwgbWluTGVuZ3RoTWVzc2FnZSkge1xuICAgICAgICAgICAgICB2YXIgbWF4VHlwZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogSU5QVVRfVkFMSURBVElPTl9SVUxFUy5tYXhMZW5ndGg7XG4gICAgICAgICAgICAgIHZhciBtaW5UeXBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBJTlBVVF9WQUxJREFUSU9OX1JVTEVTLm1pbkxlbmd0aDtcbiAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBleGNlZWRNYXggPyBtYXhMZW5ndGhNZXNzYWdlIDogbWluTGVuZ3RoTWVzc2FnZTtcbiAgICAgICAgICAgICAgZXJyb3JbbmFtZV0gPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBleGNlZWRNYXggPyBtYXhUeXBlIDogbWluVHlwZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgIHJlZjogcmVmXG4gICAgICAgICAgICAgIH0sIGV4Y2VlZE1heCA/IGFwcGVuZEVycm9yc0N1cnJ5KG1heFR5cGUsIG1lc3NhZ2UpIDogYXBwZW5kRXJyb3JzQ3VycnkobWluVHlwZSwgbWVzc2FnZSkpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKCEocmVxdWlyZWQgJiYgKCFpc1JhZGlvICYmICFpc0NoZWNrQm94ICYmIChpc0VtcHR5IHx8IGlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSkgfHwgaXNCb29sZWFuKHZhbHVlKSAmJiAhdmFsdWUgfHwgaXNDaGVja0JveCAmJiAhZ2V0Q2hlY2tib3hWYWx1ZShvcHRpb25zKS5pc1ZhbGlkIHx8IGlzUmFkaW8gJiYgIWdldFJhZGlvVmFsdWUob3B0aW9ucykuaXNWYWxpZCkpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9yZWY4ID0gaXNNZXNzYWdlKHJlcXVpcmVkKSA/IHtcbiAgICAgICAgICAgICAgdmFsdWU6ICEhcmVxdWlyZWQsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IHJlcXVpcmVkXG4gICAgICAgICAgICB9IDogZ2V0VmFsdWVBbmRNZXNzYWdlKHJlcXVpcmVkKSwgX3ZhbHVlID0gX3JlZjgudmFsdWUsIG1lc3NhZ2UgPSBfcmVmOC5tZXNzYWdlO1xuXG4gICAgICAgICAgICBpZiAoIV92YWx1ZSkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlcnJvcltuYW1lXSA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICB0eXBlOiBJTlBVVF9WQUxJREFUSU9OX1JVTEVTLnJlcXVpcmVkLFxuICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgICAgICByZWY6IGlzUmFkaW9PckNoZWNrYm94ID8gKChmaWVsZHNSZWYuY3VycmVudFtuYW1lXS5vcHRpb25zIHx8IFtdKVswXSB8fCB7fSkucmVmIDogcmVmXG4gICAgICAgICAgICB9LCBhcHBlbmRFcnJvcnNDdXJyeShJTlBVVF9WQUxJREFUSU9OX1JVTEVTLnJlcXVpcmVkLCBtZXNzYWdlKSk7XG5cbiAgICAgICAgICAgIGlmICh2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE1O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBlcnJvcik7XG5cbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgaWYgKCEoKCFpc051bGxPclVuZGVmaW5lZChtaW4pIHx8ICFpc051bGxPclVuZGVmaW5lZChtYXgpKSAmJiB2YWx1ZSAhPT0gJycpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyMztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1heE91dHB1dCA9IGdldFZhbHVlQW5kTWVzc2FnZShtYXgpO1xuICAgICAgICAgICAgbWluT3V0cHV0ID0gZ2V0VmFsdWVBbmRNZXNzYWdlKG1pbik7XG5cbiAgICAgICAgICAgIGlmICghaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbHVlTnVtYmVyID0gcmVmLnZhbHVlQXNOdW1iZXIgfHwgcGFyc2VGbG9hdCh2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChtYXhPdXRwdXQudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZXhjZWVkTWF4ID0gdmFsdWVOdW1iZXIgPiBtYXhPdXRwdXQudmFsdWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKG1pbk91dHB1dC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBleGNlZWRNaW4gPSB2YWx1ZU51bWJlciA8IG1pbk91dHB1dC52YWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFsdWVEYXRlID0gcmVmLnZhbHVlQXNEYXRlIHx8IG5ldyBEYXRlKHZhbHVlKTtcblxuICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcobWF4T3V0cHV0LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGV4Y2VlZE1heCA9IHZhbHVlRGF0ZSA+IG5ldyBEYXRlKG1heE91dHB1dC52YWx1ZSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcobWluT3V0cHV0LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGV4Y2VlZE1pbiA9IHZhbHVlRGF0ZSA8IG5ldyBEYXRlKG1pbk91dHB1dC52YWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEoZXhjZWVkTWF4IHx8IGV4Y2VlZE1pbikpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDIzO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2V0TWluTWF4TWVzc2FnZSghIWV4Y2VlZE1heCwgbWF4T3V0cHV0Lm1lc3NhZ2UsIG1pbk91dHB1dC5tZXNzYWdlLCBJTlBVVF9WQUxJREFUSU9OX1JVTEVTLm1heCwgSU5QVVRfVkFMSURBVElPTl9SVUxFUy5taW4pO1xuXG4gICAgICAgICAgICBpZiAodmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyMztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgZXJyb3IpO1xuXG4gICAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICAgIGlmICghKGlzU3RyaW5nKHZhbHVlKSAmJiAhaXNFbXB0eSAmJiAobWF4TGVuZ3RoIHx8IG1pbkxlbmd0aCkpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1heExlbmd0aE91dHB1dCA9IGdldFZhbHVlQW5kTWVzc2FnZShtYXhMZW5ndGgpO1xuICAgICAgICAgICAgbWluTGVuZ3RoT3V0cHV0ID0gZ2V0VmFsdWVBbmRNZXNzYWdlKG1pbkxlbmd0aCk7XG4gICAgICAgICAgICBfZXhjZWVkTWF4ID0gIWlzTnVsbE9yVW5kZWZpbmVkKG1heExlbmd0aE91dHB1dC52YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID4gbWF4TGVuZ3RoT3V0cHV0LnZhbHVlO1xuICAgICAgICAgICAgX2V4Y2VlZE1pbiA9ICFpc051bGxPclVuZGVmaW5lZChtaW5MZW5ndGhPdXRwdXQudmFsdWUpICYmIHZhbHVlLmxlbmd0aCA8IG1pbkxlbmd0aE91dHB1dC52YWx1ZTtcblxuICAgICAgICAgICAgaWYgKCEoX2V4Y2VlZE1heCB8fCBfZXhjZWVkTWluKSkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMzI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnZXRNaW5NYXhNZXNzYWdlKF9leGNlZWRNYXgsIG1heExlbmd0aE91dHB1dC5tZXNzYWdlLCBtaW5MZW5ndGhPdXRwdXQubWVzc2FnZSk7XG5cbiAgICAgICAgICAgIGlmICh2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDMyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBlcnJvcik7XG5cbiAgICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgICAgaWYgKCEocGF0dGVybiAmJiAhaXNFbXB0eSkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM4O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2dldFZhbHVlQW5kTWVzc2FnZSA9IGdldFZhbHVlQW5kTWVzc2FnZShwYXR0ZXJuKSwgcGF0dGVyblZhbHVlID0gX2dldFZhbHVlQW5kTWVzc2FnZS52YWx1ZSwgX21lc3NhZ2UgPSBfZ2V0VmFsdWVBbmRNZXNzYWdlLm1lc3NhZ2U7XG5cbiAgICAgICAgICAgIGlmICghKGlzUmVnZXgocGF0dGVyblZhbHVlKSAmJiAhcGF0dGVyblZhbHVlLnRlc3QodmFsdWUpKSkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMzg7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlcnJvcltuYW1lXSA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICB0eXBlOiBJTlBVVF9WQUxJREFUSU9OX1JVTEVTLnBhdHRlcm4sXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IF9tZXNzYWdlLFxuICAgICAgICAgICAgICByZWY6IHJlZlxuICAgICAgICAgICAgfSwgYXBwZW5kRXJyb3JzQ3VycnkoSU5QVVRfVkFMSURBVElPTl9SVUxFUy5wYXR0ZXJuLCBfbWVzc2FnZSkpO1xuXG4gICAgICAgICAgICBpZiAodmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzODtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgZXJyb3IpO1xuXG4gICAgICAgICAgY2FzZSAzODpcbiAgICAgICAgICAgIGlmICghdmFsaWRhdGUpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDcxO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmllbGRWYWx1ZSA9IGdldEZpZWxkVmFsdWUoZmllbGRzUmVmLCBuYW1lLCBzaGFsbG93RmllbGRzU3RhdGVSZWYpO1xuICAgICAgICAgICAgdmFsaWRhdGVSZWYgPSBpc1JhZGlvT3JDaGVja2JveCAmJiBvcHRpb25zID8gb3B0aW9uc1swXS5yZWYgOiByZWY7XG5cbiAgICAgICAgICAgIGlmICghaXNGdW5jdGlvbih2YWxpZGF0ZSkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDUyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDQ0O1xuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlKGZpZWxkVmFsdWUpO1xuXG4gICAgICAgICAgY2FzZSA0NDpcbiAgICAgICAgICAgIHJlc3VsdCA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICB2YWxpZGF0ZUVycm9yID0gZ2V0VmFsaWRhdGVFcnJvcihyZXN1bHQsIHZhbGlkYXRlUmVmKTtcblxuICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZUVycm9yKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA1MDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVycm9yW25hbWVdID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB2YWxpZGF0ZUVycm9yKSwgYXBwZW5kRXJyb3JzQ3VycnkoSU5QVVRfVkFMSURBVElPTl9SVUxFUy52YWxpZGF0ZSwgdmFsaWRhdGVFcnJvci5tZXNzYWdlKSk7XG5cbiAgICAgICAgICAgIGlmICh2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDUwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBlcnJvcik7XG5cbiAgICAgICAgICBjYXNlIDUwOlxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDcxO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDUyOlxuICAgICAgICAgICAgaWYgKCFpc09iamVjdCh2YWxpZGF0ZSkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDcxO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgX2kyID0gMCwgX09iamVjdCRlbnRyaWVzID0gT2JqZWN0LmVudHJpZXModmFsaWRhdGUpO1xuXG4gICAgICAgICAgY2FzZSA1NTpcbiAgICAgICAgICAgIGlmICghKF9pMiA8IF9PYmplY3QkZW50cmllcy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA2NztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9PYmplY3QkZW50cmllcyRfaSA9IF9zbGljZWRUb0FycmF5KF9PYmplY3QkZW50cmllc1tfaTJdLCAyKSwga2V5ID0gX09iamVjdCRlbnRyaWVzJF9pWzBdLCB2YWxpZGF0ZUZ1bmN0aW9uID0gX09iamVjdCRlbnRyaWVzJF9pWzFdO1xuXG4gICAgICAgICAgICBpZiAoISghaXNFbXB0eU9iamVjdCh2YWxpZGF0aW9uUmVzdWx0KSAmJiAhdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhKSkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNTk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwiYnJlYWtcIiwgNjcpO1xuXG4gICAgICAgICAgY2FzZSA1OTpcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA2MTtcbiAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZUZ1bmN0aW9uKGZpZWxkVmFsdWUpO1xuXG4gICAgICAgICAgY2FzZSA2MTpcbiAgICAgICAgICAgIHZhbGlkYXRlUmVzdWx0ID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgIF92YWxpZGF0ZUVycm9yID0gZ2V0VmFsaWRhdGVFcnJvcih2YWxpZGF0ZVJlc3VsdCwgdmFsaWRhdGVSZWYsIGtleSk7XG5cbiAgICAgICAgICAgIGlmIChfdmFsaWRhdGVFcnJvcikge1xuICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBfdmFsaWRhdGVFcnJvciksIGFwcGVuZEVycm9yc0N1cnJ5KGtleSwgX3ZhbGlkYXRlRXJyb3IubWVzc2FnZSkpO1xuXG4gICAgICAgICAgICAgIGlmICh2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpIHtcbiAgICAgICAgICAgICAgICBlcnJvcltuYW1lXSA9IHZhbGlkYXRpb25SZXN1bHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgNjQ6XG4gICAgICAgICAgICBfaTIrKztcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA1NTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSA2NzpcbiAgICAgICAgICAgIGlmIChpc0VtcHR5T2JqZWN0KHZhbGlkYXRpb25SZXN1bHQpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA3MTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVycm9yW25hbWVdID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgIHJlZjogdmFsaWRhdGVSZWZcbiAgICAgICAgICAgIH0sIHZhbGlkYXRpb25SZXN1bHQpO1xuXG4gICAgICAgICAgICBpZiAodmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA3MTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgZXJyb3IpO1xuXG4gICAgICAgICAgY2FzZSA3MTpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgZXJyb3IpO1xuXG4gICAgICAgICAgY2FzZSA3MjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSk7XG4gIH0pKTtcblxuICByZXR1cm4gZnVuY3Rpb24gdmFsaWRhdGVGaWVsZChfeCwgX3gyLCBfeDMsIF94NCkge1xuICAgIHJldHVybiBfcmVmNy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufSgpO1xuXG52YXIgZ2V0UGF0aCA9IGZ1bmN0aW9uIGdldFBhdGgocm9vdFBhdGgsIHZhbHVlcykge1xuICB2YXIgcGF0aHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFtdO1xuXG4gIGZvciAodmFyIHByb3BlcnR5IGluIHZhbHVlcykge1xuICAgIHZhciByb290TmFtZSA9IHJvb3RQYXRoICsgKGlzT2JqZWN0KHZhbHVlcykgPyBcIi5cIi5jb25jYXQocHJvcGVydHkpIDogXCJbXCIuY29uY2F0KHByb3BlcnR5LCBcIl1cIikpO1xuICAgIGlzUHJpbWl0aXZlKHZhbHVlc1twcm9wZXJ0eV0pID8gcGF0aHMucHVzaChyb290TmFtZSkgOiBnZXRQYXRoKHJvb3ROYW1lLCB2YWx1ZXNbcHJvcGVydHldLCBwYXRocyk7XG4gIH1cblxuICByZXR1cm4gcGF0aHM7XG59O1xuXG52YXIgYXNzaWduV2F0Y2hGaWVsZHMgPSBmdW5jdGlvbiBhc3NpZ25XYXRjaEZpZWxkcyhmaWVsZFZhbHVlcywgZmllbGROYW1lLCB3YXRjaEZpZWxkcywgaW5wdXRWYWx1ZSwgaXNTaW5nbGVGaWVsZCkge1xuICB2YXIgdmFsdWUgPSB1bmRlZmluZWQ7XG4gIHdhdGNoRmllbGRzLmFkZChmaWVsZE5hbWUpO1xuXG4gIGlmICghaXNFbXB0eU9iamVjdChmaWVsZFZhbHVlcykpIHtcbiAgICB2YWx1ZSA9IGdldChmaWVsZFZhbHVlcywgZmllbGROYW1lKTtcblxuICAgIGlmIChpc09iamVjdCh2YWx1ZSkgfHwgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGdldFBhdGgoZmllbGROYW1lLCB2YWx1ZSkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gd2F0Y2hGaWVsZHMuYWRkKG5hbWUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGlzVW5kZWZpbmVkKHZhbHVlKSA/IGlzU2luZ2xlRmllbGQgPyBpbnB1dFZhbHVlIDogZ2V0KGlucHV0VmFsdWUsIGZpZWxkTmFtZSkgOiB2YWx1ZTtcbn07XG5cbnZhciBza2lwVmFsaWRhdGlvbiA9IGZ1bmN0aW9uIHNraXBWYWxpZGF0aW9uKF9yZWY5KSB7XG4gIHZhciBpc09uQmx1ciA9IF9yZWY5LmlzT25CbHVyLFxuICAgICAgaXNPbkNoYW5nZSA9IF9yZWY5LmlzT25DaGFuZ2UsXG4gICAgICBpc09uVG91Y2ggPSBfcmVmOS5pc09uVG91Y2gsXG4gICAgICBpc1RvdWNoZWQgPSBfcmVmOS5pc1RvdWNoZWQsXG4gICAgICBpc1JlVmFsaWRhdGVPbkJsdXIgPSBfcmVmOS5pc1JlVmFsaWRhdGVPbkJsdXIsXG4gICAgICBpc1JlVmFsaWRhdGVPbkNoYW5nZSA9IF9yZWY5LmlzUmVWYWxpZGF0ZU9uQ2hhbmdlLFxuICAgICAgaXNCbHVyRXZlbnQgPSBfcmVmOS5pc0JsdXJFdmVudCxcbiAgICAgIGlzU3VibWl0dGVkID0gX3JlZjkuaXNTdWJtaXR0ZWQsXG4gICAgICBpc09uQWxsID0gX3JlZjkuaXNPbkFsbDtcblxuICBpZiAoaXNPbkFsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmICghaXNTdWJtaXR0ZWQgJiYgaXNPblRvdWNoKSB7XG4gICAgcmV0dXJuICEoaXNUb3VjaGVkIHx8IGlzQmx1ckV2ZW50KTtcbiAgfSBlbHNlIGlmIChpc1N1Ym1pdHRlZCA/IGlzUmVWYWxpZGF0ZU9uQmx1ciA6IGlzT25CbHVyKSB7XG4gICAgcmV0dXJuICFpc0JsdXJFdmVudDtcbiAgfSBlbHNlIGlmIChpc1N1Ym1pdHRlZCA/IGlzUmVWYWxpZGF0ZU9uQ2hhbmdlIDogaXNPbkNoYW5nZSkge1xuICAgIHJldHVybiBpc0JsdXJFdmVudDtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIGdldEZpZWxkQXJyYXlQYXJlbnROYW1lID0gZnVuY3Rpb24gZ2V0RmllbGRBcnJheVBhcmVudE5hbWUobmFtZSkge1xuICByZXR1cm4gbmFtZS5zdWJzdHJpbmcoMCwgbmFtZS5pbmRleE9mKCdbJykpO1xufTtcblxudmFyIGlzTWF0Y2hGaWVsZEFycmF5TmFtZSA9IGZ1bmN0aW9uIGlzTWF0Y2hGaWVsZEFycmF5TmFtZShuYW1lLCBzZWFyY2hOYW1lKSB7XG4gIHJldHVybiBSZWdFeHAoXCJeXCIuY29uY2F0KHNlYXJjaE5hbWUsIFwiKFt8LilcXFxcZCtcIikucmVwbGFjZSgvXFxbL2csICdcXFxcWycpLnJlcGxhY2UoL1xcXS9nLCAnXFxcXF0nKSkudGVzdChuYW1lKTtcbn07XG5cbnZhciBpc05hbWVJbkZpZWxkQXJyYXkgPSBmdW5jdGlvbiBpc05hbWVJbkZpZWxkQXJyYXkobmFtZXMsIG5hbWUpIHtcbiAgcmV0dXJuIF90b0NvbnN1bWFibGVBcnJheShuYW1lcykuc29tZShmdW5jdGlvbiAoY3VycmVudCkge1xuICAgIHJldHVybiBpc01hdGNoRmllbGRBcnJheU5hbWUobmFtZSwgY3VycmVudCk7XG4gIH0pO1xufTtcblxudmFyIGlzU2VsZWN0SW5wdXQgPSBmdW5jdGlvbiBpc1NlbGVjdElucHV0KGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQudHlwZSA9PT0gXCJcIi5jb25jYXQoU0VMRUNULCBcIi1vbmVcIik7XG59O1xuXG5mdW5jdGlvbiBvbkRvbVJlbW92ZShmaWVsZHNSZWYsIHJlbW92ZUZpZWxkRXZlbnRMaXN0ZW5lckFuZFJlZikge1xuICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgX2kzID0gMCwgX09iamVjdCR2YWx1ZXMgPSBPYmplY3QudmFsdWVzKGZpZWxkc1JlZi5jdXJyZW50KTsgX2kzIDwgX09iamVjdCR2YWx1ZXMubGVuZ3RoOyBfaTMrKykge1xuICAgICAgdmFyIGZpZWxkID0gX09iamVjdCR2YWx1ZXNbX2kzXTtcblxuICAgICAgaWYgKGZpZWxkICYmIGZpZWxkLm9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGZpZWxkLm9wdGlvbnMpLFxuICAgICAgICAgICAgX3N0ZXA7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIG9wdGlvbiA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9uICYmIG9wdGlvbi5yZWYgJiYgaXNEZXRhY2hlZChvcHRpb24ucmVmKSkge1xuICAgICAgICAgICAgICByZW1vdmVGaWVsZEV2ZW50TGlzdGVuZXJBbmRSZWYoZmllbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGZpZWxkICYmIGlzRGV0YWNoZWQoZmllbGQucmVmKSkge1xuICAgICAgICByZW1vdmVGaWVsZEV2ZW50TGlzdGVuZXJBbmRSZWYoZmllbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIG9ic2VydmVyLm9ic2VydmUod2luZG93LmRvY3VtZW50LCB7XG4gICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgIHN1YnRyZWU6IHRydWVcbiAgfSk7XG4gIHJldHVybiBvYnNlcnZlcjtcbn1cblxudmFyIGlzV2ViID0gdHlwZW9mIHdpbmRvdyAhPT0gVU5ERUZJTkVEICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gVU5ERUZJTkVEO1xuXG5mdW5jdGlvbiBjbG9uZU9iamVjdChkYXRhKSB7XG4gIHZhciBjb3B5O1xuXG4gIGlmIChpc1ByaW1pdGl2ZShkYXRhKSB8fCBpc1dlYiAmJiBkYXRhIGluc3RhbmNlb2YgRmlsZSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgY29weSA9IG5ldyBEYXRlKGRhdGEuZ2V0VGltZSgpKTtcbiAgICByZXR1cm4gY29weTtcbiAgfVxuXG4gIGlmIChkYXRhIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgY29weSA9IG5ldyBTZXQoKTtcblxuICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoZGF0YSksXG4gICAgICAgIF9zdGVwMjtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICB2YXIgaXRlbSA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgY29weS5hZGQoaXRlbSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvcHk7XG4gIH1cblxuICBpZiAoZGF0YSBpbnN0YW5jZW9mIE1hcCkge1xuICAgIGNvcHkgPSBuZXcgTWFwKCk7XG5cbiAgICB2YXIgX2l0ZXJhdG9yMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGRhdGEua2V5cygpKSxcbiAgICAgICAgX3N0ZXAzO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yMy5zKCk7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBrZXkgPSBfc3RlcDMudmFsdWU7XG4gICAgICAgIGNvcHkuc2V0KGtleSwgY2xvbmVPYmplY3QoZGF0YS5nZXQoa2V5KSkpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yMy5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvcjMuZigpO1xuICAgIH1cblxuICAgIHJldHVybiBjb3B5O1xuICB9XG5cbiAgY29weSA9IEFycmF5LmlzQXJyYXkoZGF0YSkgPyBbXSA6IHt9O1xuXG4gIGZvciAodmFyIF9rZXkgaW4gZGF0YSkge1xuICAgIGNvcHlbX2tleV0gPSBjbG9uZU9iamVjdChkYXRhW19rZXldKTtcbiAgfVxuXG4gIHJldHVybiBjb3B5O1xufVxuXG52YXIgbW9kZUNoZWNrZXIgPSBmdW5jdGlvbiBtb2RlQ2hlY2tlcihtb2RlKSB7XG4gIHJldHVybiB7XG4gICAgaXNPblN1Ym1pdDogIW1vZGUgfHwgbW9kZSA9PT0gVkFMSURBVElPTl9NT0RFLm9uU3VibWl0LFxuICAgIGlzT25CbHVyOiBtb2RlID09PSBWQUxJREFUSU9OX01PREUub25CbHVyLFxuICAgIGlzT25DaGFuZ2U6IG1vZGUgPT09IFZBTElEQVRJT05fTU9ERS5vbkNoYW5nZSxcbiAgICBpc09uQWxsOiBtb2RlID09PSBWQUxJREFUSU9OX01PREUuYWxsLFxuICAgIGlzT25Ub3VjaDogbW9kZSA9PT0gVkFMSURBVElPTl9NT0RFLm9uVG91Y2hlZFxuICB9O1xufTtcblxudmFyIGlzUmFkaW9PckNoZWNrYm94RnVuY3Rpb24gPSBmdW5jdGlvbiBpc1JhZGlvT3JDaGVja2JveEZ1bmN0aW9uKHJlZikge1xuICByZXR1cm4gaXNSYWRpb0lucHV0KHJlZikgfHwgaXNDaGVja0JveElucHV0KHJlZik7XG59O1xuXG52YXIgaXNXaW5kb3dVbmRlZmluZWQgPSB0eXBlb2Ygd2luZG93ID09PSBVTkRFRklORUQ7XG52YXIgaXNQcm94eUVuYWJsZWQgPSBpc1dlYiA/ICdQcm94eScgaW4gd2luZG93IDogdHlwZW9mIFByb3h5ICE9PSBVTkRFRklORUQ7XG5cbmZ1bmN0aW9uIHVzZUZvcm0oKSB7XG4gIHZhciBfcmVmMTAgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgX3JlZjEwJG1vZGUgPSBfcmVmMTAubW9kZSxcbiAgICAgIG1vZGUgPSBfcmVmMTAkbW9kZSA9PT0gdm9pZCAwID8gVkFMSURBVElPTl9NT0RFLm9uU3VibWl0IDogX3JlZjEwJG1vZGUsXG4gICAgICBfcmVmMTAkcmVWYWxpZGF0ZU1vZGUgPSBfcmVmMTAucmVWYWxpZGF0ZU1vZGUsXG4gICAgICByZVZhbGlkYXRlTW9kZSA9IF9yZWYxMCRyZVZhbGlkYXRlTW9kZSA9PT0gdm9pZCAwID8gVkFMSURBVElPTl9NT0RFLm9uQ2hhbmdlIDogX3JlZjEwJHJlVmFsaWRhdGVNb2RlLFxuICAgICAgcmVzb2x2ZXIgPSBfcmVmMTAucmVzb2x2ZXIsXG4gICAgICBjb250ZXh0ID0gX3JlZjEwLmNvbnRleHQsXG4gICAgICBfcmVmMTAkZGVmYXVsdFZhbHVlcyA9IF9yZWYxMC5kZWZhdWx0VmFsdWVzLFxuICAgICAgZGVmYXVsdFZhbHVlcyA9IF9yZWYxMCRkZWZhdWx0VmFsdWVzID09PSB2b2lkIDAgPyB7fSA6IF9yZWYxMCRkZWZhdWx0VmFsdWVzLFxuICAgICAgX3JlZjEwJHNob3VsZEZvY3VzRXJyID0gX3JlZjEwLnNob3VsZEZvY3VzRXJyb3IsXG4gICAgICBzaG91bGRGb2N1c0Vycm9yID0gX3JlZjEwJHNob3VsZEZvY3VzRXJyID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZjEwJHNob3VsZEZvY3VzRXJyLFxuICAgICAgX3JlZjEwJHNob3VsZFVucmVnaXN0ID0gX3JlZjEwLnNob3VsZFVucmVnaXN0ZXIsXG4gICAgICBzaG91bGRVbnJlZ2lzdGVyID0gX3JlZjEwJHNob3VsZFVucmVnaXN0ID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZjEwJHNob3VsZFVucmVnaXN0LFxuICAgICAgY3JpdGVyaWFNb2RlID0gX3JlZjEwLmNyaXRlcmlhTW9kZTtcblxuICB2YXIgZmllbGRzUmVmID0gdXNlUmVmKHt9KTtcbiAgdmFyIGZpZWxkQXJyYXlEZWZhdWx0VmFsdWVzUmVmID0gdXNlUmVmKHt9KTtcbiAgdmFyIGZpZWxkQXJyYXlWYWx1ZXNSZWYgPSB1c2VSZWYoe30pO1xuICB2YXIgd2F0Y2hGaWVsZHNSZWYgPSB1c2VSZWYobmV3IFNldCgpKTtcbiAgdmFyIHVzZVdhdGNoRmllbGRzUmVmID0gdXNlUmVmKHt9KTtcbiAgdmFyIHVzZVdhdGNoUmVuZGVyRnVuY3Rpb25zUmVmID0gdXNlUmVmKHt9KTtcbiAgdmFyIGZpZWxkc1dpdGhWYWxpZGF0aW9uUmVmID0gdXNlUmVmKHt9KTtcbiAgdmFyIHZhbGlkRmllbGRzUmVmID0gdXNlUmVmKHt9KTtcbiAgdmFyIGRlZmF1bHRWYWx1ZXNSZWYgPSB1c2VSZWYoZGVmYXVsdFZhbHVlcyk7XG4gIHZhciBkZWZhdWx0VmFsdWVzQXRSZW5kZXJSZWYgPSB1c2VSZWYoe30pO1xuICB2YXIgaXNVbk1vdW50ID0gdXNlUmVmKGZhbHNlKTtcbiAgdmFyIGlzV2F0Y2hBbGxSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICB2YXIgaGFuZGxlQ2hhbmdlUmVmID0gdXNlUmVmKCk7XG4gIHZhciBzaGFsbG93RmllbGRzU3RhdGVSZWYgPSB1c2VSZWYoe30pO1xuICB2YXIgcmVzZXRGaWVsZEFycmF5RnVuY3Rpb25SZWYgPSB1c2VSZWYoe30pO1xuICB2YXIgY29udGV4dFJlZiA9IHVzZVJlZihjb250ZXh0KTtcbiAgdmFyIHJlc29sdmVyUmVmID0gdXNlUmVmKHJlc29sdmVyKTtcbiAgdmFyIGZpZWxkQXJyYXlOYW1lc1JlZiA9IHVzZVJlZihuZXcgU2V0KCkpO1xuICB2YXIgbW9kZVJlZiA9IHVzZVJlZihtb2RlQ2hlY2tlcihtb2RlKSk7XG4gIHZhciBfbW9kZVJlZiRjdXJyZW50ID0gbW9kZVJlZi5jdXJyZW50LFxuICAgICAgaXNPblN1Ym1pdCA9IF9tb2RlUmVmJGN1cnJlbnQuaXNPblN1Ym1pdCxcbiAgICAgIGlzT25Ub3VjaCA9IF9tb2RlUmVmJGN1cnJlbnQuaXNPblRvdWNoO1xuICB2YXIgaXNWYWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEgPSBjcml0ZXJpYU1vZGUgPT09IFZBTElEQVRJT05fTU9ERS5hbGw7XG5cbiAgdmFyIF91c2VTdGF0ZSA9IHVzZVN0YXRlKHtcbiAgICBpc0RpcnR5OiBmYWxzZSxcbiAgICBkaXJ0eUZpZWxkczoge30sXG4gICAgaXNTdWJtaXR0ZWQ6IGZhbHNlLFxuICAgIHN1Ym1pdENvdW50OiAwLFxuICAgIHRvdWNoZWQ6IHt9LFxuICAgIGlzU3VibWl0dGluZzogZmFsc2UsXG4gICAgaXNTdWJtaXRTdWNjZXNzZnVsOiBmYWxzZSxcbiAgICBpc1ZhbGlkOiAhaXNPblN1Ym1pdCxcbiAgICBlcnJvcnM6IHt9XG4gIH0pLFxuICAgICAgX3VzZVN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZSwgMiksXG4gICAgICBmb3JtU3RhdGUgPSBfdXNlU3RhdGUyWzBdLFxuICAgICAgc2V0Rm9ybVN0YXRlID0gX3VzZVN0YXRlMlsxXTtcblxuICB2YXIgcmVhZEZvcm1TdGF0ZVJlZiA9IHVzZVJlZih7XG4gICAgaXNEaXJ0eTogIWlzUHJveHlFbmFibGVkLFxuICAgIGRpcnR5RmllbGRzOiAhaXNQcm94eUVuYWJsZWQsXG4gICAgdG91Y2hlZDogIWlzUHJveHlFbmFibGVkIHx8IGlzT25Ub3VjaCxcbiAgICBpc1N1Ym1pdHRpbmc6ICFpc1Byb3h5RW5hYmxlZCxcbiAgICBpc1ZhbGlkOiAhaXNQcm94eUVuYWJsZWRcbiAgfSk7XG4gIHZhciBmb3JtU3RhdGVSZWYgPSB1c2VSZWYoZm9ybVN0YXRlKTtcbiAgdmFyIG9ic2VydmVyUmVmID0gdXNlUmVmKCk7XG4gIHZhciBfdXNlUmVmJGN1cnJlbnQgPSB1c2VSZWYobW9kZUNoZWNrZXIocmVWYWxpZGF0ZU1vZGUpKS5jdXJyZW50LFxuICAgICAgaXNSZVZhbGlkYXRlT25CbHVyID0gX3VzZVJlZiRjdXJyZW50LmlzT25CbHVyLFxuICAgICAgaXNSZVZhbGlkYXRlT25DaGFuZ2UgPSBfdXNlUmVmJGN1cnJlbnQuaXNPbkNoYW5nZTtcbiAgY29udGV4dFJlZi5jdXJyZW50ID0gY29udGV4dDtcbiAgcmVzb2x2ZXJSZWYuY3VycmVudCA9IHJlc29sdmVyO1xuICBmb3JtU3RhdGVSZWYuY3VycmVudCA9IGZvcm1TdGF0ZTtcbiAgc2hhbGxvd0ZpZWxkc1N0YXRlUmVmLmN1cnJlbnQgPSBzaG91bGRVbnJlZ2lzdGVyID8ge30gOiBpc0VtcHR5T2JqZWN0KHNoYWxsb3dGaWVsZHNTdGF0ZVJlZi5jdXJyZW50KSA/IGNsb25lT2JqZWN0KGRlZmF1bHRWYWx1ZXMpIDogc2hhbGxvd0ZpZWxkc1N0YXRlUmVmLmN1cnJlbnQ7XG4gIHZhciB1cGRhdGVGb3JtU3RhdGUgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgIGlmICghaXNVbk1vdW50LmN1cnJlbnQpIHtcbiAgICAgIGZvcm1TdGF0ZVJlZi5jdXJyZW50ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmb3JtU3RhdGVSZWYuY3VycmVudCksIHN0YXRlKTtcbiAgICAgIHNldEZvcm1TdGF0ZShmb3JtU3RhdGVSZWYuY3VycmVudCk7XG4gICAgfVxuICB9LCBbXSk7XG4gIHZhciBzaG91bGRSZW5kZXJCYXNlT25FcnJvciA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChuYW1lLCBlcnJvcikge1xuICAgIHZhciBzaG91bGRSZW5kZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgIHZhciBzdGF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG4gICAgdmFyIGlzVmFsaWQgPSBhcmd1bWVudHMubGVuZ3RoID4gNCA/IGFyZ3VtZW50c1s0XSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgc2hvdWxkUmVSZW5kZXIgPSBzaG91bGRSZW5kZXIgfHwgaXNFcnJvclN0YXRlQ2hhbmdlZCh7XG4gICAgICBlcnJvcnM6IGZvcm1TdGF0ZVJlZi5jdXJyZW50LmVycm9ycyxcbiAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWxpZEZpZWxkczogdmFsaWRGaWVsZHNSZWYuY3VycmVudCxcbiAgICAgIGZpZWxkc1dpdGhWYWxpZGF0aW9uOiBmaWVsZHNXaXRoVmFsaWRhdGlvblJlZi5jdXJyZW50XG4gICAgfSk7XG4gICAgdmFyIHByZXZpb3VzRXJyb3IgPSBnZXQoZm9ybVN0YXRlUmVmLmN1cnJlbnQuZXJyb3JzLCBuYW1lKTtcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgdW5zZXQodmFsaWRGaWVsZHNSZWYuY3VycmVudCwgbmFtZSk7XG4gICAgICBzaG91bGRSZVJlbmRlciA9IHNob3VsZFJlUmVuZGVyIHx8ICFwcmV2aW91c0Vycm9yIHx8ICFkZWVwRXF1YWwocHJldmlvdXNFcnJvciwgZXJyb3IsIHRydWUpO1xuICAgICAgc2V0KGZvcm1TdGF0ZVJlZi5jdXJyZW50LmVycm9ycywgbmFtZSwgZXJyb3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZ2V0KGZpZWxkc1dpdGhWYWxpZGF0aW9uUmVmLmN1cnJlbnQsIG5hbWUpIHx8IHJlc29sdmVyUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgc2V0KHZhbGlkRmllbGRzUmVmLmN1cnJlbnQsIG5hbWUsIHRydWUpO1xuICAgICAgICBzaG91bGRSZVJlbmRlciA9IHNob3VsZFJlUmVuZGVyIHx8IHByZXZpb3VzRXJyb3I7XG4gICAgICB9XG5cbiAgICAgIHVuc2V0KGZvcm1TdGF0ZVJlZi5jdXJyZW50LmVycm9ycywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFJlUmVuZGVyICYmICFpc051bGxPclVuZGVmaW5lZChzaG91bGRSZW5kZXIpIHx8ICFpc0VtcHR5T2JqZWN0KHN0YXRlKSkge1xuICAgICAgdXBkYXRlRm9ybVN0YXRlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpLCByZXNvbHZlclJlZi5jdXJyZW50ID8ge1xuICAgICAgICBpc1ZhbGlkOiAhIWlzVmFsaWRcbiAgICAgIH0gOiB7fSkpO1xuICAgIH1cbiAgfSwgW10pO1xuICB2YXIgc2V0RmllbGRWYWx1ZSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChuYW1lLCByYXdWYWx1ZSkge1xuICAgIHZhciBfZmllbGRzUmVmJGN1cnJlbnQkbmEgPSBmaWVsZHNSZWYuY3VycmVudFtuYW1lXSxcbiAgICAgICAgcmVmID0gX2ZpZWxkc1JlZiRjdXJyZW50JG5hLnJlZixcbiAgICAgICAgb3B0aW9ucyA9IF9maWVsZHNSZWYkY3VycmVudCRuYS5vcHRpb25zO1xuICAgIHZhciB2YWx1ZSA9IGlzV2ViICYmIGlzSFRNTEVsZW1lbnQocmVmKSAmJiBpc051bGxPclVuZGVmaW5lZChyYXdWYWx1ZSkgPyAnJyA6IHJhd1ZhbHVlO1xuXG4gICAgaWYgKGlzUmFkaW9JbnB1dChyZWYpKSB7XG4gICAgICAob3B0aW9ucyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbiAoX3JlZjExKSB7XG4gICAgICAgIHZhciByYWRpb1JlZiA9IF9yZWYxMS5yZWY7XG4gICAgICAgIHJldHVybiByYWRpb1JlZi5jaGVja2VkID0gcmFkaW9SZWYudmFsdWUgPT09IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpc0ZpbGVJbnB1dChyZWYpICYmICFpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgIHJlZi5maWxlcyA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAoaXNNdWx0aXBsZVNlbGVjdChyZWYpKSB7XG4gICAgICBfdG9Db25zdW1hYmxlQXJyYXkocmVmLm9wdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKHNlbGVjdFJlZikge1xuICAgICAgICByZXR1cm4gc2VsZWN0UmVmLnNlbGVjdGVkID0gdmFsdWUuaW5jbHVkZXMoc2VsZWN0UmVmLnZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoaXNDaGVja0JveElucHV0KHJlZikgJiYgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucy5sZW5ndGggPiAxID8gb3B0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmMTIpIHtcbiAgICAgICAgdmFyIGNoZWNrYm94UmVmID0gX3JlZjEyLnJlZjtcbiAgICAgICAgcmV0dXJuIGNoZWNrYm94UmVmLmNoZWNrZWQgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/ICEhdmFsdWUuZmluZChmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgIHJldHVybiBkYXRhID09PSBjaGVja2JveFJlZi52YWx1ZTtcbiAgICAgICAgfSkgOiB2YWx1ZSA9PT0gY2hlY2tib3hSZWYudmFsdWU7XG4gICAgICB9KSA6IG9wdGlvbnNbMF0ucmVmLmNoZWNrZWQgPSAhIXZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWYudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gIH0sIFtdKTtcbiAgdmFyIGlzRm9ybURpcnR5ID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKG5hbWUsIGRhdGEpIHtcbiAgICBpZiAocmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LmlzRGlydHkpIHtcbiAgICAgIHZhciBmb3JtVmFsdWVzID0gZ2V0VmFsdWVzKCk7XG4gICAgICBuYW1lICYmIGRhdGEgJiYgc2V0KGZvcm1WYWx1ZXMsIG5hbWUsIGRhdGEpO1xuICAgICAgcmV0dXJuICFkZWVwRXF1YWwoZm9ybVZhbHVlcywgaXNFbXB0eU9iamVjdChkZWZhdWx0VmFsdWVzUmVmLmN1cnJlbnQpID8gZGVmYXVsdFZhbHVlc0F0UmVuZGVyUmVmLmN1cnJlbnQgOiBkZWZhdWx0VmFsdWVzUmVmLmN1cnJlbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgW10pO1xuICB2YXIgdXBkYXRlQW5kR2V0RGlydHlTdGF0ZSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHNob3VsZFJlbmRlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcblxuICAgIGlmIChyZWFkRm9ybVN0YXRlUmVmLmN1cnJlbnQuaXNEaXJ0eSB8fCByZWFkRm9ybVN0YXRlUmVmLmN1cnJlbnQuZGlydHlGaWVsZHMpIHtcbiAgICAgIHZhciBpc0ZpZWxkRGlydHkgPSAhZGVlcEVxdWFsKGdldChkZWZhdWx0VmFsdWVzQXRSZW5kZXJSZWYuY3VycmVudCwgbmFtZSksIGdldEZpZWxkVmFsdWUoZmllbGRzUmVmLCBuYW1lLCBzaGFsbG93RmllbGRzU3RhdGVSZWYpKTtcbiAgICAgIHZhciBpc0RpcnR5RmllbGRFeGlzdCA9IGdldChmb3JtU3RhdGVSZWYuY3VycmVudC5kaXJ0eUZpZWxkcywgbmFtZSk7XG4gICAgICB2YXIgcHJldmlvdXNJc0RpcnR5ID0gZm9ybVN0YXRlUmVmLmN1cnJlbnQuaXNEaXJ0eTtcbiAgICAgIGlzRmllbGREaXJ0eSA/IHNldChmb3JtU3RhdGVSZWYuY3VycmVudC5kaXJ0eUZpZWxkcywgbmFtZSwgdHJ1ZSkgOiB1bnNldChmb3JtU3RhdGVSZWYuY3VycmVudC5kaXJ0eUZpZWxkcywgbmFtZSk7XG4gICAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAgIGlzRGlydHk6IGlzRm9ybURpcnR5KCksXG4gICAgICAgIGRpcnR5RmllbGRzOiBmb3JtU3RhdGVSZWYuY3VycmVudC5kaXJ0eUZpZWxkc1xuICAgICAgfTtcbiAgICAgIHZhciBpc0NoYW5nZWQgPSByZWFkRm9ybVN0YXRlUmVmLmN1cnJlbnQuaXNEaXJ0eSAmJiBwcmV2aW91c0lzRGlydHkgIT09IHN0YXRlLmlzRGlydHkgfHwgcmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LmRpcnR5RmllbGRzICYmIGlzRGlydHlGaWVsZEV4aXN0ICE9PSBnZXQoZm9ybVN0YXRlUmVmLmN1cnJlbnQuZGlydHlGaWVsZHMsIG5hbWUpO1xuICAgICAgaXNDaGFuZ2VkICYmIHNob3VsZFJlbmRlciAmJiB1cGRhdGVGb3JtU3RhdGUoc3RhdGUpO1xuICAgICAgcmV0dXJuIGlzQ2hhbmdlZCA/IHN0YXRlIDoge307XG4gICAgfVxuXG4gICAgcmV0dXJuIHt9O1xuICB9LCBbXSk7XG4gIHZhciBleGVjdXRlVmFsaWRhdGlvbiA9IHVzZUNhbGxiYWNrKCAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcmVmMTMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMihuYW1lLCBza2lwUmVSZW5kZXIpIHtcbiAgICAgIHZhciBlcnJvcjtcbiAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBpZiAoIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChmaWVsZHNSZWYuY3VycmVudFtuYW1lXSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvbnNvbGUud2Fybign8J+TiyBGaWVsZCBpcyBtaXNzaW5nIHdpdGggYG5hbWVgIGF0dHJpYnV0ZTogJywgbmFtZSk7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIGZhbHNlKTtcblxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDY7XG4gICAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZUZpZWxkKGZpZWxkc1JlZiwgaXNWYWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEsIGZpZWxkc1JlZi5jdXJyZW50W25hbWVdLCBzaGFsbG93RmllbGRzU3RhdGVSZWYpO1xuXG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi50MCA9IG5hbWU7XG4gICAgICAgICAgICAgIGVycm9yID0gX2NvbnRleHQyLnNlbnRbX2NvbnRleHQyLnQwXTtcbiAgICAgICAgICAgICAgc2hvdWxkUmVuZGVyQmFzZU9uRXJyb3IobmFtZSwgZXJyb3IsIHNraXBSZVJlbmRlcik7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIGlzVW5kZWZpbmVkKGVycm9yKSk7XG5cbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZTIpO1xuICAgIH0pKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoX3g1LCBfeDYpIHtcbiAgICAgIHJldHVybiBfcmVmMTMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9KCksIFtzaG91bGRSZW5kZXJCYXNlT25FcnJvciwgaXNWYWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWFdKTtcbiAgdmFyIGV4ZWN1dGVTY2hlbWFPclJlc29sdmVyVmFsaWRhdGlvbiA9IHVzZUNhbGxiYWNrKCAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcmVmMTQgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMyhuYW1lcykge1xuICAgICAgdmFyIF95aWVsZCRyZXNvbHZlclJlZiRjdSwgZXJyb3JzLCBwcmV2aW91c0Zvcm1Jc1ZhbGlkLCBpc0lucHV0c1ZhbGlkLCBfZXJyb3I7XG5cbiAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0Mykge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDI7XG4gICAgICAgICAgICAgIHJldHVybiByZXNvbHZlclJlZi5jdXJyZW50KGdldFZhbHVlcygpLCBjb250ZXh0UmVmLmN1cnJlbnQsIGlzVmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhKTtcblxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBfeWllbGQkcmVzb2x2ZXJSZWYkY3UgPSBfY29udGV4dDMuc2VudDtcbiAgICAgICAgICAgICAgZXJyb3JzID0gX3lpZWxkJHJlc29sdmVyUmVmJGN1LmVycm9ycztcbiAgICAgICAgICAgICAgcHJldmlvdXNGb3JtSXNWYWxpZCA9IGZvcm1TdGF0ZVJlZi5jdXJyZW50LmlzVmFsaWQ7XG5cbiAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG5hbWVzKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpc0lucHV0c1ZhbGlkID0gbmFtZXMubWFwKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yID0gZ2V0KGVycm9ycywgbmFtZSk7XG4gICAgICAgICAgICAgICAgZXJyb3IgPyBzZXQoZm9ybVN0YXRlUmVmLmN1cnJlbnQuZXJyb3JzLCBuYW1lLCBlcnJvcikgOiB1bnNldChmb3JtU3RhdGVSZWYuY3VycmVudC5lcnJvcnMsIG5hbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiAhZXJyb3I7XG4gICAgICAgICAgICAgIH0pLmV2ZXJ5KEJvb2xlYW4pO1xuICAgICAgICAgICAgICB1cGRhdGVGb3JtU3RhdGUoe1xuICAgICAgICAgICAgICAgIGlzVmFsaWQ6IGlzRW1wdHlPYmplY3QoZXJyb3JzKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgaXNJbnB1dHNWYWxpZCk7XG5cbiAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgIF9lcnJvciA9IGdldChlcnJvcnMsIG5hbWVzKTtcbiAgICAgICAgICAgICAgc2hvdWxkUmVuZGVyQmFzZU9uRXJyb3IobmFtZXMsIF9lcnJvciwgcHJldmlvdXNGb3JtSXNWYWxpZCAhPT0gaXNFbXB0eU9iamVjdChlcnJvcnMpLCB7fSwgaXNFbXB0eU9iamVjdChlcnJvcnMpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgIV9lcnJvcik7XG5cbiAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZTMpO1xuICAgIH0pKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoX3g3KSB7XG4gICAgICByZXR1cm4gX3JlZjE0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfSgpLCBbc2hvdWxkUmVuZGVyQmFzZU9uRXJyb3IsIGlzVmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhXSk7XG4gIHZhciB0cmlnZ2VyID0gdXNlQ2FsbGJhY2soIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9yZWYxNSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KG5hbWUpIHtcbiAgICAgIHZhciBmaWVsZHMsIHJlc3VsdDtcbiAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTUkKF9jb250ZXh0NSkge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ1LnByZXYgPSBfY29udGV4dDUubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBmaWVsZHMgPSBuYW1lIHx8IE9iamVjdC5rZXlzKGZpZWxkc1JlZi5jdXJyZW50KTtcblxuICAgICAgICAgICAgICBpZiAoIXJlc29sdmVyUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiLCBleGVjdXRlU2NoZW1hT3JSZXNvbHZlclZhbGlkYXRpb24oZmllbGRzKSk7XG5cbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGZpZWxkcykpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDEwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgIW5hbWUgJiYgKGZvcm1TdGF0ZVJlZi5jdXJyZW50LmVycm9ycyA9IHt9KTtcbiAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA3O1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoZmllbGRzLm1hcCggLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3JlZjE2ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlNCQoX2NvbnRleHQ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4ZWN1dGVWYWxpZGF0aW9uKGRhdGEsIG51bGwpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0NC5zZW50KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0sIF9jYWxsZWU0KTtcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKF94OSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWYxNi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH0oKSkpO1xuXG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIHJlc3VsdCA9IF9jb250ZXh0NS5zZW50O1xuICAgICAgICAgICAgICB1cGRhdGVGb3JtU3RhdGUoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzdWx0LmV2ZXJ5KEJvb2xlYW4pKTtcblxuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgcmV0dXJuIGV4ZWN1dGVWYWxpZGF0aW9uKGZpZWxkcyk7XG5cbiAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0NS5zZW50KTtcblxuICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlNSk7XG4gICAgfSkpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChfeDgpIHtcbiAgICAgIHJldHVybiBfcmVmMTUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9KCksIFtleGVjdXRlU2NoZW1hT3JSZXNvbHZlclZhbGlkYXRpb24sIGV4ZWN1dGVWYWxpZGF0aW9uXSk7XG4gIHZhciBzZXRJbnRlcm5hbFZhbHVlcyA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgX3JlZjE3KSB7XG4gICAgdmFyIHNob3VsZERpcnR5ID0gX3JlZjE3LnNob3VsZERpcnR5LFxuICAgICAgICBzaG91bGRWYWxpZGF0ZSA9IF9yZWYxNy5zaG91bGRWYWxpZGF0ZTtcbiAgICB2YXIgZGF0YSA9IHt9O1xuICAgIHNldChkYXRhLCBuYW1lLCB2YWx1ZSk7XG5cbiAgICB2YXIgX2l0ZXJhdG9yNCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGdldFBhdGgobmFtZSwgdmFsdWUpKSxcbiAgICAgICAgX3N0ZXA0O1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yNC5zKCk7ICEoX3N0ZXA0ID0gX2l0ZXJhdG9yNC5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBmaWVsZE5hbWUgPSBfc3RlcDQudmFsdWU7XG5cbiAgICAgICAgaWYgKGZpZWxkc1JlZi5jdXJyZW50W2ZpZWxkTmFtZV0pIHtcbiAgICAgICAgICBzZXRGaWVsZFZhbHVlKGZpZWxkTmFtZSwgZ2V0KGRhdGEsIGZpZWxkTmFtZSkpO1xuICAgICAgICAgIHNob3VsZERpcnR5ICYmIHVwZGF0ZUFuZEdldERpcnR5U3RhdGUoZmllbGROYW1lKTtcbiAgICAgICAgICBzaG91bGRWYWxpZGF0ZSAmJiB0cmlnZ2VyKGZpZWxkTmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvcjQuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3I0LmYoKTtcbiAgICB9XG4gIH0sIFt0cmlnZ2VyLCBzZXRGaWVsZFZhbHVlLCB1cGRhdGVBbmRHZXREaXJ0eVN0YXRlXSk7XG4gIHZhciBzZXRJbnRlcm5hbFZhbHVlID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBjb25maWcpIHtcbiAgICAhaXNQcmltaXRpdmUodmFsdWUpICYmIHNldChzaGFsbG93RmllbGRzU3RhdGVSZWYuY3VycmVudCwgbmFtZSwgdmFsdWUpO1xuXG4gICAgaWYgKGZpZWxkc1JlZi5jdXJyZW50W25hbWVdKSB7XG4gICAgICBzZXRGaWVsZFZhbHVlKG5hbWUsIHZhbHVlKTtcbiAgICAgIGNvbmZpZy5zaG91bGREaXJ0eSAmJiB1cGRhdGVBbmRHZXREaXJ0eVN0YXRlKG5hbWUpO1xuICAgICAgY29uZmlnLnNob3VsZFZhbGlkYXRlICYmIHRyaWdnZXIobmFtZSk7XG4gICAgfSBlbHNlIGlmICghaXNQcmltaXRpdmUodmFsdWUpKSB7XG4gICAgICBzZXRJbnRlcm5hbFZhbHVlcyhuYW1lLCB2YWx1ZSwgY29uZmlnKTtcblxuICAgICAgaWYgKGZpZWxkQXJyYXlOYW1lc1JlZi5jdXJyZW50LmhhcyhuYW1lKSkge1xuICAgICAgICBmaWVsZEFycmF5RGVmYXVsdFZhbHVlc1JlZi5jdXJyZW50W25hbWVdID0gdmFsdWU7XG4gICAgICAgIHJlc2V0RmllbGRBcnJheUZ1bmN0aW9uUmVmLmN1cnJlbnRbbmFtZV0oX2RlZmluZVByb3BlcnR5KHt9LCBuYW1lLCB2YWx1ZSkpO1xuXG4gICAgICAgIGlmICgocmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LmlzRGlydHkgfHwgcmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LmRpcnR5RmllbGRzKSAmJiBjb25maWcuc2hvdWxkRGlydHkpIHtcbiAgICAgICAgICBzZXQoZm9ybVN0YXRlUmVmLmN1cnJlbnQuZGlydHlGaWVsZHMsIG5hbWUsIHNldEZpZWxkQXJyYXlEaXJ0eUZpZWxkcyh2YWx1ZSwgZ2V0KGRlZmF1bHRWYWx1ZXNSZWYuY3VycmVudCwgbmFtZSwgW10pLCBnZXQoZm9ybVN0YXRlUmVmLmN1cnJlbnQuZGlydHlGaWVsZHMsIG5hbWUsIFtdKSkpO1xuICAgICAgICAgIHVwZGF0ZUZvcm1TdGF0ZSh7XG4gICAgICAgICAgICBpc0RpcnR5OiAhZGVlcEVxdWFsKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZ2V0VmFsdWVzKCkpLCBfZGVmaW5lUHJvcGVydHkoe30sIG5hbWUsIHZhbHVlKSksIGRlZmF1bHRWYWx1ZXNSZWYuY3VycmVudClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgICFzaG91bGRVbnJlZ2lzdGVyICYmIHNldChzaGFsbG93RmllbGRzU3RhdGVSZWYuY3VycmVudCwgbmFtZSwgdmFsdWUpO1xuICB9LCBbdXBkYXRlQW5kR2V0RGlydHlTdGF0ZSwgc2V0RmllbGRWYWx1ZSwgc2V0SW50ZXJuYWxWYWx1ZXNdKTtcblxuICB2YXIgaXNGaWVsZFdhdGNoZWQgPSBmdW5jdGlvbiBpc0ZpZWxkV2F0Y2hlZChuYW1lKSB7XG4gICAgcmV0dXJuIGlzV2F0Y2hBbGxSZWYuY3VycmVudCB8fCB3YXRjaEZpZWxkc1JlZi5jdXJyZW50LmhhcyhuYW1lKSB8fCB3YXRjaEZpZWxkc1JlZi5jdXJyZW50LmhhcygobmFtZS5tYXRjaCgvXFx3Ky8pIHx8IFtdKVswXSk7XG4gIH07XG5cbiAgdmFyIHJlbmRlcldhdGNoZWRJbnB1dHMgPSBmdW5jdGlvbiByZW5kZXJXYXRjaGVkSW5wdXRzKG5hbWUpIHtcbiAgICB2YXIgZm91bmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG5cbiAgICBpZiAoIWlzRW1wdHlPYmplY3QodXNlV2F0Y2hGaWVsZHNSZWYuY3VycmVudCkpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiB1c2VXYXRjaEZpZWxkc1JlZi5jdXJyZW50KSB7XG4gICAgICAgIGlmICghbmFtZSB8fCAhdXNlV2F0Y2hGaWVsZHNSZWYuY3VycmVudFtrZXldLnNpemUgfHwgdXNlV2F0Y2hGaWVsZHNSZWYuY3VycmVudFtrZXldLmhhcyhuYW1lKSB8fCB1c2VXYXRjaEZpZWxkc1JlZi5jdXJyZW50W2tleV0uaGFzKGdldEZpZWxkQXJyYXlQYXJlbnROYW1lKG5hbWUpKSkge1xuICAgICAgICAgIHVzZVdhdGNoUmVuZGVyRnVuY3Rpb25zUmVmLmN1cnJlbnRba2V5XSgpO1xuICAgICAgICAgIGZvdW5kID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZm91bmQ7XG4gIH07XG5cbiAgZnVuY3Rpb24gc2V0VmFsdWUobmFtZSwgdmFsdWUsIGNvbmZpZykge1xuICAgIHNldEludGVybmFsVmFsdWUobmFtZSwgdmFsdWUsIGNvbmZpZyB8fCB7fSk7XG4gICAgaXNGaWVsZFdhdGNoZWQobmFtZSkgJiYgdXBkYXRlRm9ybVN0YXRlKCk7XG4gICAgcmVuZGVyV2F0Y2hlZElucHV0cyhuYW1lKTtcbiAgfVxuXG4gIGhhbmRsZUNoYW5nZVJlZi5jdXJyZW50ID0gaGFuZGxlQ2hhbmdlUmVmLmN1cnJlbnQgPyBoYW5kbGVDaGFuZ2VSZWYuY3VycmVudCA6IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9yZWYxOSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU2KF9yZWYxOCkge1xuICAgICAgdmFyIHR5cGUsIHRhcmdldCwgbmFtZSwgZmllbGQsIGVycm9yLCBpc1ZhbGlkLCBpc0JsdXJFdmVudCwgc2hvdWxkU2tpcFZhbGlkYXRpb24sIHN0YXRlLCBzaG91bGRSZW5kZXIsIF95aWVsZCRyZXNvbHZlclJlZiRjdTIsIGVycm9ycywgcHJldmlvdXNGb3JtSXNWYWxpZCwgcGFyZW50Tm9kZU5hbWUsIGN1cnJlbnRFcnJvcjtcblxuICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlNiQoX2NvbnRleHQ2KSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dDYucHJldiA9IF9jb250ZXh0Ni5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHR5cGUgPSBfcmVmMTgudHlwZSwgdGFyZ2V0ID0gX3JlZjE4LnRhcmdldDtcbiAgICAgICAgICAgICAgbmFtZSA9IHRhcmdldC5uYW1lO1xuICAgICAgICAgICAgICBmaWVsZCA9IGZpZWxkc1JlZi5jdXJyZW50W25hbWVdO1xuXG4gICAgICAgICAgICAgIGlmICghZmllbGQpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDMxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaXNCbHVyRXZlbnQgPSB0eXBlID09PSBFVkVOVFMuQkxVUjtcbiAgICAgICAgICAgICAgc2hvdWxkU2tpcFZhbGlkYXRpb24gPSBza2lwVmFsaWRhdGlvbihPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgICBpc0JsdXJFdmVudDogaXNCbHVyRXZlbnQsXG4gICAgICAgICAgICAgICAgaXNSZVZhbGlkYXRlT25DaGFuZ2U6IGlzUmVWYWxpZGF0ZU9uQ2hhbmdlLFxuICAgICAgICAgICAgICAgIGlzUmVWYWxpZGF0ZU9uQmx1cjogaXNSZVZhbGlkYXRlT25CbHVyLFxuICAgICAgICAgICAgICAgIGlzVG91Y2hlZDogISFnZXQoZm9ybVN0YXRlUmVmLmN1cnJlbnQudG91Y2hlZCwgbmFtZSksXG4gICAgICAgICAgICAgICAgaXNTdWJtaXR0ZWQ6IGZvcm1TdGF0ZVJlZi5jdXJyZW50LmlzU3VibWl0dGVkXG4gICAgICAgICAgICAgIH0sIG1vZGVSZWYuY3VycmVudCkpO1xuICAgICAgICAgICAgICBzdGF0ZSA9IHVwZGF0ZUFuZEdldERpcnR5U3RhdGUobmFtZSwgZmFsc2UpO1xuICAgICAgICAgICAgICBzaG91bGRSZW5kZXIgPSAhaXNFbXB0eU9iamVjdChzdGF0ZSkgfHwgaXNGaWVsZFdhdGNoZWQobmFtZSk7XG5cbiAgICAgICAgICAgICAgaWYgKGlzQmx1ckV2ZW50ICYmICFnZXQoZm9ybVN0YXRlUmVmLmN1cnJlbnQudG91Y2hlZCwgbmFtZSkgJiYgcmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LnRvdWNoZWQpIHtcbiAgICAgICAgICAgICAgICBzZXQoZm9ybVN0YXRlUmVmLmN1cnJlbnQudG91Y2hlZCwgbmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKSwge1xuICAgICAgICAgICAgICAgICAgdG91Y2hlZDogZm9ybVN0YXRlUmVmLmN1cnJlbnQudG91Y2hlZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFzaG91bGRVbnJlZ2lzdGVyICYmIGlzQ2hlY2tCb3hJbnB1dCh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgc2V0KHNoYWxsb3dGaWVsZHNTdGF0ZVJlZi5jdXJyZW50LCBuYW1lLCBnZXRGaWVsZFZhbHVlKGZpZWxkc1JlZiwgbmFtZSkpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFzaG91bGRTa2lwVmFsaWRhdGlvbikge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gMTM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZW5kZXJXYXRjaGVkSW5wdXRzKG5hbWUpO1xuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCAoIWlzRW1wdHlPYmplY3Qoc3RhdGUpIHx8IHNob3VsZFJlbmRlciAmJiBpc0VtcHR5T2JqZWN0KHN0YXRlKSkgJiYgdXBkYXRlRm9ybVN0YXRlKHN0YXRlKSk7XG5cbiAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgIGlmICghcmVzb2x2ZXJSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gMjU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDE2O1xuICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZXJSZWYuY3VycmVudChnZXRWYWx1ZXMoKSwgY29udGV4dFJlZi5jdXJyZW50LCBpc1ZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSk7XG5cbiAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgIF95aWVsZCRyZXNvbHZlclJlZiRjdTIgPSBfY29udGV4dDYuc2VudDtcbiAgICAgICAgICAgICAgZXJyb3JzID0gX3lpZWxkJHJlc29sdmVyUmVmJGN1Mi5lcnJvcnM7XG4gICAgICAgICAgICAgIHByZXZpb3VzRm9ybUlzVmFsaWQgPSBmb3JtU3RhdGVSZWYuY3VycmVudC5pc1ZhbGlkO1xuICAgICAgICAgICAgICBlcnJvciA9IGdldChlcnJvcnMsIG5hbWUpO1xuXG4gICAgICAgICAgICAgIGlmIChpc0NoZWNrQm94SW5wdXQodGFyZ2V0KSAmJiAhZXJyb3IgJiYgcmVzb2x2ZXJSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIHBhcmVudE5vZGVOYW1lID0gZ2V0RmllbGRBcnJheVBhcmVudE5hbWUobmFtZSk7XG4gICAgICAgICAgICAgICAgY3VycmVudEVycm9yID0gZ2V0KGVycm9ycywgcGFyZW50Tm9kZU5hbWUsIHt9KTtcbiAgICAgICAgICAgICAgICBjdXJyZW50RXJyb3IudHlwZSAmJiBjdXJyZW50RXJyb3IubWVzc2FnZSAmJiAoZXJyb3IgPSBjdXJyZW50RXJyb3IpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudE5vZGVOYW1lICYmIChjdXJyZW50RXJyb3IgfHwgZ2V0KGZvcm1TdGF0ZVJlZi5jdXJyZW50LmVycm9ycywgcGFyZW50Tm9kZU5hbWUpKSkge1xuICAgICAgICAgICAgICAgICAgbmFtZSA9IHBhcmVudE5vZGVOYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlzVmFsaWQgPSBpc0VtcHR5T2JqZWN0KGVycm9ycyk7XG4gICAgICAgICAgICAgIHByZXZpb3VzRm9ybUlzVmFsaWQgIT09IGlzVmFsaWQgJiYgKHNob3VsZFJlbmRlciA9IHRydWUpO1xuICAgICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDI5O1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSAyNztcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlRmllbGQoZmllbGRzUmVmLCBpc1ZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSwgZmllbGQsIHNoYWxsb3dGaWVsZHNTdGF0ZVJlZik7XG5cbiAgICAgICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgICAgIF9jb250ZXh0Ni50MCA9IG5hbWU7XG4gICAgICAgICAgICAgIGVycm9yID0gX2NvbnRleHQ2LnNlbnRbX2NvbnRleHQ2LnQwXTtcblxuICAgICAgICAgICAgY2FzZSAyOTpcbiAgICAgICAgICAgICAgcmVuZGVyV2F0Y2hlZElucHV0cyhuYW1lKTtcbiAgICAgICAgICAgICAgc2hvdWxkUmVuZGVyQmFzZU9uRXJyb3IobmFtZSwgZXJyb3IsIHNob3VsZFJlbmRlciwgc3RhdGUsIGlzVmFsaWQpO1xuXG4gICAgICAgICAgICBjYXNlIDMxOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWU2KTtcbiAgICB9KSk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKF94MTApIHtcbiAgICAgIHJldHVybiBfcmVmMTkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9KCk7XG5cbiAgZnVuY3Rpb24gc2V0RmllbGRBcnJheURlZmF1bHRWYWx1ZXMoZGF0YSkge1xuICAgIGlmICghc2hvdWxkVW5yZWdpc3Rlcikge1xuICAgICAgdmFyIGNvcHkgPSBjbG9uZU9iamVjdChkYXRhKTtcblxuICAgICAgdmFyIF9pdGVyYXRvcjUgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihmaWVsZEFycmF5TmFtZXNSZWYuY3VycmVudCksXG4gICAgICAgICAgX3N0ZXA1O1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjUucygpOyAhKF9zdGVwNSA9IF9pdGVyYXRvcjUubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IF9zdGVwNS52YWx1ZTtcblxuICAgICAgICAgIGlmIChpc0tleSh2YWx1ZSkgJiYgIWNvcHlbdmFsdWVdKSB7XG4gICAgICAgICAgICBjb3B5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb3B5KSwgX2RlZmluZVByb3BlcnR5KHt9LCB2YWx1ZSwgW10pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3I1LmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjUuZigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29weTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFZhbHVlcyhwYXlsb2FkKSB7XG4gICAgaWYgKGlzU3RyaW5nKHBheWxvYWQpKSB7XG4gICAgICByZXR1cm4gZ2V0RmllbGRWYWx1ZShmaWVsZHNSZWYsIHBheWxvYWQsIHNoYWxsb3dGaWVsZHNTdGF0ZVJlZik7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGF5bG9hZCkpIHtcbiAgICAgIHZhciBkYXRhID0ge307XG5cbiAgICAgIHZhciBfaXRlcmF0b3I2ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIocGF5bG9hZCksXG4gICAgICAgICAgX3N0ZXA2O1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjYucygpOyAhKF9zdGVwNiA9IF9pdGVyYXRvcjYubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBfbmFtZSA9IF9zdGVwNi52YWx1ZTtcbiAgICAgICAgICBzZXQoZGF0YSwgX25hbWUsIGdldEZpZWxkVmFsdWUoZmllbGRzUmVmLCBfbmFtZSwgc2hhbGxvd0ZpZWxkc1N0YXRlUmVmKSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3I2LmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjYuZigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2V0RmllbGRBcnJheURlZmF1bHRWYWx1ZXMoZ2V0RmllbGRzVmFsdWVzKGZpZWxkc1JlZiwgY2xvbmVPYmplY3Qoc2hhbGxvd0ZpZWxkc1N0YXRlUmVmLmN1cnJlbnQpLCBzaG91bGRVbnJlZ2lzdGVyKSk7XG4gIH1cblxuICB2YXIgdmFsaWRhdGVSZXNvbHZlciA9IHVzZUNhbGxiYWNrKCAvKiNfX1BVUkVfXyovX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTcoKSB7XG4gICAgdmFyIHZhbHVlcyxcbiAgICAgICAgX3lpZWxkJHJlc29sdmVyUmVmJGN1MyxcbiAgICAgICAgZXJyb3JzLFxuICAgICAgICBpc1ZhbGlkLFxuICAgICAgICBfYXJnczcgPSBhcmd1bWVudHM7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU3JChfY29udGV4dDcpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ3LnByZXYgPSBfY29udGV4dDcubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHZhbHVlcyA9IF9hcmdzNy5sZW5ndGggPiAwICYmIF9hcmdzN1swXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3M3WzBdIDoge307XG4gICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZXJSZWYuY3VycmVudChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGdldFZhbHVlcygpKSwgdmFsdWVzKSwgY29udGV4dFJlZi5jdXJyZW50LCBpc1ZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBfeWllbGQkcmVzb2x2ZXJSZWYkY3UzID0gX2NvbnRleHQ3LnNlbnQ7XG4gICAgICAgICAgICBlcnJvcnMgPSBfeWllbGQkcmVzb2x2ZXJSZWYkY3UzLmVycm9ycztcbiAgICAgICAgICAgIGlzVmFsaWQgPSBpc0VtcHR5T2JqZWN0KGVycm9ycyk7XG4gICAgICAgICAgICBmb3JtU3RhdGVSZWYuY3VycmVudC5pc1ZhbGlkICE9PSBpc1ZhbGlkICYmIHVwZGF0ZUZvcm1TdGF0ZSh7XG4gICAgICAgICAgICAgIGlzVmFsaWQ6IGlzVmFsaWRcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTcpO1xuICB9KSksIFtpc1ZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYV0pO1xuICB2YXIgcmVtb3ZlRmllbGRFdmVudExpc3RlbmVyID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKGZpZWxkLCBmb3JjZURlbGV0ZSkge1xuICAgIHJldHVybiBmaW5kUmVtb3ZlZEZpZWxkQW5kUmVtb3ZlTGlzdGVuZXIoZmllbGRzUmVmLCBoYW5kbGVDaGFuZ2VSZWYuY3VycmVudCwgZmllbGQsIHNoYWxsb3dGaWVsZHNTdGF0ZVJlZiwgc2hvdWxkVW5yZWdpc3RlciwgZm9yY2VEZWxldGUpO1xuICB9LCBbc2hvdWxkVW5yZWdpc3Rlcl0pO1xuICB2YXIgdXBkYXRlV2F0Y2hlZFZhbHVlID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAoaXNXYXRjaEFsbFJlZi5jdXJyZW50KSB7XG4gICAgICB1cGRhdGVGb3JtU3RhdGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9pdGVyYXRvcjcgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih3YXRjaEZpZWxkc1JlZi5jdXJyZW50KSxcbiAgICAgICAgICBfc3RlcDc7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yNy5zKCk7ICEoX3N0ZXA3ID0gX2l0ZXJhdG9yNy5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIHdhdGNoRmllbGQgPSBfc3RlcDcudmFsdWU7XG5cbiAgICAgICAgICBpZiAod2F0Y2hGaWVsZC5zdGFydHNXaXRoKG5hbWUpKSB7XG4gICAgICAgICAgICB1cGRhdGVGb3JtU3RhdGUoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjcuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yNy5mKCk7XG4gICAgICB9XG5cbiAgICAgIHJlbmRlcldhdGNoZWRJbnB1dHMobmFtZSk7XG4gICAgfVxuICB9LCBbXSk7XG4gIHZhciByZW1vdmVGaWVsZEV2ZW50TGlzdGVuZXJBbmRSZWYgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoZmllbGQsIGZvcmNlRGVsZXRlKSB7XG4gICAgaWYgKGZpZWxkKSB7XG4gICAgICByZW1vdmVGaWVsZEV2ZW50TGlzdGVuZXIoZmllbGQsIGZvcmNlRGVsZXRlKTtcblxuICAgICAgaWYgKHNob3VsZFVucmVnaXN0ZXIgJiYgIWNvbXBhY3QoZmllbGQub3B0aW9ucyB8fCBbXSkubGVuZ3RoKSB7XG4gICAgICAgIHVuc2V0KGRlZmF1bHRWYWx1ZXNBdFJlbmRlclJlZi5jdXJyZW50LCBmaWVsZC5yZWYubmFtZSk7XG4gICAgICAgIHVuc2V0KHZhbGlkRmllbGRzUmVmLmN1cnJlbnQsIGZpZWxkLnJlZi5uYW1lKTtcbiAgICAgICAgdW5zZXQoZmllbGRzV2l0aFZhbGlkYXRpb25SZWYuY3VycmVudCwgZmllbGQucmVmLm5hbWUpO1xuICAgICAgICB1bnNldChmb3JtU3RhdGVSZWYuY3VycmVudC5lcnJvcnMsIGZpZWxkLnJlZi5uYW1lKTtcbiAgICAgICAgc2V0KGZvcm1TdGF0ZVJlZi5jdXJyZW50LmRpcnR5RmllbGRzLCBmaWVsZC5yZWYubmFtZSwgdHJ1ZSk7XG4gICAgICAgIHVwZGF0ZUZvcm1TdGF0ZSh7XG4gICAgICAgICAgaXNEaXJ0eTogaXNGb3JtRGlydHkoKVxuICAgICAgICB9KTtcbiAgICAgICAgcmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LmlzVmFsaWQgJiYgcmVzb2x2ZXJSZWYuY3VycmVudCAmJiB2YWxpZGF0ZVJlc29sdmVyKCk7XG4gICAgICAgIHVwZGF0ZVdhdGNoZWRWYWx1ZShmaWVsZC5yZWYubmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCBbdmFsaWRhdGVSZXNvbHZlciwgcmVtb3ZlRmllbGRFdmVudExpc3RlbmVyXSk7XG5cbiAgZnVuY3Rpb24gY2xlYXJFcnJvcnMobmFtZSkge1xuICAgIG5hbWUgJiYgKEFycmF5LmlzQXJyYXkobmFtZSkgPyBuYW1lIDogW25hbWVdKS5mb3JFYWNoKGZ1bmN0aW9uIChpbnB1dE5hbWUpIHtcbiAgICAgIHJldHVybiBmaWVsZHNSZWYuY3VycmVudFtpbnB1dE5hbWVdICYmIGlzS2V5KGlucHV0TmFtZSkgPyBkZWxldGUgZm9ybVN0YXRlUmVmLmN1cnJlbnQuZXJyb3JzW2lucHV0TmFtZV0gOiB1bnNldChmb3JtU3RhdGVSZWYuY3VycmVudC5lcnJvcnMsIGlucHV0TmFtZSk7XG4gICAgfSk7XG4gICAgdXBkYXRlRm9ybVN0YXRlKHtcbiAgICAgIGVycm9yczogbmFtZSA/IGZvcm1TdGF0ZVJlZi5jdXJyZW50LmVycm9ycyA6IHt9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRFcnJvcihuYW1lLCBlcnJvcikge1xuICAgIHZhciByZWYgPSAoZmllbGRzUmVmLmN1cnJlbnRbbmFtZV0gfHwge30pLnJlZjtcbiAgICBzZXQoZm9ybVN0YXRlUmVmLmN1cnJlbnQuZXJyb3JzLCBuYW1lLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGVycm9yKSwge1xuICAgICAgcmVmOiByZWZcbiAgICB9KSk7XG4gICAgdXBkYXRlRm9ybVN0YXRlKHtcbiAgICAgIGlzVmFsaWQ6IGZhbHNlXG4gICAgfSk7XG4gICAgZXJyb3Iuc2hvdWxkRm9jdXMgJiYgcmVmICYmIHJlZi5mb2N1cyAmJiByZWYuZm9jdXMoKTtcbiAgfVxuXG4gIHZhciB3YXRjaEludGVybmFsID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKGZpZWxkTmFtZXMsIGRlZmF1bHRWYWx1ZSwgd2F0Y2hJZCkge1xuICAgIHZhciB3YXRjaEZpZWxkcyA9IHdhdGNoSWQgPyB1c2VXYXRjaEZpZWxkc1JlZi5jdXJyZW50W3dhdGNoSWRdIDogd2F0Y2hGaWVsZHNSZWYuY3VycmVudDtcbiAgICB2YXIgZmllbGRWYWx1ZXMgPSBnZXRGaWVsZHNWYWx1ZXMoZmllbGRzUmVmLCBjbG9uZU9iamVjdChzaGFsbG93RmllbGRzU3RhdGVSZWYuY3VycmVudCksIHNob3VsZFVucmVnaXN0ZXIsIGZhbHNlLCBmaWVsZE5hbWVzKTtcblxuICAgIGlmIChpc1N0cmluZyhmaWVsZE5hbWVzKSkge1xuICAgICAgaWYgKGZpZWxkQXJyYXlOYW1lc1JlZi5jdXJyZW50LmhhcyhmaWVsZE5hbWVzKSkge1xuICAgICAgICB2YXIgZmllbGRBcnJheVZhbHVlID0gZ2V0KGZpZWxkQXJyYXlWYWx1ZXNSZWYuY3VycmVudCwgZmllbGROYW1lcywgW10pO1xuICAgICAgICBmaWVsZFZhbHVlcyA9ICFmaWVsZEFycmF5VmFsdWUubGVuZ3RoIHx8IGZpZWxkQXJyYXlWYWx1ZS5sZW5ndGggIT09IGNvbXBhY3QoZ2V0KGZpZWxkVmFsdWVzLCBmaWVsZE5hbWVzLCBbXSkpLmxlbmd0aCA/IGZpZWxkQXJyYXlWYWx1ZXNSZWYuY3VycmVudCA6IGZpZWxkVmFsdWVzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXNzaWduV2F0Y2hGaWVsZHMoZmllbGRWYWx1ZXMsIGZpZWxkTmFtZXMsIHdhdGNoRmllbGRzLCBpc1VuZGVmaW5lZChnZXQoZGVmYXVsdFZhbHVlc1JlZi5jdXJyZW50LCBmaWVsZE5hbWVzKSkgPyBkZWZhdWx0VmFsdWUgOiBnZXQoZGVmYXVsdFZhbHVlc1JlZi5jdXJyZW50LCBmaWVsZE5hbWVzKSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgdmFyIGNvbWJpbmVkRGVmYXVsdFZhbHVlcyA9IGlzVW5kZWZpbmVkKGRlZmF1bHRWYWx1ZSkgPyBkZWZhdWx0VmFsdWVzUmVmLmN1cnJlbnQgOiBkZWZhdWx0VmFsdWU7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShmaWVsZE5hbWVzKSkge1xuICAgICAgcmV0dXJuIGZpZWxkTmFtZXMucmVkdWNlKGZ1bmN0aW9uIChwcmV2aW91cywgbmFtZSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcmV2aW91cyksIF9kZWZpbmVQcm9wZXJ0eSh7fSwgbmFtZSwgYXNzaWduV2F0Y2hGaWVsZHMoZmllbGRWYWx1ZXMsIG5hbWUsIHdhdGNoRmllbGRzLCBjb21iaW5lZERlZmF1bHRWYWx1ZXMpKSk7XG4gICAgICB9LCB7fSk7XG4gICAgfVxuXG4gICAgaXNXYXRjaEFsbFJlZi5jdXJyZW50ID0gaXNVbmRlZmluZWQod2F0Y2hJZCk7XG4gICAgcmV0dXJuIHRyYW5zZm9ybVRvTmVzdE9iamVjdCghaXNFbXB0eU9iamVjdChmaWVsZFZhbHVlcykgJiYgZmllbGRWYWx1ZXMgfHwgY29tYmluZWREZWZhdWx0VmFsdWVzKTtcbiAgfSwgW10pO1xuXG4gIGZ1bmN0aW9uIHdhdGNoKGZpZWxkTmFtZXMsIGRlZmF1bHRWYWx1ZSkge1xuICAgIHJldHVybiB3YXRjaEludGVybmFsKGZpZWxkTmFtZXMsIGRlZmF1bHRWYWx1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiB1bnJlZ2lzdGVyKG5hbWUpIHtcbiAgICB2YXIgX2l0ZXJhdG9yOCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKEFycmF5LmlzQXJyYXkobmFtZSkgPyBuYW1lIDogW25hbWVdKSxcbiAgICAgICAgX3N0ZXA4O1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yOC5zKCk7ICEoX3N0ZXA4ID0gX2l0ZXJhdG9yOC5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBmaWVsZE5hbWUgPSBfc3RlcDgudmFsdWU7XG4gICAgICAgIHJlbW92ZUZpZWxkRXZlbnRMaXN0ZW5lckFuZFJlZihmaWVsZHNSZWYuY3VycmVudFtmaWVsZE5hbWVdLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvcjguZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3I4LmYoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWdpc3RlckZpZWxkUmVmKHJlZikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIXJlZi5uYW1lKSB7XG4gICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ/Cfk4sgRmllbGQgaXMgbWlzc2luZyBgbmFtZWAgYXR0cmlidXRlJywgcmVmLCBcImh0dHBzOi8vcmVhY3QtaG9vay1mb3JtLmNvbS9hcGkjdXNlRm9ybVwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZpZWxkQXJyYXlOYW1lc1JlZi5jdXJyZW50LmhhcyhyZWYubmFtZS5zcGxpdCgvXFxbXFxkK1xcXSQvKVswXSkgJiYgIVJlZ0V4cChcIl5cIi5jb25jYXQocmVmLm5hbWUuc3BsaXQoL1xcW1xcZCtcXF0kLylbMF0sIFwiW1xcXFxkK10uXFxcXHcrXCIpLnJlcGxhY2UoL1xcWy9nLCAnXFxcXFsnKS5yZXBsYWNlKC9cXF0vZywgJ1xcXFxdJykpLnRlc3QocmVmLm5hbWUpKSB7XG4gICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ/Cfk4sgYG5hbWVgIHByb3Agc2hvdWxkIGJlIGluIG9iamVjdCBzaGFwZTogbmFtZT1cInRlc3RbaW5kZXhdLm5hbWVcIicsIHJlZiwgJ2h0dHBzOi8vcmVhY3QtaG9vay1mb3JtLmNvbS9hcGkjdXNlRmllbGRBcnJheScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBuYW1lID0gcmVmLm5hbWUsXG4gICAgICAgIHR5cGUgPSByZWYudHlwZSxcbiAgICAgICAgdmFsdWUgPSByZWYudmFsdWU7XG4gICAgdmFyIGZpZWxkUmVmQW5kVmFsaWRhdGlvbk9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIHJlZjogcmVmXG4gICAgfSwgb3B0aW9ucyk7XG4gICAgdmFyIGZpZWxkcyA9IGZpZWxkc1JlZi5jdXJyZW50O1xuICAgIHZhciBpc1JhZGlvT3JDaGVja2JveCA9IGlzUmFkaW9PckNoZWNrYm94RnVuY3Rpb24ocmVmKTtcbiAgICB2YXIgaXNGaWVsZEFycmF5ID0gaXNOYW1lSW5GaWVsZEFycmF5KGZpZWxkQXJyYXlOYW1lc1JlZi5jdXJyZW50LCBuYW1lKTtcblxuICAgIHZhciBjb21wYXJlUmVmID0gZnVuY3Rpb24gY29tcGFyZVJlZihjdXJyZW50UmVmKSB7XG4gICAgICByZXR1cm4gaXNXZWIgJiYgKCFpc0hUTUxFbGVtZW50KHJlZikgfHwgY3VycmVudFJlZiA9PT0gcmVmKTtcbiAgICB9O1xuXG4gICAgdmFyIGZpZWxkID0gZmllbGRzW25hbWVdO1xuICAgIHZhciBpc0VtcHR5RGVmYXVsdFZhbHVlID0gdHJ1ZTtcbiAgICB2YXIgZGVmYXVsdFZhbHVlO1xuXG4gICAgaWYgKGZpZWxkICYmIChpc1JhZGlvT3JDaGVja2JveCA/IEFycmF5LmlzQXJyYXkoZmllbGQub3B0aW9ucykgJiYgY29tcGFjdChmaWVsZC5vcHRpb25zKS5maW5kKGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gb3B0aW9uLnJlZi52YWx1ZSAmJiBjb21wYXJlUmVmKG9wdGlvbi5yZWYpO1xuICAgIH0pIDogY29tcGFyZVJlZihmaWVsZC5yZWYpKSkge1xuICAgICAgZmllbGRzW25hbWVdID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmaWVsZCksIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlKSB7XG4gICAgICBmaWVsZCA9IGlzUmFkaW9PckNoZWNrYm94ID8gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIG9wdGlvbnM6IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoY29tcGFjdChmaWVsZCAmJiBmaWVsZC5vcHRpb25zIHx8IFtdKSksIFt7XG4gICAgICAgICAgcmVmOiByZWZcbiAgICAgICAgfV0pLFxuICAgICAgICByZWY6IHtcbiAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgfVxuICAgICAgfSwgb3B0aW9ucykgOiBPYmplY3QuYXNzaWduKHt9LCBmaWVsZFJlZkFuZFZhbGlkYXRpb25PcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmllbGQgPSBmaWVsZFJlZkFuZFZhbGlkYXRpb25PcHRpb25zO1xuICAgIH1cblxuICAgIGZpZWxkc1tuYW1lXSA9IGZpZWxkO1xuICAgIHZhciBpc0VtcHR5VW5tb3VudEZpZWxkcyA9IGlzVW5kZWZpbmVkKGdldChzaGFsbG93RmllbGRzU3RhdGVSZWYuY3VycmVudCwgbmFtZSkpO1xuXG4gICAgaWYgKCFpc0VtcHR5T2JqZWN0KGRlZmF1bHRWYWx1ZXNSZWYuY3VycmVudCkgfHwgIWlzRW1wdHlVbm1vdW50RmllbGRzKSB7XG4gICAgICBkZWZhdWx0VmFsdWUgPSBnZXQoaXNFbXB0eVVubW91bnRGaWVsZHMgPyBkZWZhdWx0VmFsdWVzUmVmLmN1cnJlbnQgOiBzaGFsbG93RmllbGRzU3RhdGVSZWYuY3VycmVudCwgbmFtZSk7XG4gICAgICBpc0VtcHR5RGVmYXVsdFZhbHVlID0gaXNVbmRlZmluZWQoZGVmYXVsdFZhbHVlKTtcblxuICAgICAgaWYgKCFpc0VtcHR5RGVmYXVsdFZhbHVlICYmICFpc0ZpZWxkQXJyYXkpIHtcbiAgICAgICAgc2V0RmllbGRWYWx1ZShuYW1lLCBkZWZhdWx0VmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaXNFbXB0eU9iamVjdChvcHRpb25zKSkge1xuICAgICAgc2V0KGZpZWxkc1dpdGhWYWxpZGF0aW9uUmVmLmN1cnJlbnQsIG5hbWUsIHRydWUpO1xuXG4gICAgICBpZiAoIWlzT25TdWJtaXQgJiYgcmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LmlzVmFsaWQpIHtcbiAgICAgICAgdmFsaWRhdGVGaWVsZChmaWVsZHNSZWYsIGlzVmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhLCBmaWVsZCwgc2hhbGxvd0ZpZWxkc1N0YXRlUmVmKS50aGVuKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgIHZhciBwcmV2aW91c0Zvcm1Jc1ZhbGlkID0gZm9ybVN0YXRlUmVmLmN1cnJlbnQuaXNWYWxpZDtcbiAgICAgICAgICBpc0VtcHR5T2JqZWN0KGVycm9yKSA/IHNldCh2YWxpZEZpZWxkc1JlZi5jdXJyZW50LCBuYW1lLCB0cnVlKSA6IHVuc2V0KHZhbGlkRmllbGRzUmVmLmN1cnJlbnQsIG5hbWUpO1xuICAgICAgICAgIHByZXZpb3VzRm9ybUlzVmFsaWQgIT09IGlzRW1wdHlPYmplY3QoZXJyb3IpICYmIHVwZGF0ZUZvcm1TdGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWRlZmF1bHRWYWx1ZXNBdFJlbmRlclJlZi5jdXJyZW50W25hbWVdICYmICEoaXNGaWVsZEFycmF5ICYmIGlzRW1wdHlEZWZhdWx0VmFsdWUpKSB7XG4gICAgICB2YXIgZmllbGRWYWx1ZSA9IGdldEZpZWxkVmFsdWUoZmllbGRzUmVmLCBuYW1lLCBzaGFsbG93RmllbGRzU3RhdGVSZWYpO1xuICAgICAgc2V0KGRlZmF1bHRWYWx1ZXNBdFJlbmRlclJlZi5jdXJyZW50LCBuYW1lLCBpc0VtcHR5RGVmYXVsdFZhbHVlID8gaXNPYmplY3QoZmllbGRWYWx1ZSkgPyBPYmplY3QuYXNzaWduKHt9LCBmaWVsZFZhbHVlKSA6IGZpZWxkVmFsdWUgOiBkZWZhdWx0VmFsdWUpO1xuICAgICAgIWlzRmllbGRBcnJheSAmJiB1bnNldChmb3JtU3RhdGVSZWYuY3VycmVudC5kaXJ0eUZpZWxkcywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUpIHtcbiAgICAgIGF0dGFjaEV2ZW50TGlzdGVuZXJzKGlzUmFkaW9PckNoZWNrYm94ICYmIGZpZWxkLm9wdGlvbnMgPyBmaWVsZC5vcHRpb25zW2ZpZWxkLm9wdGlvbnMubGVuZ3RoIC0gMV0gOiBmaWVsZCwgaXNSYWRpb09yQ2hlY2tib3ggfHwgaXNTZWxlY3RJbnB1dChyZWYpLCBoYW5kbGVDaGFuZ2VSZWYuY3VycmVudCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXIocmVmT3JSZWdpc3Rlck9wdGlvbnMsIG9wdGlvbnMpIHtcbiAgICBpZiAoIWlzV2luZG93VW5kZWZpbmVkKSB7XG4gICAgICBpZiAoaXNTdHJpbmcocmVmT3JSZWdpc3Rlck9wdGlvbnMpKSB7XG4gICAgICAgIHJlZ2lzdGVyRmllbGRSZWYoe1xuICAgICAgICAgIG5hbWU6IHJlZk9yUmVnaXN0ZXJPcHRpb25zXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChyZWZPclJlZ2lzdGVyT3B0aW9ucykgJiYgJ25hbWUnIGluIHJlZk9yUmVnaXN0ZXJPcHRpb25zKSB7XG4gICAgICAgIHJlZ2lzdGVyRmllbGRSZWYocmVmT3JSZWdpc3Rlck9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICByZXR1cm4gcmVmICYmIHJlZ2lzdGVyRmllbGRSZWYocmVmLCByZWZPclJlZ2lzdGVyT3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGhhbmRsZVN1Ym1pdCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChvblZhbGlkLCBvbkludmFsaWQpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcmVmMjEgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlOChlKSB7XG4gICAgICAgIHZhciBmaWVsZEVycm9ycywgZmllbGRWYWx1ZXMsIF95aWVsZCRyZXNvbHZlclJlZiRjdTQsIGVycm9ycywgdmFsdWVzLCBfaTQsIF9PYmplY3QkdmFsdWVzMiwgZmllbGQsIF9uYW1lMiwgZmllbGRFcnJvcjtcblxuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU4JChfY29udGV4dDgpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDgucHJldiA9IF9jb250ZXh0OC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBpZiAoZSAmJiBlLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICBlLnBlcnNpc3QoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmaWVsZEVycm9ycyA9IHt9O1xuICAgICAgICAgICAgICAgIGZpZWxkVmFsdWVzID0gc2V0RmllbGRBcnJheURlZmF1bHRWYWx1ZXMoZ2V0RmllbGRzVmFsdWVzKGZpZWxkc1JlZiwgY2xvbmVPYmplY3Qoc2hhbGxvd0ZpZWxkc1N0YXRlUmVmLmN1cnJlbnQpLCBzaG91bGRVbnJlZ2lzdGVyLCB0cnVlKSk7XG4gICAgICAgICAgICAgICAgcmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LmlzU3VibWl0dGluZyAmJiB1cGRhdGVGb3JtU3RhdGUoe1xuICAgICAgICAgICAgICAgICAgaXNTdWJtaXR0aW5nOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ4LnByZXYgPSA0O1xuXG4gICAgICAgICAgICAgICAgaWYgKCFyZXNvbHZlclJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDE1O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSA4O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlclJlZi5jdXJyZW50KGZpZWxkVmFsdWVzLCBjb250ZXh0UmVmLmN1cnJlbnQsIGlzVmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhKTtcblxuICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgX3lpZWxkJHJlc29sdmVyUmVmJGN1NCA9IF9jb250ZXh0OC5zZW50O1xuICAgICAgICAgICAgICAgIGVycm9ycyA9IF95aWVsZCRyZXNvbHZlclJlZiRjdTQuZXJyb3JzO1xuICAgICAgICAgICAgICAgIHZhbHVlcyA9IF95aWVsZCRyZXNvbHZlclJlZiRjdTQudmFsdWVzO1xuICAgICAgICAgICAgICAgIGZvcm1TdGF0ZVJlZi5jdXJyZW50LmVycm9ycyA9IGZpZWxkRXJyb3JzID0gZXJyb3JzO1xuICAgICAgICAgICAgICAgIGZpZWxkVmFsdWVzID0gdmFsdWVzO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gMjc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICBfaTQgPSAwLCBfT2JqZWN0JHZhbHVlczIgPSBPYmplY3QudmFsdWVzKGZpZWxkc1JlZi5jdXJyZW50KTtcblxuICAgICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICAgIGlmICghKF9pNCA8IF9PYmplY3QkdmFsdWVzMi5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDI3O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZmllbGQgPSBfT2JqZWN0JHZhbHVlczJbX2k0XTtcblxuICAgICAgICAgICAgICAgIGlmICghZmllbGQpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gMjQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfbmFtZTIgPSBmaWVsZC5yZWYubmFtZTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDIyO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZUZpZWxkKGZpZWxkc1JlZiwgaXNWYWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEsIGZpZWxkLCBzaGFsbG93RmllbGRzU3RhdGVSZWYpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgICAgICAgZmllbGRFcnJvciA9IF9jb250ZXh0OC5zZW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkRXJyb3JbX25hbWUyXSkge1xuICAgICAgICAgICAgICAgICAgc2V0KGZpZWxkRXJyb3JzLCBfbmFtZTIsIGZpZWxkRXJyb3JbX25hbWUyXSk7XG4gICAgICAgICAgICAgICAgICB1bnNldCh2YWxpZEZpZWxkc1JlZi5jdXJyZW50LCBfbmFtZTIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZ2V0KGZpZWxkc1dpdGhWYWxpZGF0aW9uUmVmLmN1cnJlbnQsIF9uYW1lMikpIHtcbiAgICAgICAgICAgICAgICAgIHVuc2V0KGZvcm1TdGF0ZVJlZi5jdXJyZW50LmVycm9ycywgX25hbWUyKTtcbiAgICAgICAgICAgICAgICAgIHNldCh2YWxpZEZpZWxkc1JlZi5jdXJyZW50LCBfbmFtZTIsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgICAgICAgIF9pNCsrO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gMTY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAgICAgICBpZiAoIShpc0VtcHR5T2JqZWN0KGZpZWxkRXJyb3JzKSAmJiBPYmplY3Qua2V5cyhmb3JtU3RhdGVSZWYuY3VycmVudC5lcnJvcnMpLmV2ZXJ5KGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZSBpbiBmaWVsZHNSZWYuY3VycmVudDtcbiAgICAgICAgICAgICAgICB9KSkpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gMzM7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB1cGRhdGVGb3JtU3RhdGUoe1xuICAgICAgICAgICAgICAgICAgZXJyb3JzOiB7fSxcbiAgICAgICAgICAgICAgICAgIGlzU3VibWl0dGluZzogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gMzE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9uVmFsaWQoZmllbGRWYWx1ZXMsIGUpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzE6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSAzOTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDMzOlxuICAgICAgICAgICAgICAgIGZvcm1TdGF0ZVJlZi5jdXJyZW50LmVycm9ycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZm9ybVN0YXRlUmVmLmN1cnJlbnQuZXJyb3JzKSwgZmllbGRFcnJvcnMpO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0OC50MCA9IG9uSW52YWxpZDtcblxuICAgICAgICAgICAgICAgIGlmICghX2NvbnRleHQ4LnQwKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDM4O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSAzODtcbiAgICAgICAgICAgICAgICByZXR1cm4gb25JbnZhbGlkKGZvcm1TdGF0ZVJlZi5jdXJyZW50LmVycm9ycywgZSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzODpcbiAgICAgICAgICAgICAgICBzaG91bGRGb2N1c0Vycm9yICYmIGZvY3VzT25FcnJvckZpZWxkKGZpZWxkc1JlZi5jdXJyZW50LCBmb3JtU3RhdGVSZWYuY3VycmVudC5lcnJvcnMpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzk6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ4LnByZXYgPSAzOTtcbiAgICAgICAgICAgICAgICBmb3JtU3RhdGVSZWYuY3VycmVudC5pc1N1Ym1pdHRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB1cGRhdGVGb3JtU3RhdGUoe1xuICAgICAgICAgICAgICAgICAgaXNTdWJtaXR0ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICBpc1N1Ym1pdHRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgaXNTdWJtaXRTdWNjZXNzZnVsOiBpc0VtcHR5T2JqZWN0KGZvcm1TdGF0ZVJlZi5jdXJyZW50LmVycm9ycyksXG4gICAgICAgICAgICAgICAgICBzdWJtaXRDb3VudDogZm9ybVN0YXRlUmVmLmN1cnJlbnQuc3VibWl0Q291bnQgKyAxXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5maW5pc2goMzkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNDM6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU4LCBudWxsLCBbWzQsLCAzOSwgNDNdXSk7XG4gICAgICB9KSk7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoX3gxMSkge1xuICAgICAgICByZXR1cm4gX3JlZjIxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH0oKTtcbiAgfSwgW3Nob3VsZEZvY3VzRXJyb3IsIGlzVmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhXSk7XG5cbiAgdmFyIHJlc2V0UmVmcyA9IGZ1bmN0aW9uIHJlc2V0UmVmcyhfcmVmMjIpIHtcbiAgICB2YXIgZXJyb3JzID0gX3JlZjIyLmVycm9ycyxcbiAgICAgICAgaXNEaXJ0eSA9IF9yZWYyMi5pc0RpcnR5LFxuICAgICAgICBpc1N1Ym1pdHRlZCA9IF9yZWYyMi5pc1N1Ym1pdHRlZCxcbiAgICAgICAgdG91Y2hlZCA9IF9yZWYyMi50b3VjaGVkLFxuICAgICAgICBpc1ZhbGlkID0gX3JlZjIyLmlzVmFsaWQsXG4gICAgICAgIHN1Ym1pdENvdW50ID0gX3JlZjIyLnN1Ym1pdENvdW50LFxuICAgICAgICBkaXJ0eUZpZWxkcyA9IF9yZWYyMi5kaXJ0eUZpZWxkcztcblxuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgdmFsaWRGaWVsZHNSZWYuY3VycmVudCA9IHt9O1xuICAgICAgZmllbGRzV2l0aFZhbGlkYXRpb25SZWYuY3VycmVudCA9IHt9O1xuICAgIH1cblxuICAgIGRlZmF1bHRWYWx1ZXNBdFJlbmRlclJlZi5jdXJyZW50ID0ge307XG4gICAgZmllbGRBcnJheURlZmF1bHRWYWx1ZXNSZWYuY3VycmVudCA9IHt9O1xuICAgIHdhdGNoRmllbGRzUmVmLmN1cnJlbnQgPSBuZXcgU2V0KCk7XG4gICAgaXNXYXRjaEFsbFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgdXBkYXRlRm9ybVN0YXRlKHtcbiAgICAgIHN1Ym1pdENvdW50OiBzdWJtaXRDb3VudCA/IGZvcm1TdGF0ZVJlZi5jdXJyZW50LnN1Ym1pdENvdW50IDogMCxcbiAgICAgIGlzRGlydHk6IGlzRGlydHkgPyBmb3JtU3RhdGVSZWYuY3VycmVudC5pc0RpcnR5IDogZmFsc2UsXG4gICAgICBpc1N1Ym1pdHRlZDogaXNTdWJtaXR0ZWQgPyBmb3JtU3RhdGVSZWYuY3VycmVudC5pc1N1Ym1pdHRlZCA6IGZhbHNlLFxuICAgICAgaXNWYWxpZDogaXNWYWxpZCA/IGZvcm1TdGF0ZVJlZi5jdXJyZW50LmlzVmFsaWQgOiBmYWxzZSxcbiAgICAgIGRpcnR5RmllbGRzOiBkaXJ0eUZpZWxkcyA/IGZvcm1TdGF0ZVJlZi5jdXJyZW50LmRpcnR5RmllbGRzIDoge30sXG4gICAgICB0b3VjaGVkOiB0b3VjaGVkID8gZm9ybVN0YXRlUmVmLmN1cnJlbnQudG91Y2hlZCA6IHt9LFxuICAgICAgZXJyb3JzOiBlcnJvcnMgPyBmb3JtU3RhdGVSZWYuY3VycmVudC5lcnJvcnMgOiB7fSxcbiAgICAgIGlzU3VibWl0dGluZzogZmFsc2UsXG4gICAgICBpc1N1Ym1pdFN1Y2Nlc3NmdWw6IGZhbHNlXG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHJlc2V0ID0gZnVuY3Rpb24gcmVzZXQodmFsdWVzKSB7XG4gICAgdmFyIG9taXRSZXNldFN0YXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIGlmIChpc1dlYikge1xuICAgICAgZm9yICh2YXIgX2k1ID0gMCwgX09iamVjdCR2YWx1ZXMzID0gT2JqZWN0LnZhbHVlcyhmaWVsZHNSZWYuY3VycmVudCk7IF9pNSA8IF9PYmplY3QkdmFsdWVzMy5sZW5ndGg7IF9pNSsrKSB7XG4gICAgICAgIHZhciBmaWVsZCA9IF9PYmplY3QkdmFsdWVzM1tfaTVdO1xuXG4gICAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICAgIHZhciBfcmVmMjMgPSBmaWVsZC5yZWYsXG4gICAgICAgICAgICAgIG9wdGlvbnMgPSBmaWVsZC5vcHRpb25zO1xuICAgICAgICAgIHZhciBpbnB1dFJlZiA9IGlzUmFkaW9PckNoZWNrYm94RnVuY3Rpb24oX3JlZjIzKSAmJiBBcnJheS5pc0FycmF5KG9wdGlvbnMpID8gb3B0aW9uc1swXS5yZWYgOiBfcmVmMjM7XG5cbiAgICAgICAgICBpZiAoaXNIVE1MRWxlbWVudChpbnB1dFJlZikpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlucHV0UmVmLmNsb3Nlc3QoJ2Zvcm0nKS5yZXNldCgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gY2F0Y2ggKF9hKSB7fVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZpZWxkc1JlZi5jdXJyZW50ID0ge307XG4gICAgZGVmYXVsdFZhbHVlc1JlZi5jdXJyZW50ID0gY2xvbmVPYmplY3QodmFsdWVzIHx8IGRlZmF1bHRWYWx1ZXNSZWYuY3VycmVudCk7XG4gICAgdmFsdWVzICYmIHJlbmRlcldhdGNoZWRJbnB1dHMoJycpO1xuICAgIE9iamVjdC52YWx1ZXMocmVzZXRGaWVsZEFycmF5RnVuY3Rpb25SZWYuY3VycmVudCkuZm9yRWFjaChmdW5jdGlvbiAocmVzZXRGaWVsZEFycmF5KSB7XG4gICAgICByZXR1cm4gaXNGdW5jdGlvbihyZXNldEZpZWxkQXJyYXkpICYmIHJlc2V0RmllbGRBcnJheSgpO1xuICAgIH0pO1xuICAgIHNoYWxsb3dGaWVsZHNTdGF0ZVJlZi5jdXJyZW50ID0gc2hvdWxkVW5yZWdpc3RlciA/IHt9IDogY2xvbmVPYmplY3QodmFsdWVzKSB8fCB7fTtcbiAgICByZXNldFJlZnMob21pdFJlc2V0U3RhdGUpO1xuICB9O1xuXG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcmVzb2x2ZXIgJiYgcmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LmlzVmFsaWQgJiYgdmFsaWRhdGVSZXNvbHZlcigpO1xuICAgIG9ic2VydmVyUmVmLmN1cnJlbnQgPSBvYnNlcnZlclJlZi5jdXJyZW50IHx8ICFpc1dlYiA/IG9ic2VydmVyUmVmLmN1cnJlbnQgOiBvbkRvbVJlbW92ZShmaWVsZHNSZWYsIHJlbW92ZUZpZWxkRXZlbnRMaXN0ZW5lckFuZFJlZik7XG4gIH0sIFtyZW1vdmVGaWVsZEV2ZW50TGlzdGVuZXJBbmRSZWYsIGRlZmF1bHRWYWx1ZXNSZWYuY3VycmVudF0pO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBvYnNlcnZlclJlZi5jdXJyZW50ICYmIG9ic2VydmVyUmVmLmN1cnJlbnQuZGlzY29ubmVjdCgpO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlzVW5Nb3VudC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIE9iamVjdC52YWx1ZXMoZmllbGRzUmVmLmN1cnJlbnQpLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgIHJldHVybiByZW1vdmVGaWVsZEV2ZW50TGlzdGVuZXJBbmRSZWYoZmllbGQsIHRydWUpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIGlmICghcmVzb2x2ZXIgJiYgcmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LmlzVmFsaWQpIHtcbiAgICBmb3JtU3RhdGUuaXNWYWxpZCA9IGRlZXBFcXVhbCh2YWxpZEZpZWxkc1JlZi5jdXJyZW50LCBmaWVsZHNXaXRoVmFsaWRhdGlvblJlZi5jdXJyZW50KSAmJiBpc0VtcHR5T2JqZWN0KGZvcm1TdGF0ZVJlZi5jdXJyZW50LmVycm9ycyk7XG4gIH1cblxuICB2YXIgY29tbW9uUHJvcHMgPSB7XG4gICAgdHJpZ2dlcjogdHJpZ2dlcixcbiAgICBzZXRWYWx1ZTogdXNlQ2FsbGJhY2soc2V0VmFsdWUsIFtzZXRJbnRlcm5hbFZhbHVlLCB0cmlnZ2VyXSksXG4gICAgZ2V0VmFsdWVzOiB1c2VDYWxsYmFjayhnZXRWYWx1ZXMsIFtdKSxcbiAgICByZWdpc3RlcjogdXNlQ2FsbGJhY2socmVnaXN0ZXIsIFtkZWZhdWx0VmFsdWVzUmVmLmN1cnJlbnRdKSxcbiAgICB1bnJlZ2lzdGVyOiB1c2VDYWxsYmFjayh1bnJlZ2lzdGVyLCBbXSlcbiAgfTtcbiAgdmFyIGNvbnRyb2wgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7XG4gICAgICBpc0Zvcm1EaXJ0eTogaXNGb3JtRGlydHksXG4gICAgICB1cGRhdGVXYXRjaGVkVmFsdWU6IHVwZGF0ZVdhdGNoZWRWYWx1ZSxcbiAgICAgIHNob3VsZFVucmVnaXN0ZXI6IHNob3VsZFVucmVnaXN0ZXIsXG4gICAgICB1cGRhdGVGb3JtU3RhdGU6IHVwZGF0ZUZvcm1TdGF0ZSxcbiAgICAgIHJlbW92ZUZpZWxkRXZlbnRMaXN0ZW5lcjogcmVtb3ZlRmllbGRFdmVudExpc3RlbmVyLFxuICAgICAgd2F0Y2hJbnRlcm5hbDogd2F0Y2hJbnRlcm5hbCxcbiAgICAgIG1vZGU6IG1vZGVSZWYuY3VycmVudCxcbiAgICAgIHJlVmFsaWRhdGVNb2RlOiB7XG4gICAgICAgIGlzUmVWYWxpZGF0ZU9uQmx1cjogaXNSZVZhbGlkYXRlT25CbHVyLFxuICAgICAgICBpc1JlVmFsaWRhdGVPbkNoYW5nZTogaXNSZVZhbGlkYXRlT25DaGFuZ2VcbiAgICAgIH0sXG4gICAgICB2YWxpZGF0ZVJlc29sdmVyOiByZXNvbHZlciA/IHZhbGlkYXRlUmVzb2x2ZXIgOiB1bmRlZmluZWQsXG4gICAgICBmaWVsZHNSZWY6IGZpZWxkc1JlZixcbiAgICAgIHJlc2V0RmllbGRBcnJheUZ1bmN0aW9uUmVmOiByZXNldEZpZWxkQXJyYXlGdW5jdGlvblJlZixcbiAgICAgIHVzZVdhdGNoRmllbGRzUmVmOiB1c2VXYXRjaEZpZWxkc1JlZixcbiAgICAgIHVzZVdhdGNoUmVuZGVyRnVuY3Rpb25zUmVmOiB1c2VXYXRjaFJlbmRlckZ1bmN0aW9uc1JlZixcbiAgICAgIGZpZWxkQXJyYXlEZWZhdWx0VmFsdWVzUmVmOiBmaWVsZEFycmF5RGVmYXVsdFZhbHVlc1JlZixcbiAgICAgIHZhbGlkRmllbGRzUmVmOiB2YWxpZEZpZWxkc1JlZixcbiAgICAgIGZpZWxkc1dpdGhWYWxpZGF0aW9uUmVmOiBmaWVsZHNXaXRoVmFsaWRhdGlvblJlZixcbiAgICAgIGZpZWxkQXJyYXlOYW1lc1JlZjogZmllbGRBcnJheU5hbWVzUmVmLFxuICAgICAgcmVhZEZvcm1TdGF0ZVJlZjogcmVhZEZvcm1TdGF0ZVJlZixcbiAgICAgIGZvcm1TdGF0ZVJlZjogZm9ybVN0YXRlUmVmLFxuICAgICAgZGVmYXVsdFZhbHVlc1JlZjogZGVmYXVsdFZhbHVlc1JlZixcbiAgICAgIHNoYWxsb3dGaWVsZHNTdGF0ZVJlZjogc2hhbGxvd0ZpZWxkc1N0YXRlUmVmLFxuICAgICAgZmllbGRBcnJheVZhbHVlc1JlZjogZmllbGRBcnJheVZhbHVlc1JlZlxuICAgIH0sIGNvbW1vblByb3BzKTtcbiAgfSwgW2RlZmF1bHRWYWx1ZXNSZWYuY3VycmVudCwgdXBkYXRlV2F0Y2hlZFZhbHVlLCBzaG91bGRVbnJlZ2lzdGVyLCByZW1vdmVGaWVsZEV2ZW50TGlzdGVuZXIsIHdhdGNoSW50ZXJuYWxdKTtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe1xuICAgIHdhdGNoOiB3YXRjaCxcbiAgICBjb250cm9sOiBjb250cm9sLFxuICAgIGZvcm1TdGF0ZTogaXNQcm94eUVuYWJsZWQgPyBuZXcgUHJveHkoZm9ybVN0YXRlLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldChvYmosIHByb3ApIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAocHJvcCA9PT0gJ2lzVmFsaWQnICYmIGlzT25TdWJtaXQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2Fybign8J+TiyBgZm9ybVN0YXRlLmlzVmFsaWRgIGlzIGFwcGxpY2FibGUgd2l0aCBgb25Ub3VjaGVkYCwgYG9uQ2hhbmdlYCBvciBgb25CbHVyYCBtb2RlLiBodHRwczovL3JlYWN0LWhvb2stZm9ybS5jb20vYXBpI2Zvcm1TdGF0ZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9wIGluIG9iaikge1xuICAgICAgICAgIHJlYWRGb3JtU3RhdGVSZWYuY3VycmVudFtwcm9wXSA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIG9ialtwcm9wXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSkgOiBmb3JtU3RhdGUsXG4gICAgaGFuZGxlU3VibWl0OiBoYW5kbGVTdWJtaXQsXG4gICAgcmVzZXQ6IHVzZUNhbGxiYWNrKHJlc2V0LCBbXSksXG4gICAgY2xlYXJFcnJvcnM6IHVzZUNhbGxiYWNrKGNsZWFyRXJyb3JzLCBbXSksXG4gICAgc2V0RXJyb3I6IHVzZUNhbGxiYWNrKHNldEVycm9yLCBbXSksXG4gICAgZXJyb3JzOiBmb3JtU3RhdGUuZXJyb3JzXG4gIH0sIGNvbW1vblByb3BzKTtcbn1cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cblxuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcbiAgdmFyIHQgPSB7fTtcblxuICBmb3IgKHZhciBwIGluIHMpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApIHRbcF0gPSBzW3BdO1xuICB9XG5cbiAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKSBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKSB0W3BbaV1dID0gc1twW2ldXTtcbiAgfVxuICByZXR1cm4gdDtcbn1cblxudmFyIEZvcm1Db250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcbkZvcm1Db250ZXh0LmRpc3BsYXlOYW1lID0gJ1JIRkNvbnRleHQnO1xuXG52YXIgdXNlRm9ybUNvbnRleHQgPSBmdW5jdGlvbiB1c2VGb3JtQ29udGV4dCgpIHtcbiAgcmV0dXJuIHVzZUNvbnRleHQoRm9ybUNvbnRleHQpO1xufTtcblxudmFyIEZvcm1Qcm92aWRlciA9IGZ1bmN0aW9uIEZvcm1Qcm92aWRlcihfYSkge1xuICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbixcbiAgICAgIHByb3BzID0gX19yZXN0KF9hLCBbXCJjaGlsZHJlblwiXSk7XG5cbiAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoRm9ybUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpXG4gIH0sIGNoaWxkcmVuKTtcbn07XG5cbnZhciBnZW5lcmF0ZUlkID0gZnVuY3Rpb24gZ2VuZXJhdGVJZCgpIHtcbiAgdmFyIGQgPSB0eXBlb2YgcGVyZm9ybWFuY2UgPT09IFVOREVGSU5FRCA/IERhdGUubm93KCkgOiBwZXJmb3JtYW5jZS5ub3coKSAqIDEwMDA7XG4gIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgdmFyIHIgPSAoTWF0aC5yYW5kb20oKSAqIDE2ICsgZCkgJSAxNiB8IDA7XG4gICAgcmV0dXJuIChjID09ICd4JyA/IHIgOiByICYgMHgzIHwgMHg4KS50b1N0cmluZygxNik7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gcmVtb3ZlQXRJbmRleGVzKGRhdGEsIGluZGV4ZXMpIHtcbiAgdmFyIGkgPSAwO1xuXG4gIHZhciB0ZW1wID0gX3RvQ29uc3VtYWJsZUFycmF5KGRhdGEpO1xuXG4gIHZhciBfaXRlcmF0b3I5ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoaW5kZXhlcyksXG4gICAgICBfc3RlcDk7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvcjkucygpOyAhKF9zdGVwOSA9IF9pdGVyYXRvcjkubigpKS5kb25lOykge1xuICAgICAgdmFyIGluZGV4ID0gX3N0ZXA5LnZhbHVlO1xuICAgICAgdGVtcC5zcGxpY2UoaW5kZXggLSBpLCAxKTtcbiAgICAgIGkrKztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvcjkuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvcjkuZigpO1xuICB9XG5cbiAgcmV0dXJuIGNvbXBhY3QodGVtcCkubGVuZ3RoID8gdGVtcCA6IFtdO1xufVxuXG52YXIgcmVtb3ZlQXJyYXlBdCA9IGZ1bmN0aW9uIHJlbW92ZUFycmF5QXQoZGF0YSwgaW5kZXgpIHtcbiAgcmV0dXJuIGlzVW5kZWZpbmVkKGluZGV4KSA/IFtdIDogcmVtb3ZlQXRJbmRleGVzKGRhdGEsIChBcnJheS5pc0FycmF5KGluZGV4KSA/IGluZGV4IDogW2luZGV4XSkuc29ydCgpKTtcbn07XG5cbnZhciBtb3ZlQXJyYXlBdCA9IGZ1bmN0aW9uIG1vdmVBcnJheUF0KGRhdGEsIGZyb20sIHRvKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgaWYgKGlzVW5kZWZpbmVkKGRhdGFbdG9dKSkge1xuICAgICAgZGF0YVt0b10gPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZGF0YS5zcGxpY2UodG8sIDAsIGRhdGEuc3BsaWNlKGZyb20sIDEpWzBdKTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHJldHVybiBbXTtcbn07XG5cbnZhciBzd2FwQXJyYXlBdCA9IGZ1bmN0aW9uIHN3YXBBcnJheUF0KGRhdGEsIGluZGV4QSwgaW5kZXhCKSB7XG4gIHZhciB0ZW1wID0gW2RhdGFbaW5kZXhCXSwgZGF0YVtpbmRleEFdXTtcbiAgZGF0YVtpbmRleEFdID0gdGVtcFswXTtcbiAgZGF0YVtpbmRleEJdID0gdGVtcFsxXTtcbn07XG5cbmZ1bmN0aW9uIHByZXBlbmQoZGF0YSwgdmFsdWUpIHtcbiAgcmV0dXJuIFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZSB8fCB1bmRlZmluZWRdKSwgX3RvQ29uc3VtYWJsZUFycmF5KGRhdGEpKTtcbn1cblxuZnVuY3Rpb24gaW5zZXJ0KGRhdGEsIGluZGV4LCB2YWx1ZSkge1xuICByZXR1cm4gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShkYXRhLnNsaWNlKDAsIGluZGV4KSksIF90b0NvbnN1bWFibGVBcnJheShBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlIHx8IHVuZGVmaW5lZF0pLCBfdG9Db25zdW1hYmxlQXJyYXkoZGF0YS5zbGljZShpbmRleCkpKTtcbn1cblxudmFyIGZpbGxFbXB0eUFycmF5ID0gZnVuY3Rpb24gZmlsbEVtcHR5QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpID8gQXJyYXkodmFsdWUubGVuZ3RoKS5maWxsKHVuZGVmaW5lZCkgOiB1bmRlZmluZWQ7XG59O1xuXG52YXIgZmlsbEJvb2xlYW5BcnJheSA9IGZ1bmN0aW9uIGZpbGxCb29sZWFuQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIChBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXSkubWFwKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKGlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICB2YXIgb2JqZWN0ID0ge307XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICAgIG9iamVjdFtrZXldID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG59O1xuXG52YXIgbWFwSWRzID0gZnVuY3Rpb24gbWFwSWRzKCkge1xuICB2YXIgdmFsdWVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbXTtcbiAgdmFyIGtleU5hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBfaXRlcmF0b3IxMCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHZhbHVlcyksXG4gICAgICAgIF9zdGVwMTA7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3IxMC5zKCk7ICEoX3N0ZXAxMCA9IF9pdGVyYXRvcjEwLm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIHZhbHVlID0gX3N0ZXAxMC52YWx1ZTtcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGlmIChrZXlOYW1lIGluIHZhbHVlKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJcXHVEODNEXFx1RENDQiB1c2VGaWVsZEFycmF5IGZpZWxkVmFsdWVzIGNvbnRhaW4gdGhlIGtleU5hbWUgYFwiLmNvbmNhdChrZXlOYW1lLCBcImAgd2hpY2ggaXMgcmVzZXJ2ZWQgZm9yIHVzZSBieSB1c2VGaWVsZEFycmF5LiBodHRwczovL3JlYWN0LWhvb2stZm9ybS5jb20vYXBpI3VzZUZpZWxkQXJyYXlcIikpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIlxcdUQ4M0RcXHVEQ0NCIHVzZUZpZWxkQXJyYXkgaW5wdXQncyBuYW1lIHNob3VsZCBiZSBpbiBvYmplY3Qgc2hhcGUgaW5zdGVhZCBvZiBmbGF0IGFycmF5LiBodHRwczovL3JlYWN0LWhvb2stZm9ybS5jb20vYXBpI3VzZUZpZWxkQXJyYXlcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvcjEwLmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yMTAuZigpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2YWx1ZXMubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKF9kZWZpbmVQcm9wZXJ0eSh7fSwga2V5TmFtZSwgZ2VuZXJhdGVJZCgpKSwgdmFsdWUpO1xuICB9KTtcbn07XG5cbnZhciB1c2VGaWVsZEFycmF5ID0gZnVuY3Rpb24gdXNlRmllbGRBcnJheShfcmVmMjQpIHtcbiAgdmFyIGNvbnRyb2wgPSBfcmVmMjQuY29udHJvbCxcbiAgICAgIG5hbWUgPSBfcmVmMjQubmFtZSxcbiAgICAgIF9yZWYyNCRrZXlOYW1lID0gX3JlZjI0LmtleU5hbWUsXG4gICAgICBrZXlOYW1lID0gX3JlZjI0JGtleU5hbWUgPT09IHZvaWQgMCA/ICdpZCcgOiBfcmVmMjQka2V5TmFtZTtcbiAgdmFyIG1ldGhvZHMgPSB1c2VGb3JtQ29udGV4dCgpO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKCFjb250cm9sICYmICFtZXRob2RzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ/Cfk4sgdXNlRmllbGRBcnJheSBpcyBtaXNzaW5nIGBjb250cm9sYCBwcm9wLiBodHRwczovL3JlYWN0LWhvb2stZm9ybS5jb20vYXBpI3VzZUZpZWxkQXJyYXknKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZm9jdXNJbmRleFJlZiA9IHVzZVJlZigtMSk7XG5cbiAgdmFyIF9yZWYyNSA9IGNvbnRyb2wgfHwgbWV0aG9kcy5jb250cm9sLFxuICAgICAgaXNGb3JtRGlydHkgPSBfcmVmMjUuaXNGb3JtRGlydHksXG4gICAgICB1cGRhdGVXYXRjaGVkVmFsdWUgPSBfcmVmMjUudXBkYXRlV2F0Y2hlZFZhbHVlLFxuICAgICAgcmVzZXRGaWVsZEFycmF5RnVuY3Rpb25SZWYgPSBfcmVmMjUucmVzZXRGaWVsZEFycmF5RnVuY3Rpb25SZWYsXG4gICAgICBmaWVsZEFycmF5TmFtZXNSZWYgPSBfcmVmMjUuZmllbGRBcnJheU5hbWVzUmVmLFxuICAgICAgZmllbGRzUmVmID0gX3JlZjI1LmZpZWxkc1JlZixcbiAgICAgIGRlZmF1bHRWYWx1ZXNSZWYgPSBfcmVmMjUuZGVmYXVsdFZhbHVlc1JlZixcbiAgICAgIHJlbW92ZUZpZWxkRXZlbnRMaXN0ZW5lciA9IF9yZWYyNS5yZW1vdmVGaWVsZEV2ZW50TGlzdGVuZXIsXG4gICAgICBmb3JtU3RhdGVSZWYgPSBfcmVmMjUuZm9ybVN0YXRlUmVmLFxuICAgICAgc2hhbGxvd0ZpZWxkc1N0YXRlUmVmID0gX3JlZjI1LnNoYWxsb3dGaWVsZHNTdGF0ZVJlZixcbiAgICAgIHVwZGF0ZUZvcm1TdGF0ZSA9IF9yZWYyNS51cGRhdGVGb3JtU3RhdGUsXG4gICAgICByZWFkRm9ybVN0YXRlUmVmID0gX3JlZjI1LnJlYWRGb3JtU3RhdGVSZWYsXG4gICAgICB2YWxpZEZpZWxkc1JlZiA9IF9yZWYyNS52YWxpZEZpZWxkc1JlZixcbiAgICAgIGZpZWxkc1dpdGhWYWxpZGF0aW9uUmVmID0gX3JlZjI1LmZpZWxkc1dpdGhWYWxpZGF0aW9uUmVmLFxuICAgICAgZmllbGRBcnJheURlZmF1bHRWYWx1ZXNSZWYgPSBfcmVmMjUuZmllbGRBcnJheURlZmF1bHRWYWx1ZXNSZWYsXG4gICAgICB2YWxpZGF0ZVJlc29sdmVyID0gX3JlZjI1LnZhbGlkYXRlUmVzb2x2ZXIsXG4gICAgICBnZXRWYWx1ZXMgPSBfcmVmMjUuZ2V0VmFsdWVzLFxuICAgICAgc2hvdWxkVW5yZWdpc3RlciA9IF9yZWYyNS5zaG91bGRVbnJlZ2lzdGVyLFxuICAgICAgZmllbGRBcnJheVZhbHVlc1JlZiA9IF9yZWYyNS5maWVsZEFycmF5VmFsdWVzUmVmO1xuXG4gIHZhciBmaWVsZEFycmF5UGFyZW50TmFtZSA9IGdldEZpZWxkQXJyYXlQYXJlbnROYW1lKG5hbWUpO1xuICB2YXIgbWVtb2l6ZWREZWZhdWx0VmFsdWVzID0gdXNlUmVmKF90b0NvbnN1bWFibGVBcnJheShnZXQoZmllbGRBcnJheURlZmF1bHRWYWx1ZXNSZWYuY3VycmVudCwgZmllbGRBcnJheVBhcmVudE5hbWUpID8gZ2V0KGZpZWxkQXJyYXlEZWZhdWx0VmFsdWVzUmVmLmN1cnJlbnQsIG5hbWUsIFtdKSA6IGdldChzaG91bGRVbnJlZ2lzdGVyID8gZGVmYXVsdFZhbHVlc1JlZi5jdXJyZW50IDogc2hhbGxvd0ZpZWxkc1N0YXRlUmVmLmN1cnJlbnQsIG5hbWUsIFtdKSkpO1xuXG4gIHZhciBfdXNlU3RhdGUzID0gdXNlU3RhdGUobWFwSWRzKG1lbW9pemVkRGVmYXVsdFZhbHVlcy5jdXJyZW50LCBrZXlOYW1lKSksXG4gICAgICBfdXNlU3RhdGU0ID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlMywgMiksXG4gICAgICBmaWVsZHMgPSBfdXNlU3RhdGU0WzBdLFxuICAgICAgc2V0RmllbGRzID0gX3VzZVN0YXRlNFsxXTtcblxuICBzZXQoZmllbGRBcnJheVZhbHVlc1JlZi5jdXJyZW50LCBuYW1lLCBmaWVsZHMpO1xuXG4gIHZhciBvbWl0S2V5ID0gZnVuY3Rpb24gb21pdEtleShmaWVsZHMpIHtcbiAgICByZXR1cm4gZmllbGRzLm1hcChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2EgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICB2YXIgX2IgPSBrZXlOYW1lLFxuICAgICAgICAgIG9taXR0ZWQgPSBfYVtfYl0sXG4gICAgICAgICAgcmVzdCA9IF9fcmVzdChfYSwgW3R5cGVvZiBfYiA9PT0gXCJzeW1ib2xcIiA/IF9iIDogX2IgKyBcIlwiXSk7XG5cbiAgICAgIHJldHVybiByZXN0O1xuICAgIH0pO1xuICB9O1xuXG4gIGZpZWxkQXJyYXlOYW1lc1JlZi5jdXJyZW50LmFkZChuYW1lKTtcbiAgdmFyIGdldEZpZWxkQXJyYXlWYWx1ZSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2V0KGZpZWxkQXJyYXlWYWx1ZXNSZWYuY3VycmVudCwgbmFtZSwgW10pO1xuICB9LCBbXSk7XG5cbiAgdmFyIGdldEN1cnJlbnRGaWVsZHNWYWx1ZXMgPSBmdW5jdGlvbiBnZXRDdXJyZW50RmllbGRzVmFsdWVzKCkge1xuICAgIHJldHVybiBnZXQoZ2V0VmFsdWVzKCksIG5hbWUsIGdldEZpZWxkQXJyYXlWYWx1ZSgpKS5tYXAoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBnZXRGaWVsZEFycmF5VmFsdWUoKVtpbmRleF0pLCBpdGVtKTtcbiAgICB9KTtcbiAgfTtcblxuICBmaWVsZEFycmF5TmFtZXNSZWYuY3VycmVudC5hZGQobmFtZSk7XG5cbiAgaWYgKGZpZWxkQXJyYXlQYXJlbnROYW1lICYmICFnZXQoZmllbGRBcnJheURlZmF1bHRWYWx1ZXNSZWYuY3VycmVudCwgZmllbGRBcnJheVBhcmVudE5hbWUpKSB7XG4gICAgc2V0KGZpZWxkQXJyYXlEZWZhdWx0VmFsdWVzUmVmLmN1cnJlbnQsIGZpZWxkQXJyYXlQYXJlbnROYW1lLCBjbG9uZU9iamVjdChnZXQoZGVmYXVsdFZhbHVlc1JlZi5jdXJyZW50LCBmaWVsZEFycmF5UGFyZW50TmFtZSkpKTtcbiAgfVxuXG4gIHZhciBzZXRGaWVsZEFuZFZhbGlkU3RhdGUgPSBmdW5jdGlvbiBzZXRGaWVsZEFuZFZhbGlkU3RhdGUoZmllbGRzVmFsdWVzKSB7XG4gICAgc2V0RmllbGRzKGZpZWxkc1ZhbHVlcyk7XG4gICAgc2V0KGZpZWxkQXJyYXlWYWx1ZXNSZWYuY3VycmVudCwgbmFtZSwgZmllbGRzVmFsdWVzKTtcblxuICAgIGlmIChyZWFkRm9ybVN0YXRlUmVmLmN1cnJlbnQuaXNWYWxpZCAmJiB2YWxpZGF0ZVJlc29sdmVyKSB7XG4gICAgICB2YXIgdmFsdWVzID0gZ2V0VmFsdWVzKCk7XG4gICAgICBzZXQodmFsdWVzLCBuYW1lLCBmaWVsZHNWYWx1ZXMpO1xuICAgICAgdmFsaWRhdGVSZXNvbHZlcih2YWx1ZXMpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcmVzZXRGaWVsZHMgPSBmdW5jdGlvbiByZXNldEZpZWxkcygpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZmllbGRzUmVmLmN1cnJlbnQpIHtcbiAgICAgIGlzTWF0Y2hGaWVsZEFycmF5TmFtZShrZXksIG5hbWUpICYmIHJlbW92ZUZpZWxkRXZlbnRMaXN0ZW5lcihmaWVsZHNSZWYuY3VycmVudFtrZXldLCB0cnVlKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGNsZWFudXAgPSBmdW5jdGlvbiBjbGVhbnVwKHJlZikge1xuICAgIHJldHVybiAhY29tcGFjdChnZXQocmVmLCBuYW1lLCBbXSkpLmxlbmd0aCAmJiB1bnNldChyZWYsIG5hbWUpO1xuICB9O1xuXG4gIHZhciB1cGRhdGVEaXJ0eUZpZWxkc1dpdGhEZWZhdWx0VmFsdWVzID0gZnVuY3Rpb24gdXBkYXRlRGlydHlGaWVsZHNXaXRoRGVmYXVsdFZhbHVlcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcykge1xuICAgIGlmICh1cGRhdGVkRmllbGRBcnJheVZhbHVlcykge1xuICAgICAgc2V0KGZvcm1TdGF0ZVJlZi5jdXJyZW50LmRpcnR5RmllbGRzLCBuYW1lLCBzZXRGaWVsZEFycmF5RGlydHlGaWVsZHMob21pdEtleSh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyksIGdldChkZWZhdWx0VmFsdWVzUmVmLmN1cnJlbnQsIG5hbWUsIFtdKSwgZ2V0KGZvcm1TdGF0ZVJlZi5jdXJyZW50LmRpcnR5RmllbGRzLCBuYW1lLCBbXSkpKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGJhdGNoU3RhdGVVcGRhdGUgPSBmdW5jdGlvbiBiYXRjaFN0YXRlVXBkYXRlKG1ldGhvZCwgYXJncywgdXBkYXRlZEZpZWxkVmFsdWVzKSB7XG4gICAgdmFyIHVwZGF0ZWRGb3JtVmFsdWVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBbXTtcbiAgICB2YXIgc2hvdWxkU2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB0cnVlO1xuICAgIHZhciBzaG91bGRVcGRhdGVWYWxpZCA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogZmFsc2U7XG5cbiAgICBpZiAoZ2V0KHNoYWxsb3dGaWVsZHNTdGF0ZVJlZi5jdXJyZW50LCBuYW1lKSkge1xuICAgICAgdmFyIG91dHB1dCA9IG1ldGhvZChnZXQoc2hhbGxvd0ZpZWxkc1N0YXRlUmVmLmN1cnJlbnQsIG5hbWUpLCBhcmdzLmFyZ0EsIGFyZ3MuYXJnQik7XG4gICAgICBzaG91bGRTZXQgJiYgc2V0KHNoYWxsb3dGaWVsZHNTdGF0ZVJlZi5jdXJyZW50LCBuYW1lLCBvdXRwdXQpO1xuICAgIH1cblxuICAgIGlmIChnZXQoZmllbGRBcnJheURlZmF1bHRWYWx1ZXNSZWYuY3VycmVudCwgbmFtZSkpIHtcbiAgICAgIHZhciBfb3V0cHV0ID0gbWV0aG9kKGdldChmaWVsZEFycmF5RGVmYXVsdFZhbHVlc1JlZi5jdXJyZW50LCBuYW1lKSwgYXJncy5hcmdBLCBhcmdzLmFyZ0IpO1xuXG4gICAgICBzaG91bGRTZXQgJiYgc2V0KGZpZWxkQXJyYXlEZWZhdWx0VmFsdWVzUmVmLmN1cnJlbnQsIG5hbWUsIF9vdXRwdXQpO1xuICAgICAgY2xlYW51cChmaWVsZEFycmF5RGVmYXVsdFZhbHVlc1JlZi5jdXJyZW50KTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShnZXQoZm9ybVN0YXRlUmVmLmN1cnJlbnQuZXJyb3JzLCBuYW1lKSkpIHtcbiAgICAgIHZhciBfb3V0cHV0MiA9IG1ldGhvZChnZXQoZm9ybVN0YXRlUmVmLmN1cnJlbnQuZXJyb3JzLCBuYW1lKSwgYXJncy5hcmdBLCBhcmdzLmFyZ0IpO1xuXG4gICAgICBzaG91bGRTZXQgJiYgc2V0KGZvcm1TdGF0ZVJlZi5jdXJyZW50LmVycm9ycywgbmFtZSwgX291dHB1dDIpO1xuICAgICAgY2xlYW51cChmb3JtU3RhdGVSZWYuY3VycmVudC5lcnJvcnMpO1xuICAgIH1cblxuICAgIGlmIChyZWFkRm9ybVN0YXRlUmVmLmN1cnJlbnQudG91Y2hlZCAmJiBnZXQoZm9ybVN0YXRlUmVmLmN1cnJlbnQudG91Y2hlZCwgbmFtZSkpIHtcbiAgICAgIHZhciBfb3V0cHV0MyA9IG1ldGhvZChnZXQoZm9ybVN0YXRlUmVmLmN1cnJlbnQudG91Y2hlZCwgbmFtZSksIGFyZ3MuYXJnQSwgYXJncy5hcmdCKTtcblxuICAgICAgc2hvdWxkU2V0ICYmIHNldChmb3JtU3RhdGVSZWYuY3VycmVudC50b3VjaGVkLCBuYW1lLCBfb3V0cHV0Myk7XG4gICAgICBjbGVhbnVwKGZvcm1TdGF0ZVJlZi5jdXJyZW50LnRvdWNoZWQpO1xuICAgIH1cblxuICAgIGlmIChyZWFkRm9ybVN0YXRlUmVmLmN1cnJlbnQuZGlydHlGaWVsZHMgfHwgcmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LmlzRGlydHkpIHtcbiAgICAgIHZhciBfb3V0cHV0NCA9IG1ldGhvZChnZXQoZm9ybVN0YXRlUmVmLmN1cnJlbnQuZGlydHlGaWVsZHMsIG5hbWUsIFtdKSwgYXJncy5hcmdDLCBhcmdzLmFyZ0QpO1xuXG4gICAgICBzaG91bGRTZXQgJiYgc2V0KGZvcm1TdGF0ZVJlZi5jdXJyZW50LmRpcnR5RmllbGRzLCBuYW1lLCBfb3V0cHV0NCk7XG4gICAgICB1cGRhdGVEaXJ0eUZpZWxkc1dpdGhEZWZhdWx0VmFsdWVzKHVwZGF0ZWRGaWVsZFZhbHVlcyk7XG4gICAgICBjbGVhbnVwKGZvcm1TdGF0ZVJlZi5jdXJyZW50LmRpcnR5RmllbGRzKTtcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkVXBkYXRlVmFsaWQgJiYgcmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LmlzVmFsaWQgJiYgIXZhbGlkYXRlUmVzb2x2ZXIpIHtcbiAgICAgIHNldCh2YWxpZEZpZWxkc1JlZi5jdXJyZW50LCBuYW1lLCBtZXRob2QoZ2V0KHZhbGlkRmllbGRzUmVmLmN1cnJlbnQsIG5hbWUsIFtdKSwgYXJncy5hcmdBKSk7XG4gICAgICBjbGVhbnVwKHZhbGlkRmllbGRzUmVmLmN1cnJlbnQpO1xuICAgICAgc2V0KGZpZWxkc1dpdGhWYWxpZGF0aW9uUmVmLmN1cnJlbnQsIG5hbWUsIG1ldGhvZChnZXQoZmllbGRzV2l0aFZhbGlkYXRpb25SZWYuY3VycmVudCwgbmFtZSwgW10pLCBhcmdzLmFyZ0EpKTtcbiAgICAgIGNsZWFudXAoZmllbGRzV2l0aFZhbGlkYXRpb25SZWYuY3VycmVudCk7XG4gICAgfVxuXG4gICAgdXBkYXRlRm9ybVN0YXRlKHtcbiAgICAgIGlzRGlydHk6IGlzRm9ybURpcnR5KG5hbWUsIG9taXRLZXkodXBkYXRlZEZvcm1WYWx1ZXMpKVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBhcHBlbmQgPSBmdW5jdGlvbiBhcHBlbmQodmFsdWUpIHtcbiAgICB2YXIgc2hvdWxkRm9jdXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgdmFyIHVwZGF0ZUZvcm1WYWx1ZXMgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGdldEN1cnJlbnRGaWVsZHNWYWx1ZXMoKSksIF90b0NvbnN1bWFibGVBcnJheShtYXBJZHMoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV0sIGtleU5hbWUpKSk7XG4gICAgc2V0RmllbGRBbmRWYWxpZFN0YXRlKHVwZGF0ZUZvcm1WYWx1ZXMpO1xuXG4gICAgaWYgKHJlYWRGb3JtU3RhdGVSZWYuY3VycmVudC5kaXJ0eUZpZWxkcyB8fCByZWFkRm9ybVN0YXRlUmVmLmN1cnJlbnQuaXNEaXJ0eSkge1xuICAgICAgdXBkYXRlRGlydHlGaWVsZHNXaXRoRGVmYXVsdFZhbHVlcyh1cGRhdGVGb3JtVmFsdWVzKTtcbiAgICAgIHVwZGF0ZUZvcm1TdGF0ZSh7XG4gICAgICAgIGlzRGlydHk6IHRydWUsXG4gICAgICAgIGRpcnR5RmllbGRzOiBmb3JtU3RhdGVSZWYuY3VycmVudC5kaXJ0eUZpZWxkc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgIXNob3VsZFVucmVnaXN0ZXIgJiYgc2V0KHNoYWxsb3dGaWVsZHNTdGF0ZVJlZi5jdXJyZW50LCBuYW1lLCBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGdldChzaGFsbG93RmllbGRzU3RhdGVSZWYuY3VycmVudCwgbmFtZSkgfHwgW10pLCBbdmFsdWVdKSk7XG4gICAgZm9jdXNJbmRleFJlZi5jdXJyZW50ID0gc2hvdWxkRm9jdXMgPyBmaWVsZHMubGVuZ3RoIDogLTE7XG4gIH07XG5cbiAgdmFyIHByZXBlbmQkMSA9IGZ1bmN0aW9uIHByZXBlbmQkMSh2YWx1ZSkge1xuICAgIHZhciBzaG91bGRGb2N1cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICB2YXIgZW1wdHlBcnJheSA9IGZpbGxFbXB0eUFycmF5KHZhbHVlKTtcbiAgICB2YXIgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMgPSBwcmVwZW5kKGdldEN1cnJlbnRGaWVsZHNWYWx1ZXMoKSwgbWFwSWRzKEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdLCBrZXlOYW1lKSk7XG4gICAgc2V0RmllbGRBbmRWYWxpZFN0YXRlKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICByZXNldEZpZWxkcygpO1xuICAgIGJhdGNoU3RhdGVVcGRhdGUocHJlcGVuZCwge1xuICAgICAgYXJnQTogZW1wdHlBcnJheSxcbiAgICAgIGFyZ0M6IGZpbGxCb29sZWFuQXJyYXkodmFsdWUpXG4gICAgfSwgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMpO1xuICAgIGZvY3VzSW5kZXhSZWYuY3VycmVudCA9IHNob3VsZEZvY3VzID8gMCA6IC0xO1xuICB9O1xuXG4gIHZhciByZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoaW5kZXgpIHtcbiAgICB2YXIgZmllbGRWYWx1ZXMgPSBnZXRDdXJyZW50RmllbGRzVmFsdWVzKCk7XG4gICAgdmFyIHVwZGF0ZWRGaWVsZFZhbHVlcyA9IHJlbW92ZUFycmF5QXQoZmllbGRWYWx1ZXMsIGluZGV4KTtcbiAgICBzZXRGaWVsZEFuZFZhbGlkU3RhdGUodXBkYXRlZEZpZWxkVmFsdWVzKTtcbiAgICByZXNldEZpZWxkcygpO1xuICAgIGJhdGNoU3RhdGVVcGRhdGUocmVtb3ZlQXJyYXlBdCwge1xuICAgICAgYXJnQTogaW5kZXgsXG4gICAgICBhcmdDOiBpbmRleFxuICAgIH0sIHVwZGF0ZWRGaWVsZFZhbHVlcywgcmVtb3ZlQXJyYXlBdChmaWVsZFZhbHVlcywgaW5kZXgpLCB0cnVlLCB0cnVlKTtcbiAgfTtcblxuICB2YXIgaW5zZXJ0JDEgPSBmdW5jdGlvbiBpbnNlcnQkMShpbmRleCwgdmFsdWUpIHtcbiAgICB2YXIgc2hvdWxkRm9jdXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG4gICAgdmFyIGVtcHR5QXJyYXkgPSBmaWxsRW1wdHlBcnJheSh2YWx1ZSk7XG4gICAgdmFyIGZpZWxkVmFsdWVzID0gZ2V0Q3VycmVudEZpZWxkc1ZhbHVlcygpO1xuICAgIHZhciB1cGRhdGVkRmllbGRBcnJheVZhbHVlcyA9IGluc2VydChmaWVsZFZhbHVlcywgaW5kZXgsIG1hcElkcyhBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXSwga2V5TmFtZSkpO1xuICAgIHNldEZpZWxkQW5kVmFsaWRTdGF0ZSh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgcmVzZXRGaWVsZHMoKTtcbiAgICBiYXRjaFN0YXRlVXBkYXRlKGluc2VydCwge1xuICAgICAgYXJnQTogaW5kZXgsXG4gICAgICBhcmdCOiBlbXB0eUFycmF5LFxuICAgICAgYXJnQzogaW5kZXgsXG4gICAgICBhcmdEOiBmaWxsQm9vbGVhbkFycmF5KHZhbHVlKVxuICAgIH0sIHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzLCBpbnNlcnQoZmllbGRWYWx1ZXMsIGluZGV4KSk7XG4gICAgZm9jdXNJbmRleFJlZi5jdXJyZW50ID0gc2hvdWxkRm9jdXMgPyBpbmRleCA6IC0xO1xuICB9O1xuXG4gIHZhciBzd2FwID0gZnVuY3Rpb24gc3dhcChpbmRleEEsIGluZGV4Qikge1xuICAgIHZhciBmaWVsZFZhbHVlcyA9IGdldEN1cnJlbnRGaWVsZHNWYWx1ZXMoKTtcbiAgICBzd2FwQXJyYXlBdChmaWVsZFZhbHVlcywgaW5kZXhBLCBpbmRleEIpO1xuICAgIHJlc2V0RmllbGRzKCk7XG4gICAgc2V0RmllbGRBbmRWYWxpZFN0YXRlKF90b0NvbnN1bWFibGVBcnJheShmaWVsZFZhbHVlcykpO1xuICAgIGJhdGNoU3RhdGVVcGRhdGUoc3dhcEFycmF5QXQsIHtcbiAgICAgIGFyZ0E6IGluZGV4QSxcbiAgICAgIGFyZ0I6IGluZGV4QixcbiAgICAgIGFyZ0M6IGluZGV4QSxcbiAgICAgIGFyZ0Q6IGluZGV4QlxuICAgIH0sIHVuZGVmaW5lZCwgZmllbGRWYWx1ZXMsIGZhbHNlKTtcbiAgfTtcblxuICB2YXIgbW92ZSA9IGZ1bmN0aW9uIG1vdmUoZnJvbSwgdG8pIHtcbiAgICB2YXIgZmllbGRWYWx1ZXMgPSBnZXRDdXJyZW50RmllbGRzVmFsdWVzKCk7XG4gICAgbW92ZUFycmF5QXQoZmllbGRWYWx1ZXMsIGZyb20sIHRvKTtcbiAgICByZXNldEZpZWxkcygpO1xuICAgIHNldEZpZWxkQW5kVmFsaWRTdGF0ZShfdG9Db25zdW1hYmxlQXJyYXkoZmllbGRWYWx1ZXMpKTtcbiAgICBiYXRjaFN0YXRlVXBkYXRlKG1vdmVBcnJheUF0LCB7XG4gICAgICBhcmdBOiBmcm9tLFxuICAgICAgYXJnQjogdG8sXG4gICAgICBhcmdDOiBmcm9tLFxuICAgICAgYXJnRDogdG9cbiAgICB9LCB1bmRlZmluZWQsIGZpZWxkVmFsdWVzLCBmYWxzZSk7XG4gIH07XG5cbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybign8J+TiyB1c2VGaWVsZEFycmF5IGlzIG1pc3NpbmcgYG5hbWVgIGF0dHJpYnV0ZS4gaHR0cHM6Ly9yZWFjdC1ob29rLWZvcm0uY29tL2FwaSN1c2VGaWVsZEFycmF5Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRWYWx1ZXMgPSBnZXQoZmllbGRBcnJheURlZmF1bHRWYWx1ZXNSZWYuY3VycmVudCwgbmFtZSk7XG5cbiAgICBpZiAoZGVmYXVsdFZhbHVlcyAmJiBmaWVsZHMubGVuZ3RoIDwgZGVmYXVsdFZhbHVlcy5sZW5ndGgpIHtcbiAgICAgIGRlZmF1bHRWYWx1ZXMucG9wKCk7XG4gICAgICBzZXQoZmllbGRBcnJheURlZmF1bHRWYWx1ZXNSZWYuY3VycmVudCwgbmFtZSwgZGVmYXVsdFZhbHVlcyk7XG4gICAgfVxuXG4gICAgdXBkYXRlV2F0Y2hlZFZhbHVlKG5hbWUpO1xuXG4gICAgaWYgKGZvY3VzSW5kZXhSZWYuY3VycmVudCA+IC0xKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gZmllbGRzUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgdmFyIGZpZWxkID0gZmllbGRzUmVmLmN1cnJlbnRba2V5XTtcblxuICAgICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoXCJcIi5jb25jYXQobmFtZSwgXCJbXCIpLmNvbmNhdChmb2N1c0luZGV4UmVmLmN1cnJlbnQsIFwiXVwiKSkgJiYgZmllbGQucmVmLmZvY3VzKSB7XG4gICAgICAgICAgZmllbGQucmVmLmZvY3VzKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb2N1c0luZGV4UmVmLmN1cnJlbnQgPSAtMTtcbiAgfSwgW2ZpZWxkcywgbmFtZV0pO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXNldEZ1bmN0aW9ucyA9IHJlc2V0RmllbGRBcnJheUZ1bmN0aW9uUmVmLmN1cnJlbnQ7XG4gICAgdmFyIGZpZWxkQXJyYXlOYW1lcyA9IGZpZWxkQXJyYXlOYW1lc1JlZi5jdXJyZW50O1xuXG4gICAgaWYgKCFnZXRGaWVsZEFycmF5UGFyZW50TmFtZShuYW1lKSkge1xuICAgICAgcmVzZXRGdW5jdGlvbnNbbmFtZV0gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXNldEZpZWxkcygpO1xuICAgICAgICAhZGF0YSAmJiB1bnNldChmaWVsZEFycmF5RGVmYXVsdFZhbHVlc1JlZi5jdXJyZW50LCBuYW1lKTtcbiAgICAgICAgdW5zZXQoc2hhbGxvd0ZpZWxkc1N0YXRlUmVmLmN1cnJlbnQsIG5hbWUpO1xuICAgICAgICBtZW1vaXplZERlZmF1bHRWYWx1ZXMuY3VycmVudCA9IGdldChkYXRhIHx8IGRlZmF1bHRWYWx1ZXNSZWYuY3VycmVudCwgbmFtZSk7XG4gICAgICAgIHNldEZpZWxkcyhtYXBJZHMobWVtb2l6ZWREZWZhdWx0VmFsdWVzLmN1cnJlbnQsIGtleU5hbWUpKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVzZXRGaWVsZHMoKTtcbiAgICAgIGRlbGV0ZSByZXNldEZ1bmN0aW9uc1tuYW1lXTtcbiAgICAgIHVuc2V0KGZpZWxkQXJyYXlWYWx1ZXNSZWYsIG5hbWUpO1xuICAgICAgZmllbGRBcnJheU5hbWVzLmRlbGV0ZShuYW1lKTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIHJldHVybiB7XG4gICAgc3dhcDogdXNlQ2FsbGJhY2soc3dhcCwgW25hbWVdKSxcbiAgICBtb3ZlOiB1c2VDYWxsYmFjayhtb3ZlLCBbbmFtZV0pLFxuICAgIHByZXBlbmQ6IHVzZUNhbGxiYWNrKHByZXBlbmQkMSwgW25hbWVdKSxcbiAgICBhcHBlbmQ6IHVzZUNhbGxiYWNrKGFwcGVuZCwgW25hbWUsIGZpZWxkc10pLFxuICAgIHJlbW92ZTogdXNlQ2FsbGJhY2socmVtb3ZlLCBbbmFtZV0pLFxuICAgIGluc2VydDogdXNlQ2FsbGJhY2soaW5zZXJ0JDEsIFtuYW1lXSksXG4gICAgZmllbGRzOiBmaWVsZHNcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIHVzZVdhdGNoKF9yZWYyNikge1xuICB2YXIgY29udHJvbCA9IF9yZWYyNi5jb250cm9sLFxuICAgICAgbmFtZSA9IF9yZWYyNi5uYW1lLFxuICAgICAgZGVmYXVsdFZhbHVlID0gX3JlZjI2LmRlZmF1bHRWYWx1ZTtcbiAgdmFyIG1ldGhvZHMgPSB1c2VGb3JtQ29udGV4dCgpO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKCFjb250cm9sICYmICFtZXRob2RzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ/Cfk4sgdXNlV2F0Y2ggaXMgbWlzc2luZyBgY29udHJvbGAgcHJvcC4gaHR0cHM6Ly9yZWFjdC1ob29rLWZvcm0uY29tL2FwaSN1c2VXYXRjaCcpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBfcmVmMjcgPSBjb250cm9sIHx8IG1ldGhvZHMuY29udHJvbCxcbiAgICAgIHVzZVdhdGNoRmllbGRzUmVmID0gX3JlZjI3LnVzZVdhdGNoRmllbGRzUmVmLFxuICAgICAgdXNlV2F0Y2hSZW5kZXJGdW5jdGlvbnNSZWYgPSBfcmVmMjcudXNlV2F0Y2hSZW5kZXJGdW5jdGlvbnNSZWYsXG4gICAgICB3YXRjaEludGVybmFsID0gX3JlZjI3LndhdGNoSW50ZXJuYWwsXG4gICAgICBkZWZhdWx0VmFsdWVzUmVmID0gX3JlZjI3LmRlZmF1bHRWYWx1ZXNSZWY7XG5cbiAgdmFyIHVwZGF0ZVZhbHVlID0gdXNlU3RhdGUoKVsxXTtcbiAgdmFyIGlkUmVmID0gdXNlUmVmKCk7XG4gIHZhciBkZWZhdWx0VmFsdWVSZWYgPSB1c2VSZWYoZGVmYXVsdFZhbHVlKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKG5hbWUgPT09ICcnKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybign8J+TiyB1c2VXYXRjaCBpcyBtaXNzaW5nIGBuYW1lYCBhdHRyaWJ1dGUuIGh0dHBzOi8vcmVhY3QtaG9vay1mb3JtLmNvbS9hcGkjdXNlV2F0Y2gnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaWQgPSBpZFJlZi5jdXJyZW50ID0gZ2VuZXJhdGVJZCgpO1xuICAgIHZhciB3YXRjaEZpZWxkc0hvb2tSZW5kZXIgPSB1c2VXYXRjaFJlbmRlckZ1bmN0aW9uc1JlZi5jdXJyZW50O1xuICAgIHZhciB3YXRjaEZpZWxkc0hvb2sgPSB1c2VXYXRjaEZpZWxkc1JlZi5jdXJyZW50O1xuICAgIHdhdGNoRmllbGRzSG9va1tpZF0gPSBuZXcgU2V0KCk7XG5cbiAgICB3YXRjaEZpZWxkc0hvb2tSZW5kZXJbaWRdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHVwZGF0ZVZhbHVlKHt9KTtcbiAgICB9O1xuXG4gICAgd2F0Y2hJbnRlcm5hbChuYW1lLCBkZWZhdWx0VmFsdWVSZWYuY3VycmVudCwgaWQpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBkZWxldGUgd2F0Y2hGaWVsZHNIb29rW2lkXTtcbiAgICAgIGRlbGV0ZSB3YXRjaEZpZWxkc0hvb2tSZW5kZXJbaWRdO1xuICAgIH07XG4gIH0sIFtuYW1lLCB1c2VXYXRjaFJlbmRlckZ1bmN0aW9uc1JlZiwgdXNlV2F0Y2hGaWVsZHNSZWYsIHdhdGNoSW50ZXJuYWwsIGRlZmF1bHRWYWx1ZVJlZl0pO1xuICByZXR1cm4gaWRSZWYuY3VycmVudCA/IHdhdGNoSW50ZXJuYWwobmFtZSwgZGVmYXVsdFZhbHVlUmVmLmN1cnJlbnQsIGlkUmVmLmN1cnJlbnQpIDogaXNVbmRlZmluZWQoZGVmYXVsdFZhbHVlKSA/IGlzU3RyaW5nKG5hbWUpID8gZ2V0KGRlZmF1bHRWYWx1ZXNSZWYuY3VycmVudCwgbmFtZSkgOiBBcnJheS5pc0FycmF5KG5hbWUpID8gbmFtZS5yZWR1Y2UoZnVuY3Rpb24gKHByZXZpb3VzLCBpbnB1dE5hbWUpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcmV2aW91cyksIF9kZWZpbmVQcm9wZXJ0eSh7fSwgaW5wdXROYW1lLCBnZXQoZGVmYXVsdFZhbHVlc1JlZi5jdXJyZW50LCBpbnB1dE5hbWUpKSk7XG4gIH0sIHt9KSA6IGRlZmF1bHRWYWx1ZXNSZWYuY3VycmVudCA6IGRlZmF1bHRWYWx1ZTtcbn1cblxudmFyIGdldElucHV0VmFsdWUgPSBmdW5jdGlvbiBnZXRJbnB1dFZhbHVlKGV2ZW50KSB7XG4gIHJldHVybiBpc1ByaW1pdGl2ZShldmVudCkgfHwgIWlzT2JqZWN0KGV2ZW50LnRhcmdldCkgfHwgaXNPYmplY3QoZXZlbnQudGFyZ2V0KSAmJiAhZXZlbnQudHlwZSA/IGV2ZW50IDogaXNVbmRlZmluZWQoZXZlbnQudGFyZ2V0LnZhbHVlKSA/IGV2ZW50LnRhcmdldC5jaGVja2VkIDogZXZlbnQudGFyZ2V0LnZhbHVlO1xufTtcblxuZnVuY3Rpb24gdXNlRmllbGQoX3JlZjI4KSB7XG4gIHZhciBuYW1lID0gX3JlZjI4Lm5hbWUsXG4gICAgICBydWxlcyA9IF9yZWYyOC5ydWxlcyxcbiAgICAgIGRlZmF1bHRWYWx1ZSA9IF9yZWYyOC5kZWZhdWx0VmFsdWUsXG4gICAgICBjb250cm9sID0gX3JlZjI4LmNvbnRyb2wsXG4gICAgICBvbkZvY3VzID0gX3JlZjI4Lm9uRm9jdXM7XG4gIHZhciBtZXRob2RzID0gdXNlRm9ybUNvbnRleHQoKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmICghY29udHJvbCAmJiAhbWV0aG9kcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCfwn5OLIENvbnRyb2xsZXIgaXMgbWlzc2luZyBgY29udHJvbGAgcHJvcC4gaHR0cHM6Ly9yZWFjdC1ob29rLWZvcm0uY29tL2FwaSNDb250cm9sbGVyJyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIF9yZWYyOSA9IGNvbnRyb2wgfHwgbWV0aG9kcy5jb250cm9sLFxuICAgICAgZGVmYXVsdFZhbHVlc1JlZiA9IF9yZWYyOS5kZWZhdWx0VmFsdWVzUmVmLFxuICAgICAgc2V0VmFsdWUgPSBfcmVmMjkuc2V0VmFsdWUsXG4gICAgICByZWdpc3RlciA9IF9yZWYyOS5yZWdpc3RlcixcbiAgICAgIHVucmVnaXN0ZXIgPSBfcmVmMjkudW5yZWdpc3RlcixcbiAgICAgIHRyaWdnZXIgPSBfcmVmMjkudHJpZ2dlcixcbiAgICAgIG1vZGUgPSBfcmVmMjkubW9kZSxcbiAgICAgIF9yZWYyOSRyZVZhbGlkYXRlTW9kZSA9IF9yZWYyOS5yZVZhbGlkYXRlTW9kZSxcbiAgICAgIGlzUmVWYWxpZGF0ZU9uQmx1ciA9IF9yZWYyOSRyZVZhbGlkYXRlTW9kZS5pc1JlVmFsaWRhdGVPbkJsdXIsXG4gICAgICBpc1JlVmFsaWRhdGVPbkNoYW5nZSA9IF9yZWYyOSRyZVZhbGlkYXRlTW9kZS5pc1JlVmFsaWRhdGVPbkNoYW5nZSxcbiAgICAgIF9yZWYyOSRmb3JtU3RhdGVSZWYkYyA9IF9yZWYyOS5mb3JtU3RhdGVSZWYuY3VycmVudCxcbiAgICAgIGlzU3VibWl0dGVkID0gX3JlZjI5JGZvcm1TdGF0ZVJlZiRjLmlzU3VibWl0dGVkLFxuICAgICAgdG91Y2hlZCA9IF9yZWYyOSRmb3JtU3RhdGVSZWYkYy50b3VjaGVkLFxuICAgICAgZXJyb3JzID0gX3JlZjI5JGZvcm1TdGF0ZVJlZiRjLmVycm9ycyxcbiAgICAgIGRpcnR5RmllbGRzID0gX3JlZjI5JGZvcm1TdGF0ZVJlZiRjLmRpcnR5RmllbGRzLFxuICAgICAgdXBkYXRlRm9ybVN0YXRlID0gX3JlZjI5LnVwZGF0ZUZvcm1TdGF0ZSxcbiAgICAgIHJlYWRGb3JtU3RhdGVSZWYgPSBfcmVmMjkucmVhZEZvcm1TdGF0ZVJlZixcbiAgICAgIGZpZWxkc1JlZiA9IF9yZWYyOS5maWVsZHNSZWYsXG4gICAgICBmaWVsZEFycmF5TmFtZXNSZWYgPSBfcmVmMjkuZmllbGRBcnJheU5hbWVzUmVmLFxuICAgICAgc2hhbGxvd0ZpZWxkc1N0YXRlUmVmID0gX3JlZjI5LnNoYWxsb3dGaWVsZHNTdGF0ZVJlZjtcblxuICB2YXIgaXNOb3RGaWVsZEFycmF5ID0gIWlzTmFtZUluRmllbGRBcnJheShmaWVsZEFycmF5TmFtZXNSZWYuY3VycmVudCwgbmFtZSk7XG5cbiAgdmFyIGdldEluaXRpYWxWYWx1ZSA9IGZ1bmN0aW9uIGdldEluaXRpYWxWYWx1ZSgpIHtcbiAgICByZXR1cm4gIWlzVW5kZWZpbmVkKGdldChzaGFsbG93RmllbGRzU3RhdGVSZWYuY3VycmVudCwgbmFtZSkpICYmIGlzTm90RmllbGRBcnJheSA/IGdldChzaGFsbG93RmllbGRzU3RhdGVSZWYuY3VycmVudCwgbmFtZSkgOiBpc1VuZGVmaW5lZChkZWZhdWx0VmFsdWUpID8gZ2V0KGRlZmF1bHRWYWx1ZXNSZWYuY3VycmVudCwgbmFtZSkgOiBkZWZhdWx0VmFsdWU7XG4gIH07XG5cbiAgdmFyIF91c2VTdGF0ZTUgPSB1c2VTdGF0ZShnZXRJbml0aWFsVmFsdWUoKSksXG4gICAgICBfdXNlU3RhdGU2ID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlNSwgMiksXG4gICAgICB2YWx1ZSA9IF91c2VTdGF0ZTZbMF0sXG4gICAgICBzZXRJbnB1dFN0YXRlVmFsdWUgPSBfdXNlU3RhdGU2WzFdO1xuXG4gIHZhciB2YWx1ZVJlZiA9IHVzZVJlZih2YWx1ZSk7XG4gIHZhciByZWYgPSB1c2VSZWYoe1xuICAgIGZvY3VzOiBmdW5jdGlvbiBmb2N1cygpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSk7XG4gIHZhciBvbkZvY3VzUmVmID0gdXNlUmVmKG9uRm9jdXMgfHwgZnVuY3Rpb24gKCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHJlZi5jdXJyZW50LmZvY3VzKSkge1xuICAgICAgcmVmLmN1cnJlbnQuZm9jdXMoKTtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCFpc0Z1bmN0aW9uKHJlZi5jdXJyZW50LmZvY3VzKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJcXHVEODNEXFx1RENDQiAncmVmJyBmcm9tIENvbnRyb2xsZXIgcmVuZGVyIHByb3AgbXVzdCBiZSBhdHRhY2hlZCB0byBhIFJlYWN0IGNvbXBvbmVudCBvciBhIERPTSBFbGVtZW50IHdob3NlIHJlZiBwcm92aWRlcyBhICdmb2N1cygpJyBtZXRob2RcIik7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgdmFyIHNob3VsZFZhbGlkYXRlID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKGlzQmx1ckV2ZW50KSB7XG4gICAgcmV0dXJuICFza2lwVmFsaWRhdGlvbihPYmplY3QuYXNzaWduKHtcbiAgICAgIGlzQmx1ckV2ZW50OiBpc0JsdXJFdmVudCxcbiAgICAgIGlzUmVWYWxpZGF0ZU9uQmx1cjogaXNSZVZhbGlkYXRlT25CbHVyLFxuICAgICAgaXNSZVZhbGlkYXRlT25DaGFuZ2U6IGlzUmVWYWxpZGF0ZU9uQ2hhbmdlLFxuICAgICAgaXNTdWJtaXR0ZWQ6IGlzU3VibWl0dGVkLFxuICAgICAgaXNUb3VjaGVkOiAhIWdldCh0b3VjaGVkLCBuYW1lKVxuICAgIH0sIG1vZGUpKTtcbiAgfSwgW2lzUmVWYWxpZGF0ZU9uQmx1ciwgaXNSZVZhbGlkYXRlT25DaGFuZ2UsIGlzU3VibWl0dGVkLCB0b3VjaGVkLCBuYW1lLCBtb2RlXSk7XG4gIHZhciBjb21tb25UYXNrID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKF9yZWYzMCkge1xuICAgIHZhciBfcmVmMzEgPSBfc2xpY2VkVG9BcnJheShfcmVmMzAsIDEpLFxuICAgICAgICBldmVudCA9IF9yZWYzMVswXTtcblxuICAgIHZhciBkYXRhID0gZ2V0SW5wdXRWYWx1ZShldmVudCk7XG4gICAgc2V0SW5wdXRTdGF0ZVZhbHVlKGRhdGEpO1xuICAgIHZhbHVlUmVmLmN1cnJlbnQgPSBkYXRhO1xuICAgIHJldHVybiBkYXRhO1xuICB9LCBbXSk7XG4gIHZhciByZWdpc3RlckZpZWxkID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKHNob3VsZFVwZGF0ZVZhbHVlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghbmFtZSkge1xuICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCfwn5OLIEZpZWxkIGlzIG1pc3NpbmcgYG5hbWVgIHByb3AuIGh0dHBzOi8vcmVhY3QtaG9vay1mb3JtLmNvbS9hcGkjQ29udHJvbGxlcicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmaWVsZHNSZWYuY3VycmVudFtuYW1lXSkge1xuICAgICAgZmllbGRzUmVmLmN1cnJlbnRbbmFtZV0gPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgcmVmOiBmaWVsZHNSZWYuY3VycmVudFtuYW1lXS5yZWZcbiAgICAgIH0sIHJ1bGVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVnaXN0ZXIoT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgZm9jdXM6IG9uRm9jdXNSZWYuY3VycmVudFxuICAgICAgfSwgJ3ZhbHVlJywge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChkYXRhKSB7XG4gICAgICAgICAgc2V0SW5wdXRTdGF0ZVZhbHVlKGRhdGEpO1xuICAgICAgICAgIHZhbHVlUmVmLmN1cnJlbnQgPSBkYXRhO1xuICAgICAgICB9LFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWVSZWYuY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgfSksIHJ1bGVzKTtcbiAgICAgIHNob3VsZFVwZGF0ZVZhbHVlID0gaXNVbmRlZmluZWQoZ2V0KGRlZmF1bHRWYWx1ZXNSZWYuY3VycmVudCwgbmFtZSkpO1xuICAgIH1cblxuICAgIHNob3VsZFVwZGF0ZVZhbHVlICYmIGlzTm90RmllbGRBcnJheSAmJiBzZXRJbnB1dFN0YXRlVmFsdWUoZ2V0SW5pdGlhbFZhbHVlKCkpO1xuICB9LCBbcnVsZXMsIG5hbWUsIHJlZ2lzdGVyXSk7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB1bnJlZ2lzdGVyKG5hbWUpO1xuICAgIH07XG4gIH0sIFtuYW1lXSk7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiXFx1RDgzRFxcdURDQ0IgXCIuY29uY2F0KG5hbWUsIFwiIGlzIG1pc3NpbmcgaW4gdGhlICdkZWZhdWx0VmFsdWUnIHByb3Agb2YgZWl0aGVyIGl0cyBDb250cm9sbGVyIChodHRwczovL3JlYWN0LWhvb2stZm9ybS5jb20vYXBpI0NvbnRyb2xsZXIpIG9yIHVzZUZvcm0gKGh0dHBzOi8vcmVhY3QtaG9vay1mb3JtLmNvbS9hcGkjdXNlRm9ybSlcIikpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTm90RmllbGRBcnJheSAmJiBpc1VuZGVmaW5lZChkZWZhdWx0VmFsdWUpKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybign8J+TiyBDb250cm9sbGVyIGlzIG1pc3NpbmcgYGRlZmF1bHRWYWx1ZWAgcHJvcCB3aGVuIHVzaW5nIGB1c2VGaWVsZEFycmF5YC4gaHR0cHM6Ly9yZWFjdC1ob29rLWZvcm0uY29tL2FwaSNDb250cm9sbGVyJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJGaWVsZCgpO1xuICB9LCBbcmVnaXN0ZXJGaWVsZF0pO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICFmaWVsZHNSZWYuY3VycmVudFtuYW1lXSAmJiByZWdpc3RlckZpZWxkKHRydWUpO1xuICB9KTtcbiAgdmFyIG9uQmx1ciA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LnRvdWNoZWQgJiYgIWdldCh0b3VjaGVkLCBuYW1lKSkge1xuICAgICAgc2V0KHRvdWNoZWQsIG5hbWUsIHRydWUpO1xuICAgICAgdXBkYXRlRm9ybVN0YXRlKHtcbiAgICAgICAgdG91Y2hlZDogdG91Y2hlZFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgc2hvdWxkVmFsaWRhdGUodHJ1ZSkgJiYgdHJpZ2dlcihuYW1lKTtcbiAgfSwgW25hbWUsIHVwZGF0ZUZvcm1TdGF0ZSwgc2hvdWxkVmFsaWRhdGUsIHRyaWdnZXIsIHJlYWRGb3JtU3RhdGVSZWZdKTtcbiAgdmFyIG9uQ2hhbmdlID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBldmVudCA9IG5ldyBBcnJheShfbGVuKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW47IF9rZXkyKyspIHtcbiAgICAgIGV2ZW50W19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgcmV0dXJuIHNldFZhbHVlKG5hbWUsIGNvbW1vblRhc2soZXZlbnQpLCB7XG4gICAgICBzaG91bGRWYWxpZGF0ZTogc2hvdWxkVmFsaWRhdGUoKSxcbiAgICAgIHNob3VsZERpcnR5OiB0cnVlXG4gICAgfSk7XG4gIH0sIFtzZXRWYWx1ZSwgbmFtZSwgc2hvdWxkVmFsaWRhdGVdKTtcbiAgcmV0dXJuIHtcbiAgICBmaWVsZDoge1xuICAgICAgb25DaGFuZ2U6IG9uQ2hhbmdlLFxuICAgICAgb25CbHVyOiBvbkJsdXIsXG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgcmVmOiByZWZcbiAgICB9LFxuICAgIHN0YXRlOiB7XG4gICAgICBpblZhbGlkOiAhZ2V0KGVycm9ycywgbmFtZSksXG4gICAgICBpc0RpcnR5OiAhIWdldChkaXJ0eUZpZWxkcywgbmFtZSksXG4gICAgICBpc1RvdWNoZWQ6ICEhZ2V0KHRvdWNoZWQsIG5hbWUpXG4gICAgfVxuICB9O1xufVxuXG52YXIgQ29udHJvbGxlciA9IGZ1bmN0aW9uIENvbnRyb2xsZXIocHJvcHMpIHtcbiAgdmFyIHJ1bGVzID0gcHJvcHMucnVsZXMsXG4gICAgICBhcyA9IHByb3BzLmFzLFxuICAgICAgcmVuZGVyID0gcHJvcHMucmVuZGVyLFxuICAgICAgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlLFxuICAgICAgY29udHJvbCA9IHByb3BzLmNvbnRyb2wsXG4gICAgICBvbkZvY3VzID0gcHJvcHMub25Gb2N1cyxcbiAgICAgIHJlc3QgPSBfX3Jlc3QocHJvcHMsIFtcInJ1bGVzXCIsIFwiYXNcIiwgXCJyZW5kZXJcIiwgXCJkZWZhdWx0VmFsdWVcIiwgXCJjb250cm9sXCIsIFwib25Gb2N1c1wiXSk7XG5cbiAgdmFyIF91c2VGaWVsZCA9IHVzZUZpZWxkKHByb3BzKSxcbiAgICAgIGZpZWxkID0gX3VzZUZpZWxkLmZpZWxkO1xuXG4gIHZhciBjb21wb25lbnRQcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVzdCksIGZpZWxkKTtcbiAgcmV0dXJuIGFzID8gaXNWYWxpZEVsZW1lbnQoYXMpID8gY2xvbmVFbGVtZW50KGFzLCBjb21wb25lbnRQcm9wcykgOiBjcmVhdGVFbGVtZW50KGFzLCBjb21wb25lbnRQcm9wcykgOiByZW5kZXIgPyByZW5kZXIoZmllbGQpIDogbnVsbDtcbn07XG5cbmV4cG9ydCB7IENvbnRyb2xsZXIsIEZvcm1Qcm92aWRlciwgYXBwZW5kRXJyb3JzLCBnZXQsIHRyYW5zZm9ybVRvTmVzdE9iamVjdCwgdXNlRmllbGRBcnJheSwgdXNlRm9ybSwgdXNlRm9ybUNvbnRleHQsIHVzZVdhdGNoIH07IiwiaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCB9IGZyb20gXCJyZWFjdFwiXG5pbXBvcnQgeyB1c2VGb3JtLCBDb250cm9sbGVyIH0gZnJvbSBcInJlYWN0LWhvb2stZm9ybVwiXG5pbXBvcnQgeyBMaW5rLCBuYXZpZ2F0ZSB9IGZyb20gXCJnYXRzYnlcIlxuaW1wb3J0IENsZWF2ZSBmcm9tIFwiY2xlYXZlLmpzL3JlYWN0XCJcbmltcG9ydCBMYXlvdXQgZnJvbSBcInNyYy9jb21wb25lbnRzL0xheW91dFwiXG5pbXBvcnQgQWxlcnQgZnJvbSBcInNyYy9jb21wb25lbnRzL0FsZXJ0XCJcbmltcG9ydCBQcml2YXRlUm91dGUgZnJvbSBcInNyYy9jb21wb25lbnRzL1ByaXZhdGVSb3V0ZVwiXG5pbXBvcnQge1xuICB1c2VVc2VyRGF0YSxcbiAgdXNlTXV0VXNlckRhdGEsXG4gIHVzZVVzZXJKb2luZWQsXG4gIHVzZVVzZXJTaWdudXAsXG4gIHVzZU11dFVzZXJTaWdudXAsXG4gIHVzZVRvdXJuZXksXG59IGZyb20gXCJzcmMvYXBwL2hvb2tzXCJcblxuY29uc3QgU2lnbnVwID0gKHsgbG9jYXRpb24gfSkgPT4ge1xuICBjb25zdCBmb3JtID0gdXNlRm9ybSh7IG1vZGU6IFwib25Ub3VjaGVkXCIgfSlcbiAgY29uc3QgdG91cm5leVF1ZXJ5ID0gdXNlVG91cm5leSgpXG4gIGNvbnN0IHVzZXJTaWdudXBNdXQgPSB1c2VNdXRVc2VyU2lnbnVwKClcbiAgY29uc3QgdXNlckRhdGFNdXQgPSB1c2VNdXRVc2VyRGF0YSgpXG4gIGNvbnN0IHVzZXJKb2luZWRRdWVyeSA9IHVzZVVzZXJKb2luZWQoKVxuXG4gIC8vIFByZXBvcHVsYXRlIGRhdGFcbiAgY29uc3QgdXNlckRhdGFRdWVyeSA9IHVzZVVzZXJEYXRhKClcbiAgY29uc3QgdXNlclNpZ251cFF1ZXJ5ID0gdXNlVXNlclNpZ251cCgpXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgcHJvZmlsZSA9IHVzZXJEYXRhUXVlcnkuZGF0YT8ucHJvZmlsZVxuICAgIGNvbnN0IHNpZ251cCA9IHVzZXJTaWdudXBRdWVyeS5kYXRhPy5kYXRhXG4gICAgZm9ybS5yZXNldCh7XG4gICAgICAuLi5wcm9maWxlLFxuICAgICAgc3R5bGVwb2ludHM6IHtcbiAgICAgICAgXCJzdXAtYWdnXCI6IHByb2ZpbGU/LnN0eWxlcG9pbnRzPy5hZ2dyZXNzaXZlLFxuICAgICAgICBcIm9iai1zbGFcIjogcHJvZmlsZT8uc3R5bGVwb2ludHM/LnNsYXllcixcbiAgICAgICAgXCJhbmMtbW9iXCI6IHByb2ZpbGU/LnN0eWxlcG9pbnRzPy5tb2JpbGUsXG4gICAgICAgIFwiZmxlLWZvY1wiOiBwcm9maWxlPy5zdHlsZXBvaW50cz8uZm9jdXNlZCxcbiAgICAgIH0sXG4gICAgICBzbWFzaGdnOiB7XG4gICAgICAgIGxpbms6IHByb2ZpbGU/LnNtYXNoZ2dcbiAgICAgICAgICA/IGBzbWFzaC5nZy91c2VyLyR7cHJvZmlsZT8uc21hc2hnZ31gXG4gICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIGNvZGU6IHNpZ251cD8uY29uZmlybWF0aW9uQ29kZSxcbiAgICAgIH0sXG4gICAgICByZWNydWl0aW5nOiBzaWdudXA/LnJlY3J1aXRpbmcsXG4gICAgICBsZWdhbDogc2lnbnVwPy5sZWdhbCxcbiAgICB9KVxuICB9LCBbdXNlckRhdGFRdWVyeS5kYXRhLCB1c2VyU2lnbnVwUXVlcnkuZGF0YV0pXG5cbiAgLy8gSGFuZGxlIGZvcm0gc3VibWl0XG4gIGNvbnN0IGhhbmRsZVNpZ251cCA9IHJlZyA9PiB7XG4gICAgY29uc3QgZGl2ID0gbiA9PiBbTWF0aC5hYnMobiksIE51bWJlcihuKV1cbiAgICBjb25zdCBbc3VwcG9ydCwgYWdncmVzc2l2ZV0gPSBkaXYocmVnLnN0eWxlcG9pbnRzW1wic3VwLWFnZ1wiXSlcbiAgICBjb25zdCBbb2JqZWN0aXZlLCBzbGF5ZXJdID0gZGl2KHJlZy5zdHlsZXBvaW50c1tcIm9iai1zbGFcIl0pXG4gICAgY29uc3QgW2FuY2hvciwgbW9iaWxlXSA9IGRpdihyZWcuc3R5bGVwb2ludHNbXCJhbmMtbW9iXCJdKVxuICAgIGNvbnN0IFtmbGV4LCBmb2N1c2VkXSA9IGRpdihyZWcuc3R5bGVwb2ludHNbXCJmbGUtZm9jXCJdKVxuICAgIGNvbnN0IHByb2ZpbGUgPSB7XG4gICAgICBpZ246IHJlZy5pZ24sXG4gICAgICBzdzogcmVnLnN3LFxuICAgICAgcmFua3M6IHtcbiAgICAgICAgc3o6IHJlZy5yYW5rcy5zeixcbiAgICAgICAgdGM6IHJlZy5yYW5rcy50YyxcbiAgICAgICAgcm06IHJlZy5yYW5rcy5ybSxcbiAgICAgICAgY2I6IHJlZy5yYW5rcy5jYixcbiAgICAgIH0sXG4gICAgICBzdHlsZXBvaW50czoge1xuICAgICAgICBzdXBwb3J0LFxuICAgICAgICBhZ2dyZXNzaXZlLFxuICAgICAgICBvYmplY3RpdmUsXG4gICAgICAgIHNsYXllcixcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBtb2JpbGUsXG4gICAgICAgIGZsZXgsXG4gICAgICAgIGZvY3VzZWQsXG4gICAgICB9LFxuICAgICAgY3hwOiB7XG4gICAgICAgIGFtb3VudDogcmVnLmN4cC5hbW91bnQsXG4gICAgICAgIHBsYWNlbWVudDogTnVtYmVyKHJlZy5jeHAucGxhY2VtZW50KSxcbiAgICAgIH0sXG4gICAgICBzbWFzaGdnOiByZWcuc21hc2hnZy5saW5rLnNwbGl0KFwiL1wiKS5zbGljZSgtMSlbMF0sXG4gICAgfVxuICAgIGNvbnN0IHNpZ251cCA9IHtcbiAgICAgIHR6T2Zmc2V0OiBuZXcgRGF0ZSgpLmdldFRpbWV6b25lT2Zmc2V0KCksXG4gICAgICByZWNydWl0aW5nOiBCb29sZWFuKHJlZy5yZWNydWl0aW5nKSxcbiAgICAgIGNvbmZpcm1hdGlvbkNvZGU6IHJlZy5zbWFzaGdnPy5jb2RlIHx8IFwiW3N1Yl1cIixcbiAgICAgIGxlZ2FsOiBCb29sZWFuKHJlZy5sZWdhbCksXG4gICAgfVxuICAgIHVzZXJEYXRhTXV0Lm11dGF0ZShwcm9maWxlKVxuICAgIHVzZXJTaWdudXBNdXQubXV0YXRlKHNpZ251cClcbiAgICBuYXZpZ2F0ZShcImNvbXBsZXRlXCIsIHsgc3RhdGU6IHsgY29tcGxldGU6IHRydWUgfSB9KVxuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8Rm9ybUNvbnRhaW5lciBsb2NhdGlvbj17bG9jYXRpb259PlxuICAgICAgPEZyb21TdGF0dXNBbGVydHNcbiAgICAgICAgey4uLnsgdG91cm5leVF1ZXJ5LCB1c2VyU2lnbnVwUXVlcnksIHVzZXJKb2luZWRRdWVyeSB9fVxuICAgICAgLz5cbiAgICAgIDxmb3JtIGNsYXNzPVwiZm9ybVwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwic2VjdGlvbiBweC0wXCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cInRpdGxlXCI+RW50ZXIgeW91ciBpbi1nYW1lIGluZm88L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sdW1ucyBpcy0yIGlzLXZhcmlhYmxlXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sdW1uXCI+XG4gICAgICAgICAgICAgIDxGaWVsZCBsYWJlbD1cIkluLWdhbWUgbmFtZVwiIGV4cGFuZGVkPXt0cnVlfT5cbiAgICAgICAgICAgICAgICA8SW5wdXRcbiAgICAgICAgICAgICAgICAgIG5hbWU9XCJpZ25cIlxuICAgICAgICAgICAgICAgICAgY29udHJvbD17Zm9ybS5jb250cm9sfVxuICAgICAgICAgICAgICAgICAgZXJyb3JzPXtmb3JtLmVycm9yc31cbiAgICAgICAgICAgICAgICAgIG9wdGlvbnM9e3tcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tzOiBbMTBdLFxuICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgIHJ1bGVzPXt7IHJlcXVpcmVkOiBcIlRoaXMgZmllbGQgaXMgcmVxdWlyZWRcIiB9fVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgPEVycm9yTWVzc2FnZSBvcHRpb25zPXtbZm9ybS5lcnJvcnMsIFwiaWduXCJdfSAvPlxuICAgICAgICAgICAgICA8L0ZpZWxkPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sdW1uIGlzLTdcIj5cbiAgICAgICAgICAgICAgPEZpZWxkIGxhYmVsPVwiRnJpZW5kLWNvZGVcIiBleHBhbmRlZD17dHJ1ZX0+XG4gICAgICAgICAgICAgICAgPElucHV0XG4gICAgICAgICAgICAgICAgICBuYW1lPVwic3dcIlxuICAgICAgICAgICAgICAgICAgY29udHJvbD17Zm9ybS5jb250cm9sfVxuICAgICAgICAgICAgICAgICAgZXJyb3JzPXtmb3JtLmVycm9yc31cbiAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZT1cIlNXLVwiXG4gICAgICAgICAgICAgICAgICBvcHRpb25zPXt7XG4gICAgICAgICAgICAgICAgICAgIHByZWZpeDogXCJTV1wiLFxuICAgICAgICAgICAgICAgICAgICBibG9ja3M6IFsyLCA0LCA0LCA0XSxcbiAgICAgICAgICAgICAgICAgICAgZGVsaW1pdGVyOiBcIi1cIixcbiAgICAgICAgICAgICAgICAgICAgbnVtZXJpY09ubHk6IHRydWUsXG4gICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgcnVsZXM9e3tcbiAgICAgICAgICAgICAgICAgICAgbWluTGVuZ3RoOiB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IDE3LFxuICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiVGhpcyBmaWVsZCBpcyByZXF1aXJlZFwiLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDxFcnJvck1lc3NhZ2Ugb3B0aW9ucz17W2Zvcm0uZXJyb3JzLCBcInN3XCJdfSAvPlxuICAgICAgICAgICAgICA8L0ZpZWxkPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImZpZWxkXCI+XG4gICAgICAgICAgICA8RmllbGQgbGFiZWw9XCJSYW5rc1wiPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sdW1ucyBpcy0yIGlzLXZhcmlhYmxlXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbHVtblwiPlxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbHVtbnMgaXMtMiBpcy12YXJpYWJsZSBpcy1tb2JpbGVcIj5cbiAgICAgICAgICAgICAgICAgICAgPFJhbmtGaWVsZCBsYWJlbD1cIlNwbGF0IFpvbmVzXCI+XG4gICAgICAgICAgICAgICAgICAgICAgPElucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICB7Li4ucmFua1Byb3BzKFwicmFua3Muc3pcIiwgZm9ybS5jb250cm9sLCBmb3JtLmVycm9ycyl9XG4gICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICA8RXJyb3JNZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zPXtbZm9ybS5lcnJvcnMsIFwicmFua3Muc3pcIiwgPEludmFsaWRSYW5rIC8+XX1cbiAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICA8L1JhbmtGaWVsZD5cbiAgICAgICAgICAgICAgICAgICAgPFJhbmtGaWVsZCBsYWJlbD1cIlRvd2VyIENvbnRyb2xcIj5cbiAgICAgICAgICAgICAgICAgICAgICA8SW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgIHsuLi5yYW5rUHJvcHMoXCJyYW5rcy50Y1wiLCBmb3JtLmNvbnRyb2wsIGZvcm0uZXJyb3JzKX1cbiAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgIDxFcnJvck1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM9e1tmb3JtLmVycm9ycywgXCJyYW5rcy50Y1wiLCA8SW52YWxpZFJhbmsgLz5dfVxuICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgIDwvUmFua0ZpZWxkPlxuICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbHVtblwiPlxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbHVtbnMgaXMtMiBpcy12YXJpYWJsZSBpcy1tb2JpbGVcIj5cbiAgICAgICAgICAgICAgICAgICAgPFJhbmtGaWVsZCBsYWJlbD1cIlJhaW5tYWtlclwiPlxuICAgICAgICAgICAgICAgICAgICAgIDxJbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgey4uLnJhbmtQcm9wcyhcInJhbmtzLnJtXCIsIGZvcm0uY29udHJvbCwgZm9ybS5lcnJvcnMpfVxuICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgPEVycm9yTWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucz17W2Zvcm0uZXJyb3JzLCBcInJhbmtzLnJtXCIsIDxJbnZhbGlkUmFuayAvPl19XG4gICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgPC9SYW5rRmllbGQ+XG4gICAgICAgICAgICAgICAgICAgIDxSYW5rRmllbGQgbGFiZWw9XCJDbGFtIEJsaXR6XCI+XG4gICAgICAgICAgICAgICAgICAgICAgPElucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICB7Li4ucmFua1Byb3BzKFwicmFua3MuY2JcIiwgZm9ybS5jb250cm9sLCBmb3JtLmVycm9ycyl9XG4gICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICA8RXJyb3JNZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zPXtbZm9ybS5lcnJvcnMsIFwicmFua3MuY2JcIiwgPEludmFsaWRSYW5rIC8+XX1cbiAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICA8L1JhbmtGaWVsZD5cbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvRmllbGQ+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDxkaXYgY2xhc3M9XCJzZWN0aW9uIHB4LTAgcHQtNVwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0aXRsZVwiPlNldCB5b3VyIHN0eWxlcG9pbnRzIChwbGF5c3R5bGUpPC9kaXY+XG4gICAgICAgICAge1tcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgXCJTdXBwb3J0aXZlXCIsXG4gICAgICAgICAgICAgIFwiQWdncmVzc2l2ZVwiLFxuICAgICAgICAgICAgICBcIkhvdyB3b3VsZCB5b3UgY2hhcmFjdGVyaXplIHlvdXIgcGxheT9cIixcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXCJPYmplY3RpdmVcIiwgXCJTbGF5ZXJcIiwgXCJXaGF0IGRvIHlvdSBmb2N1cyBvbiB3aGVuIHBsYXlpbmc/XCJdLFxuICAgICAgICAgICAgW1wiQW5jaG9yXCIsIFwiTW9iaWxlXCIsIFwiV2hhdCBkb2VzIHlvdXIgcG9zaXRpb24gbG9vayBsaWtlP1wiXSxcbiAgICAgICAgICAgIFtcIkZsZXhpYmxlXCIsIFwiRm9jdXNlZFwiLCBcIkhvdyB3b3VsZCB5b3UgZGVzY3JpYmUgeW91ciB3ZWFwb24gcG9vbD9cIl0sXG4gICAgICAgICAgXS5tYXAoKGZpZWxkLCBpbmRleCkgPT4gKFxuICAgICAgICAgICAgPGRpdiBrZXk9e2luZGV4fSBjbGFzcz1cInNlY3Rpb24gcHgtMCBweS00XCI+XG4gICAgICAgICAgICAgIDxGaWVsZCBsYWJlbD17ZmllbGRbMl19PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJpcy1zaXplLTUgaXMtcHVsbGVkLXJpZ2h0XCI+e2ZpZWxkWzFdfTwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJpcy1zaXplLTVcIj57ZmllbGRbMF19PC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZpZWxkXCI+XG4gICAgICAgICAgICAgICAgICA8Q29udHJvbGxlclxuICAgICAgICAgICAgICAgICAgICBjb250cm9sPXtmb3JtLmNvbnRyb2x9XG4gICAgICAgICAgICAgICAgICAgIGFzPXs8aW5wdXQgLz59XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZT17NX1cbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJzbGlkZXIgaXMtZnVsbHdpZHRoIGlzLWxhcmdlIGlzLWNpcmNsZSBtdC0wXCJcbiAgICAgICAgICAgICAgICAgICAgdHlwZT1cInJhbmdlXCJcbiAgICAgICAgICAgICAgICAgICAgbmFtZT17c3R5bGVwb2ludHNOYW1lKGZpZWxkKX1cbiAgICAgICAgICAgICAgICAgICAgaWQ9e2ZpZWxkWzBdfVxuICAgICAgICAgICAgICAgICAgICBtaW49XCIxXCJcbiAgICAgICAgICAgICAgICAgICAgbWF4PVwiOVwiXG4gICAgICAgICAgICAgICAgICAgIHN0ZXA9XCIxXCJcbiAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDwvRmllbGQ+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICApKX1cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cInNlY3Rpb24gcHgtMFwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0aXRsZVwiPkVudGVyIHlvdXIgY29tcGV0aXRpdmUgZXhwZXJpZW5jZTwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJzZWN0aW9uIHB4LTAgcHktNFwiPlxuICAgICAgICAgICAgPEZpZWxkIGxhYmVsPVwiSG93IG1hbnkgdG91cm5hbWVudHMgaGF2ZSB5b3UgY29tcGV0ZWQgaW4/XCI+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJweS0zXCI+XG4gICAgICAgICAgICAgICAge1tcbiAgICAgICAgICAgICAgICAgIFwiVGhpcyBpcyBteSBmaXJzdCB0b3VybmFtZW50IDowXCIsXG4gICAgICAgICAgICAgICAgICBcIkkndmUgcGxheWVkIGluIG9uZSBvciB0d28gdG91cm5hbWVudHMuXCIsXG4gICAgICAgICAgICAgICAgICBcIkkndmUgcGxheWVkIGluIHNvbWUgdG91cm5hbWVudHMuXCIsXG4gICAgICAgICAgICAgICAgICBcIkkndmUgcGxheWVkIGluIGEgbG90IG9mIHRvdXJuYW1lbnRzLlwiLFxuICAgICAgICAgICAgICAgIF0ubWFwKChmaWVsZCwgaW5kZXgpID0+IChcbiAgICAgICAgICAgICAgICAgIDxkaXYga2V5PXtpbmRleH0gY2xhc3M9XCJmaWVsZFwiPlxuICAgICAgICAgICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICByZWY9e2Zvcm0ucmVnaXN0ZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6IFwiVGhpcyBmaWVsZCBpcyByZXF1aXJlZFwiLFxuICAgICAgICAgICAgICAgICAgICAgIH0pfVxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtmaWVsZH1cbiAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImlzLWNoZWNrcmFkaW8gaXMtbWVkaXVtXCJcbiAgICAgICAgICAgICAgICAgICAgICBuYW1lPVwiY3hwLmFtb3VudFwiXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZT1cInJhZGlvXCJcbiAgICAgICAgICAgICAgICAgICAgICBpZD17ZmllbGR9XG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgIDxsYWJlbCBodG1sRm9yPXtmaWVsZH0+e2ZpZWxkfTwvbGFiZWw+XG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICApKX1cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDxFcnJvck1lc3NhZ2Ugb3B0aW9ucz17W2Zvcm0uZXJyb3JzLCBcImN4cC5hbW91bnRcIl19IC8+XG4gICAgICAgICAgICA8L0ZpZWxkPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJzZWN0aW9uIHB4LTAgcHktNFwiPlxuICAgICAgICAgICAgPEZpZWxkIGxhYmVsPVwiV2hhdCBpcyB0aGUgaGlnaGVzdCBudW1iZXIgb2YgdGVhbXMgeW91J3ZlIHBsYWNlZCBhYm92ZT9cIj5cbiAgICAgICAgICAgICAgPGRpdiBzdHlsZT17eyBtYXhXaWR0aDogXCIxNXJlbVwiIH19PlxuICAgICAgICAgICAgICAgIDxJbnB1dFxuICAgICAgICAgICAgICAgICAgbmFtZT1cImN4cC5wbGFjZW1lbnRcIlxuICAgICAgICAgICAgICAgICAgY29udHJvbD17Zm9ybS5jb250cm9sfVxuICAgICAgICAgICAgICAgICAgZXJyb3JzPXtmb3JtLmVycm9yc31cbiAgICAgICAgICAgICAgICAgIG9wdGlvbnM9e3tcbiAgICAgICAgICAgICAgICAgICAgbnVtZXJpY09ubHk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrczogWzRdLFxuICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJoZWxwXCI+WW91IGNhbiBza2lwIHRoaXMgaWYgaXQncyBub3QgYXBwbGljYWJsZTwvZGl2PlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvRmllbGQ+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDxkaXYgY2xhc3M9XCJzZWN0aW9uIHB4LTBcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwidGl0bGVcIj5TZXQgdXAgc21hc2guZ2c8L2Rpdj5cbiAgICAgICAgICB7KCF0b3VybmV5UXVlcnkuZGF0YT8uaGFzQ2xvc2VkKCkgfHxcbiAgICAgICAgICAgIHVzZXJTaWdudXBRdWVyeS5kYXRhPy50eXBlID09PSBcInNpZ251cFwiKSAmJiAoXG4gICAgICAgICAgICA8PlxuICAgICAgICAgICAgICA8RmllbGQgbGFiZWw9XCJSZWdpc3RlciBvbiBzbWFzaC5nZywgY29weSB0aGUgY29uZmlybWF0aW9uIGNvZGUgd2hlbiBpdCBwb3BzIHVwLlwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJpbnB1dCBpcy1ub3JtYWwgcC0xXCIgc3R5bGU9e3sgaGVpZ2h0OiBcIjYwMHB4XCIgfX0+XG4gICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiBcIjRweFwiLFxuICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBcIjEwMCVcIixcbiAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93OiBcImhpZGRlblwiLFxuICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICA8aWZyYW1lXG4gICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3sgYm9yZGVyV2lkdGg6IFwiMTBweFwiIH19XG4gICAgICAgICAgICAgICAgICAgICAgdGl0bGU9XCJzbWFzaGdnXCJcbiAgICAgICAgICAgICAgICAgICAgICBzcmM9e2BodHRwczovL3NtYXNoLmdnLyR7dG91cm5leVF1ZXJ5LmRhdGE/LnNsdWd9L3JlZ2lzdGVyL2VtYmVkYH1cbiAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ9XCIxMDAlXCJcbiAgICAgICAgICAgICAgICAgICAgICB3aWR0aD1cIjEwMCVcIlxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDwvRmllbGQ+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmaWVsZFwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzZWN0aW9uIHB4LTAgcHktNFwiPlxuICAgICAgICAgICAgICAgICAgPEZpZWxkIGxhYmVsPVwiRW50ZXIgeW91ciBzbWFzaC5nZyBjb25maXJtYXRpb24gY29kZS5cIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT17eyBtYXhXaWR0aDogXCIyMGVtXCIgfX0+XG4gICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZpZWxkIGhhcy1hZGRvbnNcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250cm9sIGlzLWV4cGFuZGVkXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDxJbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9XCJzbWFzaGdnLmNvZGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2w9e2Zvcm0uY29udHJvbH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnM9e2Zvcm0uZXJyb3JzfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZT1cIiNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM9e3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VyY2FzZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrczogWzddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4OiBcIiNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVzPXt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAvXiNbMC05QS1GYS1mXXs2fSQvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkludmFsaWQgY29uZmlybWF0aW9uIGNvZGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5MZW5ndGg6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiVGhpcyBmaWVsZCBpcyByZXF1aXJlZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udHJvbFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiaW5wdXQgZWFzZSBpcy1tZWRpdW0gcHgtNSBpcy1zdGF0aWNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGZvcm0ud2F0Y2goXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic21hc2hnZy5jb2RlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiI2RiZGJkYlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxFcnJvck1lc3NhZ2Ugb3B0aW9ucz17W2Zvcm0uZXJyb3JzLCBcInNtYXNoZ2cuY29kZVwiXX0gLz5cbiAgICAgICAgICAgICAgICAgIDwvRmllbGQ+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC8+XG4gICAgICAgICAgKX1cbiAgICAgICAgICA8RmllbGRcbiAgICAgICAgICAgIGxhYmVsPXtcbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImlzLXNpemUtNFwiPlxuICAgICAgICAgICAgICAgIFBhc3RlIHRoZSB1cmwgb2YgeW91cntcIiBcIn1cbiAgICAgICAgICAgICAgICA8YVxuICAgICAgICAgICAgICAgICAgaHJlZj1cImh0dHBzOi8vc21hc2guZ2cvcHJvZmlsZVwiXG4gICAgICAgICAgICAgICAgICB0YXJnZXQ9XCJfYmxhbmtcIlxuICAgICAgICAgICAgICAgICAgcmVsPVwibm9yZWZlcnJlclwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAge1wiIFwifVxuICAgICAgICAgICAgICAgICAgc21hc2guZ2cgcHJvZmlsZVxuICAgICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgICAgICAuXG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgbWF4V2lkdGg6IFwiMjBlbVwiIH19PlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udHJvbCBpcy1tZWRpdW0gaGFzLWljb25zLXJpZ2h0XCI+XG4gICAgICAgICAgICAgICAgPElucHV0XG4gICAgICAgICAgICAgICAgICBuYW1lPVwic21hc2hnZy5saW5rXCJcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2w9e2Zvcm0uY29udHJvbH1cbiAgICAgICAgICAgICAgICAgIGVycm9ycz17Zm9ybS5lcnJvcnN9XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU9XCJzbWFzaC5nZy91c2VyL1wiXG4gICAgICAgICAgICAgICAgICBvcHRpb25zPXt7XG4gICAgICAgICAgICAgICAgICAgIGxvd2VyY2FzZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4OiBcInNtYXNoLmdnL3VzZXIvXCIsXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrczogWzIyXSxcbiAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICBydWxlcz17e1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuOiB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IC9ec21hc2hcXC5nZ1xcL3VzZXJcXC9bMC05QS1GYS1mXXs4fSQvLFxuICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiSW52YWxpZCB1c2VyIHNsdWdcIixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbWluTGVuZ3RoOiB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IDE1LFxuICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiVGhpcyBmaWVsZCBpcyByZXF1aXJlZFwiLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPEVycm9yTWVzc2FnZSBvcHRpb25zPXtbZm9ybS5lcnJvcnMsIFwic21hc2hnZy5saW5rXCJdfSAvPlxuICAgICAgICAgIDwvRmllbGQ+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwic2VjdGlvbiBweC0wIHB0LTVcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwidGl0bGVcIj5GaW5hbCBzdGVwczwvZGl2PlxuICAgICAgICAgIDxibG9ja3F1b3RlIGNsYXNzPVwic3VidGl0bGVcIj5cbiAgICAgICAgICAgIE1pc2Mgc3R1ZmYsIGFyZSBkb251dHMgY29uc2lkZXJlZCBiYWdlbHMuXG4gICAgICAgICAgPC9ibG9ja3F1b3RlPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJzZWN0aW9uIHB4LTAgcHktNFwiPlxuICAgICAgICAgICAgPEZpZWxkPlxuICAgICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICByZWY9e2Zvcm0ucmVnaXN0ZXJ9XG4gICAgICAgICAgICAgICAgdmFsdWU9e3RydWV9XG4gICAgICAgICAgICAgICAgY2xhc3M9XCJpcy1jaGVja3JhZGlvIGlzLW1lZGl1bVwiXG4gICAgICAgICAgICAgICAgbmFtZT1cInJlY3J1aXRpbmdcIlxuICAgICAgICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgICAgICAgICAgaWQ9XCJjeC0xXCJcbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgPGxhYmVsIGh0bWxGb3I9XCJjeC0xXCI+QXJlIHlvdSBjdXJyZW50bHkgcmVjcnVpdGluZz88L2xhYmVsPlxuICAgICAgICAgICAgPC9GaWVsZD5cbiAgICAgICAgICAgIDxGaWVsZD5cbiAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgcmVmPXtmb3JtLnJlZ2lzdGVyKHtcbiAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBcIlBsZWFzZSBhY2NlcHQgdGhlIHRlcm1zIGFuZCBjb25kaXRpb25zXCIsXG4gICAgICAgICAgICAgICAgfSl9XG4gICAgICAgICAgICAgICAgdmFsdWU9e3RydWV9XG4gICAgICAgICAgICAgICAgY2xhc3M9XCJpcy1jaGVja3JhZGlvIGlzLW1lZGl1bVwiXG4gICAgICAgICAgICAgICAgbmFtZT1cImxlZ2FsXCJcbiAgICAgICAgICAgICAgICB0eXBlPVwiY2hlY2tib3hcIlxuICAgICAgICAgICAgICAgIGlkPVwiY3gtMlwiXG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgIDxsYWJlbCBodG1sRm9yPVwiY3gtMlwiPlxuICAgICAgICAgICAgICAgIEkgYWdyZWUgdG8gdGhlIDxMaW5rIHRvPVwiL2xlZ2FsXCI+dGVybXMgYW5kIGNvbmRpdGlvbnM8L0xpbms+LlxuICAgICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgICAgICA8RXJyb3JNZXNzYWdlIG9wdGlvbnM9e1tmb3JtLmVycm9ycywgXCJsZWdhbFwiXX0gLz5cbiAgICAgICAgICAgIDwvRmllbGQ+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8RmllbGQ+XG4gICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICBvbkNsaWNrPXtmb3JtLmhhbmRsZVN1Ym1pdChoYW5kbGVTaWdudXApfVxuICAgICAgICAgICAgY2xhc3M9XCJidXR0b24gaXMtY2VudGVyZWQgaXMtcHJpbWFyeSBpcy1sYXJnZVwiXG4gICAgICAgICAgICBkaXNhYmxlZD17IXVzZXJKb2luZWRRdWVyeS5kYXRhIHx8IHRvdXJuZXlRdWVyeS5kYXRhPy5oYXNFbmRlZCgpfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIFN1Ym1pdFxuICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgIHshdXNlckpvaW5lZFF1ZXJ5LmRhdGEgJiYgKFxuICAgICAgICAgICAgPEVycm9yTWVzc2FnZVxuICAgICAgICAgICAgICBvcHRpb25zPXtbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgc3VibWl0OiB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6XG4gICAgICAgICAgICAgICAgICAgICAgXCJZb3UgbXVzdCBiZSBpbiB0aGUgT2ZmIHRoZSBEaWFsIGRpc2NvcmQgc2VydmVyIHRvIHBhcnRpY2lwYXRlXCIsXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJzdWJtaXRcIixcbiAgICAgICAgICAgICAgXX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgKX1cbiAgICAgICAgICB7dG91cm5leVF1ZXJ5LmRhdGE/Lmhhc0VuZGVkKCkgJiYgKFxuICAgICAgICAgICAgPEVycm9yTWVzc2FnZVxuICAgICAgICAgICAgICBvcHRpb25zPXtbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgc3VibWl0OiB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiUmVnaXN0cmF0aW9uIGlzIGNsb3NlZFwiLFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwic3VibWl0XCIsXG4gICAgICAgICAgICAgIF19XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICl9XG4gICAgICAgIDwvRmllbGQ+XG4gICAgICA8L2Zvcm0+XG4gICAgPC9Gb3JtQ29udGFpbmVyPlxuICApXG59XG5cbmNvbnN0IEZvcm1Db250YWluZXIgPSAoeyBsb2NhdGlvbiwgY2hpbGRyZW4gfSkgPT4gKFxuICA8UHJpdmF0ZVJvdXRlIGxvY2F0aW9uPXtsb2NhdGlvbn0+XG4gICAgPExheW91dCBwYWdlVGl0bGU9XCJTaWdudXBcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJzZWN0aW9uXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJjb250YWluZXIgaXMtZnVsbGhkXCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImNvbHVtbnMgaXMtY2VudGVyZWRcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2x1bW4gaXMtOVwiPntjaGlsZHJlbn08L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L0xheW91dD5cbiAgPC9Qcml2YXRlUm91dGU+XG4pXG5cbmNvbnN0IEZyb21TdGF0dXNBbGVydHMgPSAoe1xuICB0b3VybmV5UXVlcnksXG4gIHVzZXJTaWdudXBRdWVyeSxcbiAgdXNlckpvaW5lZFF1ZXJ5LFxufSkgPT4ge1xuICBjb25zdCBhbGVydHMgPSBbXVxuICBpZiAodG91cm5leVF1ZXJ5LmRhdGE/Lmhhc0VuZGVkKCkpIHtcbiAgICBhbGVydHMucHVzaCh7XG4gICAgICB0eXBlOiBcImluZm9cIixcbiAgICAgIG1lc3NhZ2U6IChcbiAgICAgICAgPD5cbiAgICAgICAgICA8Yj5SZWdpc3RyYXRpb24gaXMgY2xvc2VkPC9iPi4gQmUgb24gdGhlIGxvb2sgb3V0IGZvciB0b3VybmFtZW50cyBpblxuICAgICAgICAgIHRoZSBmdXR1cmUhXG4gICAgICAgIDwvPlxuICAgICAgKSxcbiAgICB9KVxuICB9IGVsc2UgaWYgKCF0b3VybmV5UXVlcnkuaXNMb2FkaW5nKSB7XG4gICAgaWYgKHVzZXJTaWdudXBRdWVyeS5kYXRhPy5kYXRhKSB7XG4gICAgICBhbGVydHMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwiaW5mb1wiLFxuICAgICAgICBtZXNzYWdlOiAoXG4gICAgICAgICAgPD5cbiAgICAgICAgICAgIDxiPllvdSBoYXZlIGFscmVhZHkgc2lnbmVkIHVwPC9iPi4gVG8gdXBkYXRlIHlvdXIgc2lnbnVwXG4gICAgICAgICAgICBpbmZvcm1hdGlvbiwgcmUtc3VibWl0IHRoaXMgZm9ybS5cbiAgICAgICAgICA8Lz5cbiAgICAgICAgKSxcbiAgICAgIH0pXG4gICAgfSBlbHNlIGlmICghdXNlclNpZ251cFF1ZXJ5LmlzTG9hZGluZykge1xuICAgICAgaWYgKHRvdXJuZXlRdWVyeS5kYXRhPy5oYXNDbG9zZWQoKSkge1xuICAgICAgICBhbGVydHMucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJ3YXJuaW5nXCIsXG4gICAgICAgICAgbWVzc2FnZTogKFxuICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgPGI+U2lnbnVwcyBoYXZlIGNsb3NlZDwvYj4uIFlvdSBjYW4gc3RpbGwgc3VibWl0IHRoaXMgZm9ybSBhbmRcbiAgICAgICAgICAgICAgc2lnbiB1cCBhcyBhIHN1Yi5cbiAgICAgICAgICAgIDwvPlxuICAgICAgICAgICksXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICAgIGlmICh1c2VySm9pbmVkUXVlcnkuZGF0YSA9PT0gZmFsc2UpIHtcbiAgICAgIGFsZXJ0cy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJkYW5nZXJcIixcbiAgICAgICAgbWVzc2FnZTogKFxuICAgICAgICAgIDw+WW91IG11c3QgYmUgaW4gdGhlIE9mZiB0aGUgRGlhbCBkaXNjb3JkIHNlcnZlciB0byBwYXJ0aWNpcGF0ZS48Lz5cbiAgICAgICAgKSxcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAge2FsZXJ0cy5tYXAoKGFsZXJ0LCBpKSA9PiAoXG4gICAgICAgIDxBbGVydCB0eXBlPXthbGVydC50eXBlfSBrZXk9e2l9PlxuICAgICAgICAgIDxzcGFuPnthbGVydC5tZXNzYWdlfTwvc3Bhbj5cbiAgICAgICAgPC9BbGVydD5cbiAgICAgICkpfVxuICAgIDwvPlxuICApXG59XG5cbmNvbnN0IEZpZWxkID0gKHsgbGFiZWwsIGV4cGFuZGVkLCBjaGlsZHJlbiB9KSA9PiAoXG4gIDxkaXYgY2xhc3M9XCJmaWVsZFwiPlxuICAgIDxkaXYgY2xhc3M9e2Bjb250cm9sICR7ZXhwYW5kZWQgJiYgXCJpcy1leHBhbmRlZFwifWB9PlxuICAgICAge2xhYmVsICYmIDxkaXYgY2xhc3M9XCJpcy1zaXplLTRcIj57bGFiZWx9PC9kaXY+fVxuICAgICAge2NoaWxkcmVufVxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbilcblxuY29uc3QgUmFua0ZpZWxkID0gKHsgbGFiZWwsIGNoaWxkcmVuIH0pID0+IChcbiAgPGRpdiBjbGFzcz1cImNvbHVtblwiPlxuICAgIDxkaXYgY2xhc3M9XCJjb250cm9sIGlzLWV4cGFuZGVkXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiaXMtc2l6ZS01XCI+e2xhYmVsfTwvZGl2PlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbilcblxuY29uc3QgSW5wdXQgPSBpbnB1dCA9PiAoXG4gIDxDb250cm9sbGVyXG4gICAgZGVmYXVsdFZhbHVlPVwiXCJcbiAgICB7Li4uaW5wdXR9XG4gICAgY2xhc3NOYW1lPXtgaW5wdXQgaXMtbWVkaXVtICR7XG4gICAgICBnZXQoaW5wdXQuZXJyb3JzLCBpbnB1dC5uYW1lKSAmJiBcImlzLWRhbmdlclwiXG4gICAgfWB9XG4gICAgYXM9ezxDbGVhdmUgLz59XG4gIC8+XG4pXG5cbmNvbnN0IEVycm9yTWVzc2FnZSA9ICh7IG9wdGlvbnM6IFtlcnJvcnMsIG5hbWUsIGxvbmdlc3RdIH0pID0+IHtcbiAgY29uc3QgZXJyb3IgPSBnZXQoZXJyb3JzLCBuYW1lKVxuXG4gIGlmIChlcnJvcikge1xuICAgIHJldHVybiA8cCBjbGFzcz1cImhlbHAgaXMtZGFuZ2VyXCI+e2Vycm9yLm1lc3NhZ2V9PC9wPlxuICB9IGVsc2Uge1xuICAgIHJldHVybiA8cCBjbGFzcz1cImhlbHAgaXMtZGFuZ2VyIGlzLWludmlzaWJsZVwiPntsb25nZXN0IHx8IDxiciAvPn08L3A+XG4gIH1cbn1cblxuY29uc3QgZ2V0ID0gKG9iaiwgcGF0aCkgPT4gcGF0aC5zcGxpdChcIi5cIikucmVkdWNlKChhY2MsIGN1cikgPT4gYWNjPy5bY3VyXSwgb2JqKVxuXG5jb25zdCBzdHlsZXBvaW50c05hbWUgPSAoW2xlZnQsIHJpZ2h0XSkgPT4ge1xuICBjb25zdCBwYXJzZSA9IGZpZWxkID0+IGZpZWxkLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgMylcbiAgcmV0dXJuIGBzdHlsZXBvaW50cy4ke3BhcnNlKGxlZnQpfS0ke3BhcnNlKHJpZ2h0KX1gXG59XG5cbmNvbnN0IHJhbmtQcm9wcyA9IChuYW1lLCBjb250cm9sLCBlcnJvcnMpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBuYW1lLFxuICAgIGNvbnRyb2wsXG4gICAgZXJyb3JzLFxuICAgIG9wdGlvbnM6IHsgZGVsaW1pdGVyOiBcIi5cIiwgYmxvY2tzOiBbNSwgMV0sIHVwcGVyY2FzZTogdHJ1ZSB9LFxuICAgIHJ1bGVzOiB7XG4gICAgICByZXF1aXJlZDogKFxuICAgICAgICA8PlxuICAgICAgICAgIFRoaXMgZmllbGQgaXMgcmVxdWlyZWRcbiAgICAgICAgICA8YnIgLz5cbiAgICAgICAgICA8YnIgLz5cbiAgICAgICAgPC8+XG4gICAgICApLFxuICAgICAgcGF0dGVybjoge1xuICAgICAgICB2YWx1ZTogLyheQy0kKXwoXkMkKXwoXkNcXCskKXwoXkItJCl8KF5CJCl8KF5CXFwrJCl8KF5BLSQpfCheQSQpfCheQVxcKyQpfCheUyQpfCheU1xcK1xcZCQpfCheWFsxLTldXFxkezN9KFxcLlxcZCk/JCkvLFxuICAgICAgICBtZXNzYWdlOiA8SW52YWxpZFJhbmsgLz4sXG4gICAgICB9LFxuICAgIH0sXG4gIH1cbn1cblxuY29uc3QgSW52YWxpZFJhbmsgPSAoKSA9PiAoXG4gIDw+XG4gICAgSW52YWxpZCBSYW5rXG4gICAgPGJyIC8+XG4gICAgZXg6e1wiIFwifVxuICAgIHtbXCJDXCIsIFwiQS1cIiwgXCJTKzBcIiwgXCJYMjM1MC4xXCJdLm1hcCgoZmllbGQsIGluZGV4KSA9PiAoXG4gICAgICA8c3BhbiBrZXk9e2luZGV4fT5cbiAgICAgICAgPGNvZGUgY2xhc3M9XCJoYXMtdGV4dC1kYW5nZXJcIiBrZXk9e2luZGV4fT5cbiAgICAgICAgICB7ZmllbGR9XG4gICAgICAgIDwvY29kZT5cbiAgICAgICAge2luZGV4ICE9PSAzICYmIFwiLCBcIn1cbiAgICAgIDwvc3Bhbj5cbiAgICApKX1cbiAgPC8+XG4pXG5cbi8vIGNvbnN0IFNpZ251cCA9ICh7IGxvY2F0aW9uIH0pID0+IChcbi8vICAgPFByaXZhdGVSb3V0ZSBsb2NhdGlvbj17bG9jYXRpb259IHJlZGlyZWN0PVwiL3NpZ251cFwiIGNvbXBvbmVudD17Rm9ybX0gLz5cbi8vIClcblxuZXhwb3J0IGRlZmF1bHQgU2lnbnVwXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///cttA\n')}}]);